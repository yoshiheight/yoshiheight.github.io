<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    
            <meta name="robots" content="noindex" />
        
    
            <meta name="robots" content="nofollow" />
        
    <meta name="description" content="C#とTypeScriptに関することをメインに書いています。" />

    <title>
        
                    [C#] クロージャやデリゲートは暗黙的にインスタンス生成されるので注意 | Programmer&#39;s Note
                
    </title>

    
            <link rel="stylesheet" href="/sitegen-2.1.0/css/sitegen.css" />
        
            <link rel="stylesheet" href="/sitegen-2.1.0/css/sitegen-article.css" />
        

    <script type="module" src="/sitegen-2.1.0/js/initialize.js"></script>

    
    <link rel="icon" type="image/png" href="/images/favicon-32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="/images/favicon-48.png" sizes="48x48" />
    <link rel="icon" type="image/png" href="/images/favicon-64.png" sizes="64x64" />
    <link rel="icon" type="image/png" href="/images/favicon-128.png" sizes="128x128" />
    <link rel="icon" type="image/png" href="/images/favicon-256.png" sizes="256x256" />
    <link rel="apple-touch-icon" href="/images/favicon-256.png" sizes="256x256" />
    <link rel="stylesheet" href="/css/custom-1.0.css" />
</head>
<body>
    <!-- サイトヘッダー -->
    <header id="sdi-header">
        <div id="sdi-header-inner">
            <div id="sdi-site-name"><a href="/">Programmer&#39;s Note</a></div>
            <div id="sdi-menu">
                <div class="sdc-menu-section">
                    
                                            <div>
                                                <a href="/categories/demo/">Demo</a>
                                            </div>
                                        
                                            <div>
                                                <a href="/categories/tech/">Tech</a>
                                            </div>
                                        
                                            <div>
                                                <a href="/categories/scrap/">Scrap</a>
                                            </div>
                                        
                </div>
                <div class="sdc-menu-section">
                    <div>
                        <a href="/tags/">Tags</a>
                    </div>
                    <div>
                        <a href="/search/">Search</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- メインコンテンツ -->
    <div id="sdi-container">
        <div id="sdi-container-inner">
            <main>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.6.0/build/styles/base16/nova.min.css" />
<script type="module">
    import hljs from "https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.6.0/build/es/highlight.min.js";
    hljs.highlightAll();
</script>
<script type="module">
    import mermaid from "https://unpkg.com/mermaid@9.1.3/dist/mermaid.esm.min.mjs";
    mermaid.initialize({ startOnLoad: true, theme: "base" });
</script>

<article id="sdi-entry-article">
    <!-- 記事ヘッダー -->
    <header>
        <!-- 記事タイトル -->
        <h1>[C#] クロージャやデリゲートは暗黙的にインスタンス生成されるので注意</h1>

        <div id="sdi-article-header-annotation">
            <!-- タグ -->
            <div class="sdc-tags">
                <div class="sdc-tag sdc-primary-tag sdc-primary-tag2">
                    <a href="/categories/scrap/">Scrap</a>
                </div>
                
                                    <div class="sdc-tag">
                                        <a href="/tags/cs/">C#</a>
                                    </div>
                                
            </div>

            <!-- 日付 -->
            <time datetime="2019-10-07">2019-10-07</time>
        </div>
    </header>

    <!-- 記事内容 -->
    <div id="sdi-article-body">
<h3>はじめに</h3>
<p>クロージャやデリゲートを使用した場合、実際にはインスタンスがヒープ上に確保されています。</p>
<ul>
<li>クロージャ（ローカル変数をキャプチャする匿名関数/ローカル関数）
<ul>
<li>ローカル変数をキャプチャすると、その変数をフィールドに持つクラスが自動的に定義され、そのインスタンスが暗黙的に生成される</li>
</ul>
</li>
<li>デリゲート
<ul>
<li>匿名関数や通常のメソッドをデリゲート変数に代入すると、デリゲートのインスタンスが暗黙的に生成される</li>
</ul>
</li>
</ul>
<p>パフォーマンス的に問題ない場合は特に対応は不要ですが、インスタンス生成されていることは意識しておいた方がいいです。
また、コンパイラによって最適化されるケースもあるらしいので、ufcppさんの記事を参考に確認してみました。</p>
<ul>
<li>[雑記] 匿名関数のコンパイル結果
<ul>
<li><a href="https://ufcpp.net/study/csharp/sp2_anonymousmethod.html">https://ufcpp.net/study/csharp/sp2_anonymousmethod.html</a></li>
</ul>
</li>
<li>[雑記] デリゲートの内部
<ul>
<li><a href="https://ufcpp.net/study/csharp/functional/miscdelegateinternal/">https://ufcpp.net/study/csharp/functional/miscdelegateinternal/</a></li>
</ul>
</li>
</ul>
<p>環境は以下。</p>
<ul>
<li>.NET Core 3.0 / C# 8.0</li>
<li>ILSpy（逆コンパイルツール）
<ul>
<li><a href="https://github.com/icsharpcode/ILSpy">https://github.com/icsharpcode/ILSpy</a></li>
<li>ILSpy起動後、ツールバーの言語バージョン選択で「C# 1.0 / VS.NET」を指定</li>
</ul>
</li>
</ul>
<h3>クロージャに対して最適化が行われるケース1</h3>
<p>ローカル関数のクロージャで且つデリゲートに代入せずに直接呼び出している場合、構造体を使用した最適化が行われるそうなので試してみました。</p>
<h4>ソースコード</h4>
<pre><code class="language-cs">using System;

class Program
{
    static void Main(string[] args)
    {
        var sample = new Sample();
        sample.Test(10, &quot;あいうえ&quot;);
    }
}

class Sample
{
    public void Test(int n, string str)
    {
        Update();

        Console.WriteLine(n + str);

        void Update()
        {
            n++;
            str += &quot;お&quot;;
        }
    }
}
</code></pre>
<h4>逆コンパイル</h4>
<pre><code class="language-cs">internal class Sample
{
    [StructLayout(LayoutKind.Auto)]
    [CompilerGenerated]
    private struct &lt;&gt;c__DisplayClass0_0
    {
        public int n;

        public string str;
    }

    public void Test(int n, string str)
    {
        &lt;&gt;c__DisplayClass0_0 &lt;&gt;c__DisplayClass0_ = default(&lt;&gt;c__DisplayClass0_0);
        &lt;&gt;c__DisplayClass0_.n = n;
        &lt;&gt;c__DisplayClass0_.str = str;
        &lt;Test&gt;g__Update|0_0(ref &lt;&gt;c__DisplayClass0_);
        Console.WriteLine(&lt;&gt;c__DisplayClass0_.n.ToString() + &lt;&gt;c__DisplayClass0_.str);
    }

    [CompilerGenerated]
    private static void &lt;Test&gt;g__Update|0_0(ref &lt;&gt;c__DisplayClass0_0 P_0)
    {
        P_0.n++;
        P_0.str += &quot;お&quot;;
    }
}
</code></pre>
<p>キャプチャした変数は構造体に格納され、その構造体はref渡しされるように最適化されていました。</p>
<h3>クロージャに対して最適化が行われるケース2</h3>
<p>同じスコープ内に複数の匿名関数がある場合、それらは同じクラスにまとめられるそうなので試してみました。</p>
<h4>ソースコード</h4>
<pre><code class="language-cs">using System;

class Program
{
    static void Main(string[] args)
    {
        var sample = new Sample();
        sample.Test();
    }
}

class Sample
{
    public void Test()
    {
        var num = 0;
        Invoke(() =&gt; num += 10);
        Invoke(() =&gt; num += 100);
    }

    private void Invoke(Action action)
    {
        action();
    }
}
</code></pre>
<h4>逆コンパイル</h4>
<pre><code class="language-cs">internal class Sample
{
    [CompilerGenerated]
    private sealed class &lt;&gt;c__DisplayClass0_0
    {
        public int num;

        internal void &lt;Test&gt;b__0()
        {
            num += 10;
        }

        internal void &lt;Test&gt;b__1()
        {
            num += 100;
        }
    }

    public void Test()
    {
        int num = 0;
        &lt;&gt;c__DisplayClass0_0 @object;
        Invoke(new Action(@object.&lt;Test&gt;b__0));
        Invoke(new Action(@object.&lt;Test&gt;b__1));
    }

    private void Invoke(Action action)
    {
        action();
    }
}
</code></pre>
<p>複数の匿名関数が、同じクラスにまとめられていました。</p>
<h3>デリゲートに対して最適化が行われるケース1</h3>
<p>匿名関数が静的メソッドに展開可能な場合、シングルトンとして展開されるそうなので試してみました。</p>
<h4>ソースコード</h4>
<pre><code class="language-cs">using System;

class Program
{
    static void Main(string[] args)
    {
        var func1 = Sample.GetFunc();
        var func2 = Sample.GetFunc();

        Console.WriteLine(&quot;ReferenceEquals: &quot; + ReferenceEquals(func1, func2));
    }
}

class Sample
{
    public static Func&lt;int, int&gt; GetFunc()
    {
        return n =&gt; n * n; // (1)
        //return n =&gt; Squared(n); // (2)
        //return Squared; // (3)
    }

    private static int Squared(int n)
    {
        return n * n;
    }
}
</code></pre>
<h4>実行結果</h4>
<pre><code class="language-plaintext">(1)の場合  ReferenceEquals: True
(2)の場合  ReferenceEquals: True
(3)の場合  ReferenceEquals: False
</code></pre>
<p><code>(1)</code>と<code>(2)</code>は常に同じインスタンスを返していました。</p>
<h4>逆コンパイル</h4>
<pre><code class="language-cs">internal class Sample
{
    [Serializable]
    [CompilerGenerated]
    private sealed class &lt;&gt;c
    {
        public static readonly &lt;&gt;c &lt;&gt;9 = new &lt;&gt;c();

        public static Func&lt;int, int&gt; &lt;&gt;9__0_0;

        internal int &lt;GetFunc&gt;b__0_0(int n)
        {
            return n * n;
        }
    }

    public static Func&lt;int, int&gt; GetFunc()
    {
        return &lt;&gt;c.&lt;&gt;9__0_0 ?? (&lt;&gt;c.&lt;&gt;9__0_0 = new Func&lt;int, int&gt;(&lt;&gt;c.&lt;&gt;9.&lt;GetFunc&gt;b__0_0));
    }

    private static int Squared(int n)
    {
        return n * n;
    }
}
</code></pre>
<p>ufcppさんの記事によると、静的メソッドのデリゲートは効率が悪いそうで、最適化としてシングルトンとして展開され、更にデリゲート変数は静的フィールドで保持されていました。</p>
<p>但し、<code>(3)</code>のように静的メソッドを直接デリゲート変数に代入した場合、最適化は行われませんでした（なので、<code>(2)</code>のように匿名関数をはさんだ方が効率がいい）。</p>
<h3>デリゲートに対して最適化が行われるケース2</h3>
<p>いろいろ試していて気付いたケースです。</p>
<p>ループ中の匿名関数に対するデリゲートですが、その匿名関数がループ外のローカル変数をキャプチャしている場合、デリゲート変数を保持する最適化が行われていました
（その匿名関数についてはインスタンスフィールドやインスタンスメソッドを使用している/いないは関係ない）。</p>
<h4>ソースコード</h4>
<pre><code class="language-cs">using System;
using System.Collections.Generic;

class Program
{
    static void Main(string[] args)
    {
        var sample = new Sample();
        sample.Test();

        Console.WriteLine(&quot;ReferenceEquals: &quot;
            + ReferenceEquals(sample.List1[0], sample.List1[1]));

        Console.WriteLine(&quot;ReferenceEquals: &quot;
            + ReferenceEquals(sample.List2[0], sample.List2[1]));
    }
}

class Sample
{
    public readonly List&lt;Action&gt; List1 = new List&lt;Action&gt;();
    public readonly List&lt;Action&gt; List2 = new List&lt;Action&gt;();

    public void Test()
    {
        var num = 0;
        for (var i = 0; i &lt; 2; i++)
        {
            List1.Add(() =&gt; num += 10);
            List2.Add(() =&gt; num += 100);
        }
    }
}
</code></pre>
<h4>実行結果</h4>
<pre><code class="language-plaintext">ReferenceEquals: True
ReferenceEquals: True
</code></pre>
<h4>逆コンパイル</h4>
<pre><code class="language-cs">internal class Sample
{
    [CompilerGenerated]
    private sealed class &lt;&gt;c__DisplayClass2_0
    {
        public int num;

        public Action &lt;&gt;9__0;

        public Action &lt;&gt;9__1;

        internal void &lt;Test&gt;b__0()
        {
            num += 10;
        }

        internal void &lt;Test&gt;b__1()
        {
            num += 100;
        }
    }

    public readonly List&lt;Action&gt; List1 = new List&lt;Action&gt;();

    public readonly List&lt;Action&gt; List2 = new List&lt;Action&gt;();

    public void Test()
    {
        int num = 0;
        for (int i = 0; i &lt; 2; i++)
        {
            &lt;&gt;c__DisplayClass2_0 &lt;&gt;c__DisplayClass2_;
            Action action;
            List1.Add(&lt;&gt;c__DisplayClass2_.&lt;&gt;9__0 ?? (action = new Action(&lt;&gt;c__DisplayClass2_.&lt;Test&gt;b__0)));
            Action action2;
            List2.Add(&lt;&gt;c__DisplayClass2_.&lt;&gt;9__1 ?? (action2 = new Action(&lt;&gt;c__DisplayClass2_.&lt;Test&gt;b__1)));
        }
    }
}
</code></pre>
<p>ループ中でデリゲート変数を使い回すように最適化されていました。</p>
<p>但し、「ループ外のローカル変数のキャプチャ」という条件を満たさない場合、この最適化は行われませんでした。</p>
<h3>その他、対策</h3>
<p>自分が確認した限りでは、今回最適化が行われたケース以外については、自動的に最適化されることはありませんでした（将来的には分かりませんが）。</p>
<p>もし最適化に頼らず実装を明示的にしたい場合や、パフォーマンス的に問題になる場合、</p>
<ul>
<li>不要なローカル変数のキャプチャは避ける</li>
<li>デリゲート変数を保持して使い回す</li>
</ul>
<p>等の対策をした方がいいです。</p>
<p>また .NET のクラスライブラリには、不要なローカル変数のキャプチャを回避する為のシグネチャが用意されているものがあります。
例えば<code>ConcurrentDictionary&lt;TKey, TValue&gt;.GetOrAdd</code>メソッドですが、以下のシグネチャがありますが、</p>
<pre><code class="language-plaintext">1. TValue GetOrAdd(TKey key, TValue value)
2. TValue GetOrAdd(TKey key, Func&lt;TKey, TValue&gt; valueFactory)
3. TValue GetOrAdd&lt;TArg&gt;(TKey key, Func&lt;TKey, TArg, TValue&gt; valueFactory, TArg factoryArgument)
</code></pre>
<p>値生成用の<code>valueFactory</code>に渡したいパラメータ（ローカル変数 or インスタンス変数）がある場合、</p>
<ul>
<li><code>2</code>ではなく<code>3</code>を使用することで<code>factoryArgument</code>でパラメータを渡す</li>
<li><code>valueFactory</code>自体は静的メソッドに展開可能な匿名関数にしておく</li>
</ul>
<p>とすることで、不要なローカル変数のキャプチャを回避でき、また最適化によってデリゲート変数も静的フィールドで保持されるので、
<code>GetOrAdd</code>呼び出し時に発生するクロージャやデリゲートのインスタンス生成を無くすことができます。</p>
<h3>おわりに</h3>
<p>GCがある言語ではヒープの使用状況、確保/解放の負荷、断片化などについてあまり意識しなくなってきましたが、処理によってはパフォーマンスに影響がでる場合もあるので注意が必要です。</p>

    </div>
</article>
            </main>
        </div>
    </div>

    <!-- サイトフッター -->
    <footer id="sdi-footer">
        <div id="sdi-footer-inner">
            
            <!-- プロフィール -->
            <div style="font-size: 115%; line-height: 1.1;">
                <div style="display: flex;">
                    <div style="flex-shrink: 0;">
                        <img src="/images/favicon-128.png" style="margin-right: 20px; border: 2px solid #e4e4e4; border-radius: 50%;" />
                    </div>
                    <div style="padding-top: 5px;">
                        <div style="display: flex; align-items: flex-end; flex-wrap: wrap; column-gap: 8px;">
                            <div style="font-size: 110%;">Yoshiheight</div>
                            <div>/</div>
                            <div style="font-size: 90%;">Programmer</div>
                        </div>
                        <div style="margin: 0.5em 0;">C#とTypeScriptに関することをメインに書いています。</div>
                        <div style="margin-top: 25px; text-decoration: underline;">
                            <a href="https://github.com/yoshiheight">GitHub</a>
                        </div>
                    </div>
                </div>
            </div>

            <div style="text-align: center; font-size: 98%;">
                Generated by <a style="text-decoration: underline;" href="https://github.com/yoshiheight/Sitegen">Sitegen</a>
            </div>
        </div>
    </footer>
</body>
</html>
