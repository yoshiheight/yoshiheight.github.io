[{
  "url": "/articles/420af11cac47421f800985af465d6750/",
  "date": "2018-12-05",
  "title": "[C\u002B\u002B] 参照カウント式スマートポインタを自作",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "C\u002B\u002B",
      "url": "/tags/cpp/"
    }
  ],
  "content": "はじめに かなり前に久しぶりにC\u002B\u002Bで仕事をする機会があり、リハビリ用になにか適当に作ろうと思い、なんとなく書いた「参照カウント式スマートポインタ」です。 boost::shared_ptrの簡易版みたいなものです。 実装 templateclass T class SharedPtr { // Constructors public: SharedPtr(); SharedPtr(const SharedPtrT src); explicit SharedPtr(T* ptr); ~SharedPtr(); static SharedPtrT Create(T* ptr) { return SharedPtrT(ptr); } // Operations public: // アロー演算子 T* operator -() const { return m_ptr; } // 変換演算子 operator T*() const { return m_ptr; } // 参照演算子 T operator *() const { return *m_ptr; } // 代入演算子 SharedPtrT operator =(const SharedPtrT src); // Member Function public: T* Get() const { return m_ptr; } int __UseCount() const { return (m_ptr == NULL) ? 0 : (*m_pCount); } private: void CopyImpl(const SharedPtrT src); void DeleteCheck(); // Data Member private: T* m_ptr; int* m_pCount; }; templateclass T SharedPtrT::SharedPtr() : m_ptr(NULL), m_pCount(NULL) { std::cout SharedPtrT::SharedPtr() std::endl; } templateclass T SharedPtrT::SharedPtr(const SharedPtrT src) : m_ptr(NULL), m_pCount(NULL) { CopyImpl(src); std::cout SharedPtrT::SharedPtr(const SharedPtr src) std::endl; } templateclass T SharedPtrT::SharedPtr(T* ptr) : m_ptr(NULL), m_pCount(NULL) { m_ptr = ptr; m_pCount = new int(1); std::cout SharedPtrT::SharedPtr(T* ptr) std::endl; } templateclass T SharedPtrT::~SharedPtr() { std::cout SharedPtrT::~SharedPtr() std::endl; DeleteCheck(); } templateclass T SharedPtrT SharedPtrT::operator =(const SharedPtr src) { CopyImpl(src); return *this; } templateclass T void SharedPtrT::CopyImpl(const SharedPtrT src) { if (this != src) { if (m_ptr != src.m_ptr) { DeleteCheck(); if (src.m_ptr != NULL) { m_ptr = src.m_ptr; m_pCount = src.m_pCount; (*m_pCount)\u002B\u002B; } } } } templateclass T void SharedPtrT::DeleteCheck() { if (m_ptr != NULL) { (*m_pCount)--; if ((*m_pCount) == 0) { delete m_ptr; m_ptr = NULL; delete m_pCount; m_pCount = NULL; } } } テストコード class ShareTest { public: ShareTest() : num(-1) {} ~ShareTest() {} int num; }; int main(int argc, char* argv[]) { // スコープを作っておいて最後に _CrtDumpMemoryLeaksを呼び出す { SharedPtrShareTest spTest1(new ShareTest()); { SharedPtrShareTest spTest2(spTest1); SharedPtrShareTest spTest3; SharedPtrShareTest spTest4; ((ShareTest*) spTest1)-num = 5; spTest3 = spTest1; std::cout spTest1-num = spTest1-num std::endl; std::cout spTest2-num = spTest2-num std::endl; std::cout spTest3-num = spTest3-num std::endl; std::cout spTest4.use_count() = spTest4.__UseCount() std::endl; std::cout spTest3.use_count() = spTest3.__UseCount() std::endl; std::cout spTest2.use_count() = spTest2.__UseCount() std::endl; if (spTest4 == NULL) { std::cout NULL std::endl; } } std::cout spTest1.use_count() = spTest1.__UseCount() std::endl; } _CrtDumpMemoryLeaks(); return 0; } 実行結果 SharedPtrT::SharedPtr(T* ptr) SharedPtrT::SharedPtr(const SharedPtr src) SharedPtrT::SharedPtr() SharedPtrT::SharedPtr() spTest1-num = 5 spTest2-num = 5 spTest3-num = 5 spTest4.use_count() = 0 spTest3.use_count() = 3 spTest2.use_count() = 3 NULL SharedPtrT::~SharedPtr() SharedPtrT::~SharedPtr() SharedPtrT::~SharedPtr() spTest1.use_count() = 1 SharedPtrT::~SharedPtr() とりあえず、ちゃんと機能しているようです。"
},{
  "url": "/articles/baec0664c919499cab78040ac178c61c/",
  "date": "2018-12-04",
  "title": "Flexboxで可変幅の子ボックスが親ボックスからはみ出る現象の回避",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "CSS",
      "url": "/tags/css/"
    },
    {
      "name": "Web全般",
      "url": "/tags/general-web/"
    }
  ],
  "content": "はじめに 久しぶりにWeb系の技術を調べていて、CSS3でFlexboxレイアウトなるものが追加されたと最近知りました。 Web系の、 なんでこんな基本的なことが標準機能にないんだ！ なんでベンダー毎で仕様が違うんだ！ といった不満が、HTML5、CSS3、ECMAScript 2015でやっと改善されてきた気がします。 floatなんか使わない、横並びはFlexboxで統一しよう、と書き換えていたのですが、子ボックスが親ボックスからはみ出る現象が起きていたので、解決策を記載します。 現象 以下のようなHTMLを書くと、 div style=width: 200px; display: flex; border: solid 3px black; div style=flex: none; width: 100px; background-color: lightblue; 固定幅Box /div div style=flex: 1; background-color: pink; 可変幅Box pre style=overflow-x: auto; overflow-wrap: normal;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/pre /div /div 以下のように可変幅の子ボックスが、親ボックスからはみ出てしまいます。 \u003Cdiv style=\u0022width: 200px; display: flex; border: solid 3px black;\u0022\u003E \u003Cdiv style=\u0022flex: none; width: 100px; background-color: lightblue;\u0022\u003E 固定幅Box \u003C/div\u003E \u003Cdiv style=\u0022flex: 1; background-color: pink;\u0022\u003E 可変幅Box \u003Cpre style=\u0022overflow-x: auto; overflow-wrap: normal;\u0022\u003Eaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u003C/pre\u003E \u003C/div\u003E \u003C/div\u003E 本来はpre要素に横スクロールバーが出てほしいところです。 解決策 min-widthの初期値がautoになっているのが原因のようです。 https://developer.mozilla.org/ja/docs/Web/CSS/min-width 以下のようにすると解決します。 div style=width: 200px; display: flex; border: solid 3px black; div style=flex: none; width: 100px; background-color: lightblue; 固定幅Box /div !-- min-width: 0; を追加 -- div style=flex: 1; min-width: 0; background-color: pink; 可変幅Box pre style=overflow-x: auto; overflow-wrap: normal;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/pre /div /div ちゃんと親に収まり、pre要素には横スクロールバーが表示されるようになりました。 \u003Cdiv style=\u0022width: 200px; display: flex; border: solid 3px black;\u0022\u003E \u003Cdiv style=\u0022flex: none; width: 100px; background-color: lightblue;\u0022\u003E 固定幅Box \u003C/div\u003E \u003C!-- min-width: 0; を追加 --\u003E \u003Cdiv style=\u0022flex: 1; min-width: 0; background-color: pink;\u0022\u003E 可変幅Box \u003Cpre style=\u0022overflow-x: auto; overflow-wrap: normal;\u0022\u003Eaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u003C/pre\u003E \u003C/div\u003E \u003C/div\u003E"
},{
  "url": "/articles/dd6ee3d74e8943ca82721feb84aaf48e/",
  "date": "2018-12-03",
  "title": "[C#] Pandocを外部プロセスとして起動し標準入出力でやりとりする",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "C#",
      "url": "/tags/cs/"
    },
    {
      "name": "Pandoc",
      "url": "/tags/pandoc/"
    }
  ],
  "content": "はじめに ドキュメント変換ツール「Pandoc」を、表題のとおり試してみました。 Pandoc http://pandoc.org/ 静的サイトジェネレーターを自作中なのですが、Pandocは以前使ったことがあったので、C#から使用できないかと色々試していました。 最終的には外部プロセスとして起動する関係上、時間がかかりすぎるのであきらめたのですが、 標準入出力でやりとりする際に文字コードを指定するといった工夫が必要だったので、備忘録としてサンプルコードを記載します。 単純にMarkdownをHTMLに変換するのが目的であればMarkDigをおすすめします。 MarkDig https://www.nuget.org/packages/Markdig/ 実装 class Program { static void Main() { var markdown = @ # はじめに * これはPandocでHTML変換するサンプルです。 \u0060\u0060\u0060 var i = 3; \u0060\u0060\u0060 ; Console.WriteLine( StartPandoc(@C:\\Pandoc\\pandoc.exe, -f markdown -t html5, markdown)); } static string StartPandoc(string pandocPath, string args, string input) { using (var process = new Process()) { process.StartInfo.FileName = pandocPath; process.StartInfo.Arguments = args; process.StartInfo.UseShellExecute = false; process.StartInfo.CreateNoWindow = true; process.StartInfo.RedirectStandardInput = true; process.StartInfo.RedirectStandardOutput = true; process.StartInfo.StandardOutputEncoding = Encoding.UTF8; process.Start(); using (process.StandardInput) using (var sw = new StreamWriter(process.StandardInput.BaseStream, Encoding.UTF8, 1024, true)) { sw.Write(input); } var output = process.StandardOutput.ReadToEnd(); process.WaitForExit(); return output; } } } 実行結果 h1 id=はじめにはじめに/h1 ul lipこれはPandocでHTML変換するサンプルです。/p precodevar i = 3;/code/pre/li /ul ちゃんとHTMLに変換されています。"
},{
  "url": "/articles/8df409a9cfdf41e8b67099026cddbc66/",
  "date": "2018-12-02",
  "title": "[C\u002B\u002B] DirectX9で太陽系を描画する",
  "category": {
    "order": 0,
    "name": "Demo",
    "url": "/categories/demo/"
  },
  "tags": [
    {
      "name": "3D",
      "url": "/tags/3d/"
    },
    {
      "name": "DirectX",
      "url": "/tags/directx/"
    },
    {
      "name": "C\u002B\u002B",
      "url": "/tags/cpp/"
    }
  ],
  "content": "はじめに 3Dプログラミング学習用に昔作成したサンプルをアップしました。 https://github.com/yoshiheight/Sample.D3DGalaxy \u003Cdiv style=\u0022max-width: 640px;\u0022\u003E\u003Cvideo src=\u0022/files/d3d-galaxy/d3d-galaxy.mp4\u0022 controls\u003E\u003C/video\u003E\u003C/div\u003E 仕様 惑星の大きさ、惑星間の距離は実際の値を反映 軌道傾斜角、楕円軌道は無視 カメラは「原点を注視するモード」「惑星を一定距離で注視するモード」を切り替え可能 「惑星を一定距離で注視するモード」の場合、惑星間を移動可能 太陽 \u003E 惑星公転 \u003E 衛星公転は、行列の親子関係で処理する 周囲の星々は天球を使って処理する 操作方法 キー |操作 -----|-------------- テンキー 1 / 3 |カメラX軸移動（\u002B Ctrl で回転） テンキー 5 / 2 |カメラY軸移動（\u002B Ctrl で回転） テンキー 9 / 6 |カメラZ軸移動（\u002B Ctrl で回転） テンキー \u002B / - |カメラズーム Q / W |公転半径割合変更 ESC |終了 F1 |固定FPSモード / FPS計測モードの切り替え F2 |惑星間のカメラ移動 F3 |カメラ切り替え（原点注視 / 惑星を一定距離で注視） F4 |ライトON / OFF F5 |Solid / Wireframe切り替え F6 |惑星サイズ実物 / 全て同一切り替え F7 |公転リセット"
},{
  "url": "/articles/718ac1cb539c47edb70462354c110387/",
  "date": "2018-12-01",
  "title": "[C\u002B\u002B] DirectX9で高さマップから地形を生成する",
  "category": {
    "order": 0,
    "name": "Demo",
    "url": "/categories/demo/"
  },
  "tags": [
    {
      "name": "3D",
      "url": "/tags/3d/"
    },
    {
      "name": "DirectX",
      "url": "/tags/directx/"
    },
    {
      "name": "C\u002B\u002B",
      "url": "/tags/cpp/"
    }
  ],
  "content": "はじめに 3Dプログラミング学習用に昔作成したサンプルをアップしました。 https://github.com/yoshiheight/Sample.D3DField \u003Cdiv style=\u0022max-width: 640px;\u0022\u003E\u003Cvideo src=\u0022/files/d3d-field/d3d-field.mp4\u0022 controls\u003E\u003C/video\u003E\u003C/div\u003E 仕様 地形を表すメッシュ状のポリゴンを、外部からロードした高さマップによって生成する 高さマップは、グレースケールのBMP画像を使用する 1ピクセルがポリゴン1頂点を表す 各ピクセルが256段階の高さを表し、色が薄いほど高い標高とする 地形全体に地形画像用テクスチャをマッピング可能とする テクスチャのサイズは高さマップと同じでなくてもいい ポイントスプライトを使用して雪を降らせる 雪はαで抜きの入った画像を使用 操作方法 キー |操作 -----|-------------- ← / → |モデルX軸移動（\u002B Ctrl で回転） ↑ / ↓ |モデルY軸移動（\u002B Ctrl で回転） PgUp / PgDn |モデルZ軸移動（\u002B Ctrl で回転） テンキー 1 / 3 |カメラX軸移動（\u002B Ctrl で回転） テンキー 5 / 2 |カメラY軸移動（\u002B Ctrl で回転） テンキー 9 / 6 |カメラZ軸移動（\u002B Ctrl で回転） テンキー \u002B / - |カメラズーム 1 / Q |光源色R 2 / W |光源色G 3 / E |光源色B A / Z |光源方向X S / X |光源方向Y D / C |光源方向Z O / L |高さ単位 ESC |終了 F1 |固定FPSモード / FPS計測モードの切り替え F2 |頂点バッファ/ インデックスバッファの切り替え F3 |カメラ切り替え（原点注視 / 任意注視） F4 |ライトON / OFF F5 |Solid / Wireframe切り替え F6 |法線表示ON / OFF F7 |テクスチャON / OFF F8 |フォグON / OFF"
},{
  "url": "/articles/9adc3a386df24055a69dbeb63c7d58f2/",
  "date": "2018-11-30",
  "title": "DirectX9について書いたメモ",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "3D",
      "url": "/tags/3d/"
    },
    {
      "name": "DirectX",
      "url": "/tags/directx/"
    },
    {
      "name": "開発全般",
      "url": "/tags/general-dev/"
    }
  ],
  "content": "はじめに 昔書いたDirectX9のメモが出てきたので、とりあえずアップしました。 メモ メッセージループは一般的には60FPSで描画する メッセージループ中では適度なスリープを入れる。ウィンドウアクティブ状態によりスリープ量を可変にするとより最適。(アクティブ時:スリープなし、非アクティブ時:スリープ多め、等) ベンチマーク的な事をしたい場合はFPS固定にしないで、とにかくぶん回す(FPSを測定したい場合など。その場合でもスクリプト更新処理は60FPSにしておく事) プレゼンテーションパラメータのVSync同期はオフにしておく(VSync同期がオンの場合、描画結果の転送時(m_pD3DDevice-\u003EPresent())に同期が行われる) 時間測定はウィンドウズマルチメディアタイマ(timeGetTime)を使用し精度を高めておく 基本的にゲーム内での絶対的な時間はフレームである FPSが異なる環境で同じ速度にする場合や処理落ちしても通常と同じ分だけ移動させる場合、1フレームでの経過時間に速度をかける方法がある ビューのOnPaintでもレンダリングしておくと描画もれを防げる 座標はスクリーン座標とワールド座標がある デバイス消失(ロスト)を考慮する必要がある(ユーザーが解像度を変えたりとか)。デバイス再作成やテクスチャー作り変えをしないとだめ GetDeviceCaps → これにより事前にデバイスの詳細情報を取得して適切な量のVRam確保を行ったりする VertexBuffer → VRamに確保した頂点バッファ。Lockでシステムメモリにコピー、UnLockで逆にVRamにコピーされる。 Z順比較は無効にして、自分で描画する順番でZ順になるようにする事もある。(２Ｄだけ?) Zソート法では物体が交差する場合、うまく描画できないので、Zバッファ法を使う。半透明のものはZソート法を使って後から描画。またZバッファ法では出来るだけ手前の物体から描画すると後ろの物体を描画するときに余計な書き込みが起こるのを防げるのでパフォーマンスが上がる。 行列で合成の繰り返しは誤差を生む(30度の行列と60度の行列の合成とか)。その場合は一度リセットし、新たに90度の回転行列を生成してそれを適用するべし。 回転は X軸、Y軸、Z軸 でどの順番で回転させるかで意味が違ってくる。(例: X軸回転後 → Y軸回転 と Y軸回転後 → X軸回転 では意味が違う) フォントによる文字列描画はDrawPrimitiveに比べると格段に遅い。(スプライトを使っても遅かった) Xファイルのデータはマテリアル単位になっているので、その単位で描画する(DrawSubset) カメラ設定で D3DXMatrixLookAtLH を使って注視点を任意で動的に設定する場合、X軸回転が90度を越えてもカメラの上下は逆にならない。(カメラの上方向ベクトルを D3DXVECTOR3(0.0f, 1.0f, 0.0f) で指定しているので当たり前だが) 頂点バッファ(CreateVertexBuffer)を使用しない場合 → DrawPrimitiveUP 2Dで使う場合 → D3DFVF_XYZRHW 半透明にするものは後から描画する。(先に描画したら半透明にならないので) 半透明でない物は手前から描画する。(町を描いた後にそれを覆う山を書く場合、町の描画が無駄になる為)(2Dの場合、Z値は0.0固定にして描画処理順でZ順を制御してもいい) DirectX9.0から SetVertexShader が SetFVF に変更された SetRenderStateとかSetTextureとか、設定変えたらちゃんと元に戻さないとダメ。 ポリゴン数が多くてFPSが下がる場合、クリッピング、矩形分割、見える範囲のみ描画する。メモリもフィールドを一定矩形で分割し、必要な分だけ読み込むとか。 描画する時、SetRenderStateがいろいろ切り替わると描画効率が下がる。なので同じRenderStateで描画できる物は一まとめで描画する。 頂点フォグとピクセルフォグがあるが、どうやら頂点フォグの方がよく使う？らしい ビュー行列→単位行列にした場合、位置は(0,0,0)、方向はZ軸プラス方向だった。 アルファテストでZソートしなくてもいい Zソートする場合、単純に中心座標だけで比較はできない(内包する場合とか) テクスチャとか、D3DXCreateSphereで作成したモデルとか、Xファイル読み込みモデルとか、１つあればそれを使いまわして描画可能。(大きさの違いは描画時にスケーリング。また読み込み時に頂点バッファをロックして直接座標を×2とかして最初にスケーリングしておく事も可。但し通常は読み込んだデータをその後スケーリングする場合は少ない。) 背景描画には天球を使ったりする。 プレゼンテーションパラメータ指定でアンチエイリアスできる 座標でW値？ SetRenderState、これからSetしようとする場合、Getして現状と違うならSetする D3DXBoxBoundProbe 関数 D3DCLIPSTATUS9 構造体 視錐台 D3DXIntersect 関数 pD3DDevice-\u003ESetRenderState(D3DRS_ZENABLE, D3DZB_TRUE); // Ｚ比較を有効 pD3DDevice-\u003ESetRenderState(D3DRS_CULLMODE, D3DCULL_CCW); // 左回りでカリング pD3DDevice-\u003ESetRenderState(D3DRS_ALPHABLENDENABLE, FALSE); // アルファブレンドを無効 フレームスキップ時、当たり判定考慮 頂点データ配列 → DrawPrimitiveUP 頂点バッファ → SetStreamSource → SetFVF → DrawPrimitive ビルボード： 常にカメラに対して正対する表現方法 ポイントスプライト： パーティクル(火花、雪といった粒子状の物)の描画に適した手法。1頂点で常にカメラに対して自動的に正対してくれる。2Dテクスチャを張っただけの板ポリゴンでも、常にカメラの方向を向いてくれるので、手動で向きの計算を行う必要がない。 座標系：モデル座標を以下の順で変換される(最終的にはスクリーン座標になる) モデル座標系: モデルの中心が原点の座標系(論理座標) ワールド座標系: シーンの座標系。原点にあまり意味はない。(論理座標) ビュー座標系: カメラ視点(カメラの位置と方向)にあわせて再定義した座標系。原点はカメラ。(論理座標) 射影座標系: 視点からの距離を基準にスケーリングした座標系。(論理座標)。カメラから見える全てのものを含んだ空間を「視錐台」という。 スクリーン座標系: 画面の座標系。(物理座標)。 行列の合成: 座標変換は原点を基準に処理されるため、拡大縮小→回転→移動、の順番を守って合成しないとだめ。回転はX軸、Y軸、Z軸のどの順で回転させるかによって結果が異なる。"
}]
