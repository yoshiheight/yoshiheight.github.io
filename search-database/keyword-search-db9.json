[{
  "url": "/articles/494cd9ee1be2439c805277f5db5c9227/",
  "date": "2019-07-13",
  "title": "[TS] OpenCV.jsで画像処理を試してみた",
  "category": {
    "order": 0,
    "name": "Demo",
    "url": "/categories/demo/"
  },
  "tags": [
    {
      "name": "2D",
      "url": "/tags/2d/"
    },
    {
      "name": "OpenCV",
      "url": "/tags/opencv/"
    },
    {
      "name": "TypeScript",
      "url": "/tags/typescript/"
    }
  ],
  "content": "デモ \u003Cscript defer src=\u0022/files/cvdemo-ts/opencv-4.0.1.js\u0022\u003E\u003C/script\u003E \u003Cscript defer src=\u0022/files/cvdemo-ts/cvdemo.js?v=9b6b4392aa42418fbdeae5f6607ff23c\u0022\u003E\u003C/script\u003E \u003Cdiv id=\u0022demo-loading-progress\u0022\u003ELoading...\u003C/div\u003E \u003Cdiv id=\u0022demo-root\u0022 style=\u0022display: none;\u0022\u003E \u003Cdiv\u003E \u003C!-- 処理前の画像 --\u003E \u003Cspan id=\u0022img-src-wrapper\u0022 style=\u0022margin: 1px;\u0022\u003E \u003C/span\u003E \u003C!-- 処理後の表示 --\u003E \u003Cspan style=\u0022margin: 1px;\u0022\u003E \u003Ccanvas id=\u0022canvas-dst\u0022 width=\u00221\u0022 height=\u00221\u0022\u003E\u003C/canvas\u003E \u003C/span\u003E \u003C/div\u003E \u003Cdiv style=\u0022font-size: 75%;\u0022\u003E \u003Cdiv style=\u0022display: inline-grid; grid-template-columns: auto 5px auto;\u0022\u003E \u003C!-- ガンマ --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-gamma\u0022 type=\u0022checkbox\u0022 checked /\u003E \u003Clabel for=\u0022check-gamma\u0022\u003Eガンマ\u003C/label\u003E \u003C/div\u003E \u003Cdiv\u003E\u003C/div\u003E \u003Cdiv\u003E \u003Cinput id=\u0022range-gamma\u0022 type=\u0022range\u0022 style=\u0022width: 125px;\u0022 min=\u00220.5\u0022 max=\u00225.0\u0022 step=\u00220.1\u0022 value=\u00222.0\u0022 /\u003E \u003Cspan id=\u0022span-gamma\u0022\u003E\u003C/span\u003E \u003C/div\u003E \u003C!-- コントラスト --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-contrast\u0022 type=\u0022checkbox\u0022 checked /\u003E \u003Clabel for=\u0022check-contrast\u0022\u003Eコントラスト\u003C/label\u003E \u003C/div\u003E \u003Cdiv\u003E\u003C/div\u003E \u003Cdiv\u003E \u003Cinput id=\u0022range-contrast\u0022 type=\u0022range\u0022 style=\u0022width: 125px;\u0022 min=\u00221.0\u0022 max=\u002215.0\u0022 step=\u00220.1\u0022 value=\u00228.0\u0022 /\u003E \u003Cspan id=\u0022span-contrast\u0022\u003E\u003C/span\u003E \u003C/div\u003E \u003C!-- シャープネス --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-sharpness\u0022 type=\u0022checkbox\u0022 checked /\u003E \u003Clabel for=\u0022check-sharpness\u0022\u003Eシャープネス\u003C/label\u003E \u003C/div\u003E \u003Cdiv\u003E\u003C/div\u003E \u003Cdiv\u003E \u003Cinput id=\u0022range-sharpness\u0022 type=\u0022range\u0022 style=\u0022width: 125px;\u0022 min=\u00220.1\u0022 max=\u002210.0\u0022 step=\u00220.1\u0022 value=\u00223.0\u0022 /\u003E \u003Cspan id=\u0022span-sharpness\u0022\u003E\u003C/span\u003E \u003C/div\u003E \u003C!-- モザイク --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-mosaic\u0022 type=\u0022checkbox\u0022 /\u003E \u003Clabel for=\u0022check-mosaic\u0022\u003Eモザイク\u003C/label\u003E \u003C/div\u003E \u003Cdiv\u003E\u003C/div\u003E \u003Cdiv\u003E \u003Cinput id=\u0022range-mosaic\u0022 type=\u0022range\u0022 style=\u0022width: 125px;\u0022 min=\u00222\u0022 max=\u002230\u0022 step=\u00221\u0022 value=\u00225.0\u0022 /\u003E \u003Cspan id=\u0022span-mosaic\u0022\u003E\u003C/span\u003E \u003C/div\u003E \u003C/div\u003E \u003C!-- ディザリング --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-dithering\u0022 type=\u0022checkbox\u0022 /\u003E \u003Clabel for=\u0022check-dithering\u0022\u003Eディザリング（8色に減色）\u003C/label\u003E \u003C/div\u003E \u003C!-- グレイスケール --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-grayscale\u0022 type=\u0022checkbox\u0022 /\u003E \u003Clabel for=\u0022check-grayscale\u0022\u003Eグレイスケール\u003C/label\u003E \u003C/div\u003E \u003Cdiv id=\u0022require-grayscaled\u0022 style=\u0022margin-left: 1.5em;\u0022\u003E \u003C!-- 大津の二値化 --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-binary\u0022 type=\u0022checkbox\u0022 /\u003E \u003Clabel for=\u0022check-binary\u0022\u003E大津の二値化\u003C/label\u003E \u003C/div\u003E \u003C!-- 重心表示 --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-center\u0022 type=\u0022checkbox\u0022 /\u003E \u003Clabel for=\u0022check-center\u0022\u003E重心表示\u003C/label\u003E \u003C/div\u003E \u003C/div\u003E \u003C/div\u003E \u003C/div\u003E はじめに もともと OpenCvSharp で遊んでいたんですが、OpenCV.js なるものが存在することを知ったので試してみました。 OpenCV.jsですが、npm管理されているわけではなく、またts定義ファイルがないのがかなりつらいです。 OpenCV.js https://opencv.org/ https://docs.opencv.org/4.0.1/d5/d10/tutorial_js_root.html OpenCvSharp https://www.nuget.org/profiles/schimatk ソースコード HTML script defer src=/files/cvdemo-ts/opencv-4.0.1.js/script script defer src=/files/cvdemo-ts/cvdemo.js?v=9b6b4392aa42418fbdeae5f6607ff23c/script div id=demo-loading-progressLoading.../div div id=demo-root style=display: none; div !-- 処理前の画像 -- span id=img-src-wrapper style=margin: 1px; /span !-- 処理後の表示 -- span style=margin: 1px; canvas id=canvas-dst width=1 height=1/canvas /span /div div style=font-size: 75%; div style=display: inline-grid; grid-template-columns: auto 5px auto; !-- ガンマ -- div input id=check-gamma type=checkbox checked / label for=check-gammaガンマ/label /div div/div div input id=range-gamma type=range style=width: 125px; min=0.5 max=5.0 step=0.1 value=2.0 / span id=span-gamma/span /div !-- コントラスト -- div input id=check-contrast type=checkbox checked / label for=check-contrastコントラスト/label /div div/div div input id=range-contrast type=range style=width: 125px; min=1.0 max=15.0 step=0.1 value=8.0 / span id=span-contrast/span /div !-- シャープネス -- div input id=check-sharpness type=checkbox checked / label for=check-sharpnessシャープネス/label /div div/div div input id=range-sharpness type=range style=width: 125px; min=0.1 max=10.0 step=0.1 value=3.0 / span id=span-sharpness/span /div !-- モザイク -- div input id=check-mosaic type=checkbox / label for=check-mosaicモザイク/label /div div/div div input id=range-mosaic type=range style=width: 125px; min=2 max=30 step=1 value=5.0 / span id=span-mosaic/span /div /div !-- ディザリング -- div input id=check-dithering type=checkbox / label for=check-ditheringディザリング（8色に減色）/label /div !-- グレイスケール -- div input id=check-grayscale type=checkbox / label for=check-grayscaleグレイスケール/label /div div id=require-grayscaled style=margin-left: 1.5em; !-- 大津の二値化 -- div input id=check-binary type=checkbox / label for=check-binary大津の二値化/label /div !-- 重心表示 -- div input id=check-center type=checkbox / label for=check-center重心表示/label /div /div /div /div TypeScript declare var cv: any; class CvDemoApp { private _imgSrc: HTMLImageElement | null = null; private readonly _canvasDst = document.querySelectorHTMLCanvasElement(#canvas-dst)!; private readonly _checkGamma = document.querySelectorHTMLInputElement(#check-gamma)!; private readonly _rangeGamma = document.querySelectorHTMLInputElement(#range-gamma)!; private readonly _spanGamma = document.querySelectorHTMLSpanElement(#span-gamma)!; private readonly _checkContrast = document.querySelectorHTMLInputElement(#check-contrast)!; private readonly _rangeContrast = document.querySelectorHTMLInputElement(#range-contrast)!; private readonly _spanContrast = document.querySelectorHTMLSpanElement(#span-contrast)!; private readonly _checkSharpness = document.querySelectorHTMLInputElement(#check-sharpness)!; private readonly _rangeSharpness = document.querySelectorHTMLInputElement(#range-sharpness)!; private readonly _spanSharpness = document.querySelectorHTMLSpanElement(#span-sharpness)!; private readonly _checkMosaic = document.querySelectorHTMLInputElement(#check-mosaic)!; private readonly _rangeMosaic = document.querySelectorHTMLInputElement(#range-mosaic)!; private readonly _spanMosaic = document.querySelectorHTMLSpanElement(#span-mosaic)!; private readonly _checkDithering = document.querySelectorHTMLInputElement(#check-dithering)!; private readonly _checkGrayscale = document.querySelectorHTMLInputElement(#check-grayscale)!; private readonly _checkBinary = document.querySelectorHTMLInputElement(#check-binary)!; private readonly _checkCenter = document.querySelectorHTMLInputElement(#check-center)!; public start(): void { document.querySelectorHTMLElement(#demo-loading-progress)!.style.display = none; document.querySelectorHTMLElement(#demo-root)!.style.display = inline; const targets = document.querySelectorAllHTMLInputElement(#demo-root input); for (const target of targets) { target.addEventListener(change, () = { if (this._imgSrc?.complete) { this.refreshGui(); this.processCv(); } }); } this._imgSrc = document.createElement(img); this._imgSrc.onload = () = { this.refreshGui(); this.processCv(); }; this._imgSrc.src = /files/cvdemo-ts/test.jpg?v=9b6b4392aa42418fbdeae5f6607ff23c; document.querySelector(#img-src-wrapper)!.appendChild(this._imgSrc); } private refreshGui(): void { this._rangeGamma.disabled = !this._checkGamma.checked; this._spanGamma.textContent = this._rangeGamma.value; this._rangeContrast.disabled = !this._checkContrast.checked; this._spanContrast.textContent = this._rangeContrast.value; this._rangeSharpness.disabled = !this._checkSharpness.checked; this._spanSharpness.textContent = this._rangeSharpness.value; this._rangeMosaic.disabled = !this._checkMosaic.checked; this._spanMosaic.textContent = this._rangeMosaic.value; const targets = document.querySelectorAllHTMLInputElement(#require-grayscaled input); for (const target of targets) { target.disabled = !this._checkGrayscale.checked; } } private processCv(): void { const imageProc = new ImageProc(cv.imread(this._imgSrc!)); try { if (this._checkGamma.checked) { imageProc.gamma(this._rangeGamma.valueAsNumber); } if (this._checkContrast.checked) { imageProc.contrast(this._rangeContrast.valueAsNumber); } if (this._checkSharpness.checked) { imageProc.sharpness(this._rangeSharpness.valueAsNumber); } if (this._checkMosaic.checked) { imageProc.mosaic(this._rangeMosaic.valueAsNumber); } if (this._checkDithering.checked) { imageProc.dithering(); } if (this._checkGrayscale.checked) { imageProc.colorToGray(); if (this._checkBinary.checked) { imageProc.binary(); } if (this._checkCenter.checked) { imageProc.drawCenterOfMoments(); } } cv.imshow(this._canvasDst, imageProc.mat); } finally { imageProc.dispose(); } } } /** * 画像処理クラス */ class ImageProc { private _disposed = false; public get mat(): any { return this._mat; } public constructor(private _mat: any) { } public dispose(): void { if (!this._disposed) { this._mat.delete(); this._disposed = true; } } // ガンマ補正 public gamma(value: number): void { const GV = 1.0 / value; const lut = ImageProc.createLut(i = { return Math.pow(i / 255.0, GV) * 255.0; }); this.applyFunc((row, col, value) = lut[value]); } // コントラスト調整 public contrast(value: number): void { const lut = ImageProc.createLut(i = { return 255.0 / (1 \u002B Math.exp(-value * (i - 128) / 255.0)); }); this.applyFunc((row, col, value) = lut[value]); } // シャープネス public sharpness(value: number): void { this.exchange(dst = { value = value / 9.0; const kernelData = [ -value, -value, -value, -value, 1 \u002B (8 * value), -value, -value, -value, -value, ]; const kernel = cv.matFromArray(3, 3, cv.CV_64F, kernelData); cv.filter2D(this._mat, dst, -1, kernel); }); } // モザイク public mosaic(value: number): void { const ROWS = this._mat.rows; const COLS = this._mat.cols; this.exchange(dst = { const dstSize = new cv.Size(0, 0); const ratio = 1.0 / value; cv.resize(this._mat, dst, dstSize, ratio, ratio, cv.INTER_NEAREST); }); this.exchange(dst = { const dstSize = new cv.Size(COLS, ROWS); cv.resize(this._mat, dst, dstSize, 0, 0, cv.INTER_NEAREST); }); } // カラー to グレー public colorToGray(): void { this.exchange(dst = { cv.cvtColor(this._mat, dst, cv.COLOR_RGBA2GRAY, 0); }); } // グレー to カラー public grayToColor(): void { this.exchange(dst = { cv.cvtColor(this._mat, dst, cv.COLOR_GRAY2RGBA, 0); }); } // 大津の二値化 public binary(): void { this.exchange(dst = { cv.threshold(this._mat, dst, 0.0, 255.0, cv.THRESH_BINARY | cv.THRESH_OTSU); }); } // ディザリング public dithering(): void { const matrix = [[0, 8, 2, 10], [12, 4, 14, 6], [3, 11, 1, 9], [15, 7, 13, 5]]; for (let i = 0; i 4; i\u002B\u002B) { for (let j = 0; j 4; j\u002B\u002B) { matrix[i][j] *= 16; } } this.applyFunc((row, col, value) = { return (value matrix[row % 4][col % 4]) ? 0 : 255; }); } // 重心描画 public drawCenterOfMoments(): void { const center = this.getCenterOfMoments(); this.grayToColor(); this.fillCircle(center, 7, new cv.Scalar(255, 0, 0, 255)); } // 塗りつぶし円を描画 public fillCircle(point: any, radius: number, scalar: any): void { cv.circle(this._mat, point, radius, scalar, -1, cv.LINE_AA); } // 重心取得 public getCenterOfMoments(): any { const moments = cv.moments(this._mat); return new cv.Point(moments.m10 / moments.m00, moments.m01 / moments.m00); } // 画像処理時の共通処理 private exchange(callback: (dst: any) = void): void { const dst = new cv.Mat(); callback(dst); this._mat.delete(); this._mat = dst; } // 各RGBに対する処理 public applyFunc(callback: (row: number, col: number, value: number) = number): void { if (!this._mat.isContinuous()) { throw mat is not continuous.; } const ROWS = this._mat.rows; const COLS = this._mat.cols; const CHANNELS = this._mat.channels(); const TARGET_CHANNELS = Math.min(CHANNELS, 3); let index = 0; let beforeIndex = 0; const data = this._mat.data; for (let row = 0; row ROWS; row\u002B\u002B) { beforeIndex = row * COLS * CHANNELS; for (let col = 0; col COLS; col\u002B\u002B) { index = beforeIndex \u002B (col * CHANNELS); for (let ch = 0; ch TARGET_CHANNELS; ch\u002B\u002B) { data[index \u002B ch] = callback(row, col, data[index \u002B ch]); } } } } // ルックアップテーブル生成 public static createLut(callback: (i: number) = number): number[] { const LENGTH = 256; const lut = new Arraynumber(LENGTH); for (let i = 0; i LENGTH; i\u002B\u002B) { lut[i] = Math.floor(callback(i)); } return lut; } } const demoApp = new CvDemoApp(); demoApp.start();"
},{
  "url": "/articles/5b247fcd204244cbba2e046bb2f09381/",
  "date": "2019-04-04",
  "title": "[TS] TypeScriptざっくりメモ",
  "category": {
    "order": 1,
    "name": "Tech",
    "url": "/categories/tech/"
  },
  "tags": [
    {
      "name": "TypeScript",
      "url": "/tags/typescript/"
    }
  ],
  "content": "はじめに TypeScriptの言語仕様の自分用ざっくりメモです。 TypeScriptを使う際、とりあえず知っておけばいいことを適当に記載 ECMAScript 2015（ES 6）の話も混ざってる 現時点のTypeScriptのバージョンは3.4 言語仕様やコンパイラオプションの詳細は公式サイトで https://www.typescriptlang.org/ 型定義の検索は以下で https://microsoft.github.io/TypeSearch/ 型 boolean number string null, undefined オブジェクト型 any型 他にもあるけど省略 変数 ブロックスコープ let グローバルスコープ var let hoge: string = abc; let fuga = xyz; // 初期化する場合、型指定は省略可能 let piyo; // この場合、any型となる 定数 ブロックスコープ const const length = 100; 数値リテラル let decimal = 6; // 10進数リテラル let hex = 0xFF; // 16進数リテラル let octal = 0o66; // 8進数 let binary = 0b1011; // 2進数 let exp1 = 7.2E5 // 指数 let exp2 = 3.4E-3 // 指数 テンプレート文字列 let hoge = \u0060私の名前は ${name} です。\u0060; let fuga = \u0060ここは 改行となる。\u0060; 演算子、条件分岐、ループ JavaScriptと同じ。 分割代入 let hoge, fuga: number; [hoge, fuga] = [100, 200]; console.log(hoge); console.log(fuga); const [foo, bar] = [FOO, BAR]; console.log(foo); console.log(bar); any型 なんでも代入できる型。用途としては、型定義が提供されていない場合に使用する等。 declare 外部のJavaScriptで定義されたグローバル変数を使用する。 declare var hoge: any; 配列 let array1: string[] = [abc, xyz]; let array2: string[] = []; // 空の配列で初期化 let array3 = [abc, xyz]; let array4 = [abc, 123]; // この場合は (string | number)[] 型になる // 多次元配列 let data: number[][] = [[10, 20], [30, 40], [50, 60]]; タプル // 型指定は必須（省略すると配列になってしまう） let tuple: [string, number, boolean] = [hoge, 123, true]; 列挙型 enum Color { Red, // 0 Green, // 1 Blue, // 2 } enum Color { Red = 1, // 1 Green, // 2 Blue, // 3 } let currentColor = Color.Red; let name: string = Color[currentColor]; // 文字列として取得する場合 // 文字列も可 enum Direction { Up = Up, Down = Down, Left = Left, Right = Right, } 共用体型 let userId: number | string = 007; // 数値と文字列の両方OKな型 userId = 007; 交差型 省略。 型エイリアス type HogeType = number | string; type FugaType = [string, number, boolean]; 型アサーション キャストのこと。記述方法が2種類ある。 let anyText: any = hoge; let text1 = stringanyText; // 方法1 let text2 = anyText as string; // 方法2 Set let mySet = new Setstring([hoge, fuga]); mySet.add(piyo); for (const item of mySet) { console.log(item); } Map let myMap = new Mapstring, number(); myMap.set(hoge, 100); myMap.set(fuga, 200); for (const [key, value] of myMap) { console.log(key); console.log(value); } リテラル型 let direction: up | down | left | right; direction = up; // OK direction = abc; // Error type Direction = up | down | left | right | 0 | 1 | 2 | 3; let direction: Direction = up; direction = 3; null許容型 デフォルトでは変数はnull許容だが、コンパイラオプションでnull非許容に変更可能。 その場合、以下のようにするとnull許容型となる。 let hoge: string | null = null; let fuga: string | undefined = undefined; オブジェクト型リテラル 省略。 例外処理 JavaScriptと同じ。 関数 外部関数 JavaScriptと同じ。 関数の引数 通常の引数 デフォルト引数 function hoge(num: number = 0) オプション引数 省略した場合、undefined になる function hoge(num?: number) 可変長引数 function hoge(...nums: number[]) 関数のオーバーロード やりかたが特殊で、まずオーバーロードする関数の宣言のみを書き、実際に実装する関数は1つのみとする。 その実装する関数の引数は、宣言した関数とつじつまが合うようにする。 クラス /** * ドキュメンテーションコメント。 */ class Hoge { // フィールド /** 名前 */ private readonly _name: string; /** 年齢 */ private _age: number; // コンストラクタ public constructor(name: string, age: number) { this._name = name; this._age = age; } // アクセサ public get name(): string { return this._name; } public get age(): number { return this._age; } public set age(age: number) { this._age = age; } // メソッド public update(): void { } // 静的フィールド public static readonly __Foo = 999; private static __bar = 0; // 静的アクセサ public static get bar(): number { return Hoge.__bar; } public static set bar(bar: number) { Hoge.__bar = bar; } // 静的メソッド public static init(): void { } } class Hoge { // コンストラクタでインスタンスフィールドを定義する場合 public constructor( private readonly _name: string, private _age: number) { } } 自身のメソッドやフィールドにアクセスする際 インスタンスメソッド/インスタンスフィールドを使用する場合、this. は必須 staticメソッド/staticフィールドを使用する場合、クラス名. は必須 クラスの継承 // 基底クラス class Hoge { public constructor(name: string) { } protected update(): void { } } // 派生クラス class Fuga extends Hoge { public constructor() { // 基底クラスのコンストラクタ呼び出し super(fuga); } // 同シグネチャにすることでオーバーライドとなる protected update(): void { } } // 抽象基底クラス abstract class Hoge { protected abstract update(): void; } // 派生クラス class Fuga extends Hoge { protected update(): void { } } 戻り値の型としてのthis インスタンスメソッドの戻り値の型に this を指定する事が可能（メソッドチェーンにする場合等） クラス型を戻り値の型にしてもいいが、this だと派生クラスがある場合に戻り値の型が派生クラス型扱いになるので便利 ユーティリティークラス staticクラスはないので、コンストラクタをprivateにすること。 class Hoge { private constructor() { } } 名前空間 namespace Foo { class Hoge { } } namespace Foo.Bar { class Fuga { } } namespace Foo { // 別の名前空間からPiyoを参照できるようにする export class Piyo { } } ジェネリック 基本的な構文はC#と大体同じ。 制約 // T は Hoge を満たしていることを制約として指定する T extends Hoge アロー関数 ラムダ式のこと。アロー関数を使用するでthis問題を回避できる。 インターフェイス interface Hoge { name: string; age?: number; // ?指定の場合、実装は任意 init(): void; update?(): void; // ?指定の場合、実装は任意 } class Fuga implements Hoge { public name = fuga; public init(): void { } } TypeScriptのインターフェイスは、implementsしていなくても対象がそのインターフェイスのシグネチャを満たしていればいい 型が一致するかではなく、構造が一致するかどうかで互換性があるかを判断しているから（構造的部分型） 型ガード if文で instanceof 型名 や typeof value === \u0022型名\u0022 で判定したあとは、その型として使える機能。 let value: any = abc; if (typeof value === string) { // string型のtoUpperCase()メソッドが使用可能 let upperCase = value.toUpperCase(); } // 型ガードをメソッド化する場合 public static isString(value: any): value is string { return typeof value === string; } その他、参考 async/await、コルーチンは以下の記事で使用例あり。 https://crash.jp/pages/938a2b72c7174014b7ce6005cd4bda9e/ おわりに JavaScriptよさらば！"
}]
