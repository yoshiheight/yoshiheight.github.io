[{
  "url": "/articles/91c9b9e34c204d70824f6eca7d84b5bf/",
  "date": "2020-06-08",
  "title": "[C#] ジェネリックなクラスや構造体の中の静的フィールドは型指定毎に存在する",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "C#",
      "url": "/tags/cs/"
    }
  ],
  "content": "概要 ふと EqualityComparer\u003Choge\u003E.Default を見ていて、 Default ってジェネリックの型指定毎に別物なんだろうと思い（まぁそうとしか考えられないですが）、 確かめたくなったので試してみました。 実験１ using System; #nullable enable class Program { static void Main() { _ = Hogeint.Default; _ = Hogestring.Default; _ = Hoge(string, int).Default; // 実行結果： // System.Int32 // System.String // System.ValueTuple\u00602[[System.String, 長いので省略],[System.Int32, 長いので省略]] } } class HogeT { public static readonly HogeT Default = new HogeT(); public Hoge() { Console.WriteLine(typeof(T).FullName); } } 実験２ using System; #nullable enable class Program { static void Main() { _ = Hogeint.Fuga; _ = Hogestring.Fuga; _ = Hoge(string, int).Fuga; // 実行結果： // Fuga // Fuga // Fuga } } static class HogeT // class HogeT でも結果は同じ // struct HogeT でも結果は同じ { public static readonly Fuga Fuga = new Fuga(0); } struct Fuga { public Fuga(int _) { Console.WriteLine(Fuga); } } 結論 「ジェネリックなクラス（静的／非静的問わず）や構造体」の中の「静的フィールド」は、ジェネリックの型指定毎に独立して存在していました。"
},{
  "url": "/articles/5347cbfd659f463487682f03434798b3/",
  "date": "2020-06-07",
  "title": "[C#] 値型とnullが比較できてしまうという話",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "C#",
      "url": "/tags/cs/"
    }
  ],
  "content": "概要 値型と null が比較できてしまう場合があります。 比較することに意味はないのでコンパイルエラーになってほしいですが。 ソースコード using System; #nullable enable class Program { static void Main() { // コンパイルは通り（警告は出るけど）、以下の比較結果は true となる。 var n = 100; if (n != null) { } // これはコンパイルエラーとなる。 var hoge = new Hoge(); if (hoge != null) { } // ==, != 演算子をオーバーロードすればコンパイルは通るけど、 // 演算子は実際には呼び出されないという謎の挙動。 // 以下の比較結果は true となる。 var fuga = new Fuga(); if (fuga != null) { } } } struct Hoge { } struct Fuga { public static bool operator ==(Fuga left, Fuga right) { throw new NotImplementedException(); } public static bool operator !=(Fuga left, Fuga right) { throw new NotImplementedException(); } }"
},{
  "url": "/articles/6eae5c30c3624d17927d40648612dd93/",
  "date": "2020-06-06",
  "title": "[C#] 参照型の等値演算子は暗黙裡に機能してほしくないという話",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "C#",
      "url": "/tags/cs/"
    }
  ],
  "content": "概要 参照型に対する ==, != 比較は、デフォルトで参照の等値性の比較になります。 ですが、演算子はオーバーロードで挙動を変えられますし、 ==, != が参照を比較しているのか、内容を比較しているのか、どっちを表しているのかがあいまいです。 というわけで、参照比較は明示的に行った方がいい、という話です。 備考 まぁ基本的には参照型の ==, != 比較は「参照の比較」であるべきと Microsoft は推奨しているけど（Effective C# にそう書いてあった） これは Equals を内容比較するようにオーバーライドしていたとしても。つまり Equals が true を返すときに == は false を返す場合もあるということ ちなみに値型は ==, != 比較は演算子をオーバーロードしないと使用できない ソースコード using System.Runtime.CompilerServices; #nullable enable class Program { static void Main() { var hoge1 = new Hoge(); var hoge2 = hoge1; // 暗黙裡に ==、!= が機能するのが気に入らない // （デフォルトで参照比較だし、演算子をオーバーロードすれば挙動は変わるし） if (hoge1 == hoge2) { } // 明示的に参照比較にしたい場合、object.ReferenceEquals を使用すればいいが、 // このメソッドは引数が object? 型なのが気に入らない // （間違って値型を渡すとボックス化されるし） if (object.ReferenceEquals(hoge1, hoge2)) { } // 以下のようなメソッドを定義して使った方がメンテナンス性が高い if (hoge1.ClassReferenceEquals(hoge2)) { } } } class Hoge { } static class ObjectExtension { [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool ClassReferenceEqualsT(this T obj1, T obj2) where T : class? { return object.ReferenceEquals(obj1, obj2); } }"
},{
  "url": "/articles/99e4791b441643eba63125fd592d59b8/",
  "date": "2020-06-05",
  "title": "[C#] ボックス化は暗黙裡に機能してほしくないという話",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "C#",
      "url": "/tags/cs/"
    }
  ],
  "content": "概要 値型は、object型変数やインターフェイス型変数に代入するだけでボックス化されます。 ある意味ではアップキャストなので、明示的なキャストが必要なく暗黙裡に行えるというのは言語仕様的にわからなくもないのですが、 気付かずにボックス化されるという副作用もあります。 気づきにくい例 object型を引数にとるメソッドに渡す場合 当初クラスとして実装したけどあとから構造体に変更した場合、その変数を使用している箇所とか というわけで、せめてボックス化／ボックス化解除用のメソッドを用意してそれを使おう、そうすればあとから探すときにも楽、という話です。 ソースコード using System.Diagnostics.CodeAnalysis; #nullable enable class Program { static void Main() { Hoge hoge = default; // 以下のように暗黙裡にボックス化されるのは好きじゃない object obj = hoge; // ボックス化 IHoge ihoge = hoge; // ボックス化 // 以下のように明示的にボックス化するコードの方がメンテナンス性が高い hoge.Boxing(out IHoge ihoge2); } } interface IHoge { } struct Hoge : IHoge { } static class ObjectExtension { public static void BoxingTSource, TResult(this TSource source, out TResult outResult) where TSource : struct where TResult : class { outResult = (TResult)(object)source; } public static void BoxingTSource, TResult(this TSource? source, [NotNullIfNotNull(source)] out TResult? outResult) where TSource : struct where TResult : class { outResult = (TResult?)(object?)source; } public static void UnboxingTSource, TResult(this TSource source, out TResult outResult) where TSource : class where TResult : struct { outResult = (TResult)(object)source; } public static void UnboxingTSource, TResult(this TSource? source, [NotNullIfNotNull(source)] out TResult? outResult) where TSource : class where TResult : struct { outResult = (TResult?)(object?)source; } }"
},{
  "url": "/articles/3a91c1d948c44ed690435d18d903a582/",
  "date": "2020-06-04",
  "title": "[C#] foreachに必要な最低限のEnumerableとEnumerator",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "C#",
      "url": "/tags/cs/"
    }
  ],
  "content": "概要 foreach でループする際に必要になる最低限の Enumerable, Enumerator の実装です。実務で使ってはダメなコードです。 foreach の対象はダックタイピングなので、IEnumerable, IEnumerator インターフェイスの実装は必須ではありません（とはいえ必要なプロパティやメソッドを満たしているかはコンパイル時にチェックされる）。 （ダックタイピングといえば、C\u002B\u002B のテンプレートや TypeScript のインターフェイスは静的なダックタイピングといえる。C# にも同じ機能ほしいなぁ、とたまに思う。副作用はあるだろうけど） ソースコード using System; using System.Collections.Generic; #nullable enable class Program { static void Main() { var hoge = new HogeEnumerable(); foreach (var s in hoge) { Console.WriteLine(s); } // 実行結果： // hoge // fuga // piyo } } class HogeEnumerable { private string[] _data = new[] { hoge, fuga, piyo }; public ValueEnumeratorstring GetEnumerator() { return new ValueEnumeratorstring(_data); } } // ListT.Enumerator のように構造体にした。 // ヒープは消費したくないし。 struct ValueEnumeratorT { private readonly IReadOnlyListT _list; private int _index; public ValueEnumerator(IReadOnlyListT list) { _list = list; _index = 0; Current = default!; } public T Current { get; private set; } public bool MoveNext() { if (_index _list.Count) { Current = _list[_index\u002B\u002B]; return true; } return false; } }"
},{
  "url": "/articles/f5546510b986466cba747d9644745029/",
  "date": "2020-06-03",
  "title": "[C#] IntelのCPUがリトルエンディアンであることを確認する",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "C#",
      "url": "/tags/cs/"
    }
  ],
  "content": "概要 自環境のCPU（Intel Core i3）がリトルエンディアンであることを、実際にメモリレイアウトを見て確認します。 ソースコード using System; using System.Runtime.InteropServices; #nullable enable class Program { static void Main() { // リトルエンディアンかどうか Console.WriteLine(BitConverter.IsLittleEndian); // True var union = new Union { num = 0x_0A_1B_2C_3D }; // 実際に下位バイトから格納されているか確認 Console.WriteLine(union.dword.byte0.ToString(X2)); // 3D Console.WriteLine(union.dword.byte1.ToString(X2)); // 2C Console.WriteLine(union.dword.byte2.ToString(X2)); // 1B Console.WriteLine(union.dword.byte3.ToString(X2)); // 0A // BitConverter.TryWriteBytesでも確認 Spanbyte bytes = stackalloc byte[4]; BitConverter.TryWriteBytes(bytes, union.num); Console.WriteLine(bytes[0].ToString(X2)); // 3D Console.WriteLine(bytes[1].ToString(X2)); // 2C Console.WriteLine(bytes[2].ToString(X2)); // 1B Console.WriteLine(bytes[3].ToString(X2)); // 0A // 備考：ビットシフト演算子の処理結果はエンディアンは関係ない Console.WriteLine((union.num 24).ToString(X2)); // 0A Console.WriteLine((union.num 16 0xFF).ToString(X2)); // 1B Console.WriteLine((union.num 8 0xFF).ToString(X2)); // 2C Console.WriteLine((union.num 0xFF).ToString(X2)); // 3D } } [StructLayout(LayoutKind.Explicit)] struct Union { [FieldOffset(0)] public uint num; [FieldOffset(0)] public DWord dword; } [StructLayout(LayoutKind.Sequential)] struct DWord { public byte byte0; public byte byte1; public byte byte2; public byte byte3; }"
},{
  "url": "/articles/1fd038618df241c9adce790f10c0db52/",
  "date": "2020-06-02",
  "title": "[C#] FizzBuzz",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "C#",
      "url": "/tags/cs/"
    }
  ],
  "content": "今更ですが、C# で FizzBuzz です。 案）まず最初は using System; class Program { static void Main() { // とりあえずこう書くか for (var i = 1; i = 100; i\u002B\u002B) { var isFizz = (i % 3) == 0; var isBuzz = (i % 5) == 0; if (isFizz isBuzz) { Console.WriteLine(FizzBuzz); } else if (isFizz) { Console.WriteLine(Fizz); } else if (isBuzz) { Console.WriteLine(Buzz); } else { Console.WriteLine(i); } } // もしくはこう書くか for (var i = 1; i = 100; i\u002B\u002B) { var isFizz = (i % 3) == 0; var isBuzz = (i % 5) == 0; if (isFizz || isBuzz) { if (isFizz) { Console.Write(Fizz); } if (isBuzz) { Console.Write(Buzz); } } else { Console.Write(i); } Console.WriteLine(); } } } 案）StringBuilderを使用 using System; using System.Text; class Program { static void Main() { var sb = new StringBuilder(); for (var i = 1; i = 100; i\u002B\u002B) { if (i % 3 == 0) { sb.Append(Fizz); } if (i % 5 == 0) { sb.Append(Buzz); } if (sb.Length == 0) { sb.Append(i); } Console.WriteLine(sb); sb.Clear(); } } } 案）パターンマッチング using System; class Program { static void Main() { // プロパティパターンマッチング for (var i = 1; i = 100; i\u002B\u002B) { Console.WriteLine((modFizz: i % 3, modBuzz: i % 5) switch { { modFizz: 0, modBuzz: 0 } = FizzBuzz, { modFizz: 0 } = Fizz, { modBuzz: 0 } = Buzz, _ = Convert.ToString(i), }); } // 位置パターンマッチング for (var i = 1; i = 100; i\u002B\u002B) { Console.WriteLine((i % 3, i % 5) switch { (0, 0) = FizzBuzz, (0, _) = Fizz, (_, 0) = Buzz, _ = Convert.ToString(i), }); } // varパターンマッチング for (var i = 1; i = 100; i\u002B\u002B) { Console.WriteLine(i switch { var _ when i % 15 == 0 = FizzBuzz, var _ when i % 3 == 0 = Fizz, var _ when i % 5 == 0 = Buzz, _ = Convert.ToString(i), }); } } } 案）FizzBuzz値を表す構造体 using System; class Program { static void Main() { for (var v = new FizzBuzzValue(1); v = 100; v\u002B\u002B) { Console.WriteLine(v); } } } readonly struct FizzBuzzValue { private readonly int _num; public FizzBuzzValue(int num) { _num = num; } public static bool operator =(FizzBuzzValue fizzBuzzValue, int num) { return fizzBuzzValue._num = num; } public static bool operator =(FizzBuzzValue fizzBuzzValue, int num) { return fizzBuzzValue._num = num; } public static FizzBuzzValue operator \u002B\u002B(FizzBuzzValue fizzBuzzValue) { return new FizzBuzzValue(fizzBuzzValue._num \u002B 1); } public override string ToString() { return (_num % 3, _num % 5) switch { (0, 0) = FizzBuzz, (0, _) = Fizz, (_, 0) = Buzz, _ = Convert.ToString(_num), }; } } 案）コルーチンを使用 using System; using System.Collections.Generic; class Program { static void Main() { foreach (var s in FizzBuzzGenerator.Generate(1, 100)) { Console.WriteLine(s); } } } static class FizzBuzzGenerator { public static IEnumerablestring Generate(int start, int count) { for (var i = start; i = count; i\u002B\u002B) { yield return (i % 3, i % 5) switch { (0, 0) = FizzBuzz, (0, _) = Fizz, (_, 0) = Buzz, _ = Convert.ToString(i), }; } } } 案）外部から条件を指定 using System; using System.Collections.Generic; using System.Linq; class Program { static void Main() { var fb = new FizzBuzzGenerator(new (Funcint, bool condition, string value)[] { (n = n % 3 == 0, Fizz), (n = n % 5 == 0, Buzz), }); foreach (var s in fb.Generate(1, 100)) { Console.WriteLine(s); } } } class FizzBuzzGenerator { private readonly IReadOnlyList(Funcint, bool condition, string value) _rules; public FizzBuzzGenerator(IReadOnlyList(Funcint, bool, string) rules) { _rules = rules; } public IEnumerablestring Generate(int start, int count) { return Enumerable.Range(start, count).Select(n = _rules.Aggregate( (string?)null, (s, rule) = rule.condition(n) ? s \u002B rule.value : s, s = s ?? n.ToString())); } } 案）三項演算子でワンライナー using System; using System.Linq; class Program { static void Main() = Enumerable.Range(1, 100).Select(n = n % 15 == 0 ? FizzBuzz : n % 3 == 0 ? Fizz : n % 5 == 0 ? Buzz : n.ToString()).ToList().ForEach(Console.WriteLine); }"
},{
  "url": "/articles/79f6f7e9a5e54d599af457ef07a4e129/",
  "date": "2020-06-01",
  "title": "[C#] IListがIReadOnlyListを継承していない理由を考える",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "C#",
      "url": "/tags/cs/"
    }
  ],
  "content": "概要 .NET には IReadOnlyList\u003CT\u003E というインターフェイスが途中から追加されましたが、 IList\u003CT\u003E は IReadOnlyList\u003CT\u003E を継承するように変更されてはいません。 その理由を考察してみます。 考察１：互換性問題 実験 実際にコードを書いて試してみます。 public interface IReadOnlyListT { T this[int index] { get; } } public interface IListT : IReadOnlyListT { // IReadOnlyListのインデクサを隠すのでコンパイル時に警告がでるので、new指定が必要 new T this[int index] { set; get; } // こうでもいいが、どちらにしてもインデクサを隠すことになるのでコンパイル時に警告がでる // T this[int index] { set; } } public class ListT : IListT { private T[] _array = Array.EmptyT(); public T this[int index] { get = _array[index]; set = _array[index] = value; } } new指定でコンパイル時の警告を消しているのは気持ち悪いですが、ビルドは通り、動作的にも問題ありません。 但し、以前の IList\u003CT\u003E を明示的インターフェイス実装しているクラスがあった場合、コンパイルエラーとなります。 コンパイルエラーとなる public class MyListT : IListT { private T[] _array = Array.EmptyT(); T IListT.this[int index] { get = _array[index]; set = _array[index] = value; } } こうする必要がある public class MyListT : IListT { private T[] _array = Array.EmptyT(); T IListT.this[int index] { get = _array[index]; set = _array[index] = value; } // これが必要 T IReadOnlyListT.this[int index] { get = _array[index]; } } 結論 互換性の問題が理由の一つとしてあります。 考察２：オブジェクト指向的な問題 オブジェクト指向的に見て、IList\u003CT\u003E は IReadOnlyList\u003CT\u003E を継承していいか、ですが、どちらかといえば「継承させない方がいい」と思うのですが、実際には、 業務で書くなら、継承させない 趣味で書くなら、継承させる と思います。 ReactiveProperty はどうなのか調べてみた IReactiveProperty.cs https://github.com/runceel/ReactiveProperty/blob/v6.1.3/Source/ReactiveProperty.NETStandard/IReactiveProperty.cs https://github.com/runceel/ReactiveProperty/blob/v6.1.4/Source/ReactiveProperty.NETStandard/IReactiveProperty.cs v6.1.4 から、IReactiveProperty\u003CT\u003E は IReadOnlyReactiveProperty\u003CT\u003E を継承するように変更されていました。 結論 オブジェクト指向的に見た場合、「こうするべき」という結論には至っていません。 何か思いついたらまた記載します。"
},{
  "url": "/articles/3803c333c8184c37b10c60b0b40786a8/",
  "date": "2020-05-27",
  "title": "[C#] SeleniumでEdgeを操作してみた",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "C#",
      "url": "/tags/cs/"
    },
    {
      "name": "Selenium",
      "url": "/tags/selenium/"
    },
    {
      "name": "Edge",
      "url": "/tags/edge/"
    }
  ],
  "content": "概要 Selenium ブラウザを操作するライブラリ。各 Web ブラウザが提供する WebDriver 経由でブラウザを操作する https://www.selenium.dev/ https://www.selenium.dev/documentation/ja/ 環境構築 Selenium.WebDriver https://www.nuget.org/packages/Selenium.WebDriver/ Edge WebDriver 本体 Edge のバージョンに対応するものをダウンロードし、適当なディレクトリに解凍する https://developer.microsoft.com/ja-jp/microsoft-edge/tools/webdriver/ ソースコード using System; using OpenQA.Selenium; using OpenQA.Selenium.Edge; using OpenQA.Selenium.Support.UI; namespace Sample.Selenium { class Program { static void Main() { var driver = new EdgeDriver(EdgeDriverService.CreateDefaultService(@C:\\edgedriver_win64, msedgedriver.exe)); // URL遷移 driver.Navigate().GoToUrl(https://crash.jp/); // 検索アイコンをクリック driver.FindElement(By.Id(search-icon)).Click(); // 検索ボックスに文字列入力してサブミット var searchBox = driver.FindElement(By.CssSelector(input[type=\u0027search\u0027]:focus)); searchBox.SendKeys(SeleniumでEdgeを操作してみた); searchBox.Submit(); // 検索結果一覧から記事ページへ遷移 var articleLink = new WebDriverWait(driver, TimeSpan.FromSeconds(3)) .Until(d = d.FindElement(By.CssSelector(.article-list-title a))); articleLink.Click(); Console.ReadKey(); driver.Quit(); } } }"
}]
