[{"url":"/articles/980ae7eb03564dcc807f35622213a827/","date":"2023-01-23","title":"WPFメモ","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"WPF","url":"/tags/wpf/"}],"content":"デモ カスタムコントロール、ビヘイビア、添付プロパティ こういう問題点がありますよ 一覧にする こういう対処を行ってきましたよ 一覧にする ですが、改善が難しいこともありますよ、でしめくくる ■WPFの全てについて知ってはいないが、問題になりそうなことは過去に一通り調べたりしたことはあります。 ・WPFの各コントロール ・CollectionViewの使用 ・レイアウト Grid/StackPanel/DockPanel/WrapPanel ・ComponentOneのChartを使用したグラフ表示（棒、折れ線、箱ひげ図、ヒートマップ） ・カスタムコントロール/依存関係プロパティ ・ReactiveProperty/リアクティブプログラミング ・Messengerパターンを使用したViewModelからViewへの通知 ・DIを使用したViewModelへのModelの渡し方 ・WebAPIを使用したViewModelからのModelの操作 ・Converter作成 ・DataTemplate、ControlTemplate ・共通スタイル定義 ■補足 ・Prismといった大規模開発向けのMVVMフレームワークの導入経験はない (Prismが使用されている現場で、PrismのRegionに埋め込む子画面側の開発担当だった為) ・すべてについて実装を経験したわけではないが、全体像は把握しているので、都度しらべて対処 ・正解がない、判断が難しい部分の多いので、複数の選択肢を提案しますので、相談して決めていく ■WPF問題点 ・Windowsフォームと比較して、パフォーマンスの問題が出やすい部分もある ・DataGrid/Chartで大量のデータを表示する場合 ・XAMLの書き方（どういう風にでもかける） ・レイアウトのしくみ（HTMLレンダリングの様に子要素で親要素のサイズが決まる） ・テンプレート ・コードビハインド、ビヘイビア/アクション/トリガー ・ ・Windowsフォームが即時描画、WPFは遅延描画なので、コード側で実行した処理に対する遅延やタイミングの問題が出ることも ・守備範囲が広い、覚えなければならないことが多い"},{"url":"/articles/2a6c0202153e480c97ad21ebc6e24b16/","date":"2020-10-14","title":"[C#] フルスクラッチでテキストエディタエンジンを実装してWebAssemblyで動かす","category":{"order":0,"name":"Demo","url":"/categories/demo/"},"tags":[{"name":"C#","url":"/tags/cs/"},{"name":"Blazor","url":"/tags/blazor/"}],"content":"以前Qiitaに投稿した記事の再アップです。 デモ 以下のリンクから試せます。 https://yoshiheight.github.io/apps/text-editor/ 環境によっては表示まで数秒かかります。二回目以降はキャッシュから読み込まれるので、表示に時間はかかりません。 キャッシュはブラウザの開発ツールから削除可能です。以下はChromeの場合。 開発ツール \u003E Applicationタブ \u003E Cache \u003E Cache Storage ※デモを何度か上げなおしているので、エラーになる場合にはキャッシュを削除してみてください 動作環境 WebAssemblyに対応したブラウザが必要ですが、最近のブラウザであればまず問題ないです。 自分で確認した環境 Windows 10 Pro, Chrome/新Edge/Firefox Android 10, Chrome（表示と文字入力のみ確認） 誰向けの記事か 以下に興味がある人。 テキストエディタ/テキストエディタエンジンの実装 MVPアーキテクチャ（監視コントローラー式） 差分管理によるUndo/Redo IME制御 メモリ共有を使用したBlazor WebAssembly/JavaScript相互運用 以下が知りたい人はこの記事はあまり参考にはならないです。 Blazorでの一般的なSPA開発の情報がほしい人（今回、Razorを使ったUI制御は行っていません） 何を作ったか 正確にはマルチプラットフォーム対応のテキストエディタエンジンをC#でフルスクラッチで実装し、そのエンジンを使用するサンプルアプリケーションとして、 Blazor WebAssemblyアプリ WinFormsアプリ を作成しました。まだ作りかけですが、一通り動くようになったので公開しました。 タイトルに「WebAssemblyで動かした」とえらそうに書いてしまいましたが、これはBlazor WebAssemblyで簡単に実現できます。ただ、ブラウザでテキストエディタとして動かすにはJavaScript側とやりとりする部分に工夫が必要で、そういった点は参考になると思います。 免責 成果物は実用目的ではなく研究開発目的なので、基本的な機能しか実装していません 既存ライブラリは使用せず、既存のテキストエディタの実装を参考にしたわけでもないので、定石を外している部分があるかもしれません ASP/Blazor/WebAssembly/Webフロントエンドはあまり詳しくないので、へんなことをしているかもしれません メモリ共有を使用したBlazor WebAssembly/JavaScript相互運用ですが、実は公式な情報に基づいた実装は行っていません WebAssembly自体の仕様ではメモリ共有可能になっているようなのですが、Blazorでの使い方は公式には記載されていませんでした いろいろ調べた結果、Emscripten関連の機能が使用可能だったので、今回強引に使いました（なので今後この方法は使用できなくなる可能性があります） 実装説明は「箇条書き＋ソースコードへのリンク」なので、ざっくりとした説明になっています 機能 文字入力/編集（日本語入力対応） 一通りのよくあるカーソル移動（Home/End/PageUp/PageDownとか、Ctrlキーとの組み合わせとか） 現在行の強調表示 現在行の位置をスクロールバーに表示 行番号表示 タブ挿入 複数行のタブインデント/インデント解除 ASCII文字と日本語文字で別々のフォント/サイズの適用 フォントサイズの倍率変更 Undo/Redo コピー/カット/ペースト ダブルクリックによる単語選択、トリプルクリックによる行選択、フォースクリックによる全選択 開発動機 Blazor WebAssemblyが正式リリースになり、やっとプラグインなしでC#がブラウザで動く時代が来た！これは何か作らねば！と思い 以前テキストエディタをWinFormsで実装して一時期公開していたが、デスクトップアプリを実行してみてくれる人は皆無で、日の目を見なかったので テキストエディタをどこまでシンプルでメンテナンス性の高いコードで実装できるか試したい ソースコード GitHubにアップしました。開発環境はVisual Studio 2019です。 https://github.com/yoshiheight/Crash.Editor Blazor WebAssemblyサンプルアプリでは、Webフロントエンドで必要最低限な箇所でjQueryとLodashを使用しているので、package.jsonからパッケージを復元してください。 プロジェクト構成 サンプリアプリ以外はすべて.NET Standard 2.1クラスライブラリプロジェクトです。 Crash.Core 特定のプロジェクトに依存しない汎用ライブラリ Crash.Core.UI 1枚のキャンバス内に仮想的にUIエレメント構造を構築する為に即席で作った簡易GUIフレームワーク（2D API描画ベース） Crash.Editor.Engine.Model テキストエディタエンジンのモデル部 Crash.Editor.Engine.Presenter テキストエディタエンジンのプレゼンター部 Crash.Editor.Engine.View テキストエディタエンジンのビュー部 Sample.BlazorWasm.TextEditor Blazor WebAssemblyサンプルアプリ Sample.WinForms.TextEditor WinFormsサンプルアプリ アーキテクチャ WinFormsサンプルアプリの方は以下の図のようになっています。 [エンジン側] [WinForms側] TextPresenter ――――― Use ―――――― TextEditorControl use↓ ↓use (文字列入力/キー操作) (UserControl) TextDocument ↑observe TextView ↓use/observe ↑use/observe ICanvasContext ---- Impl ---- CanvasContext IOffScreen ---- Impl ---- OffScreen IFont ---- Impl ---- Font IInputMethod ---- Impl ---- InputMethod キーボード/マウス/フォーカス/IME関連や描画処理は環境に依存する為、その部分をアプリケーション側が提供する仕組み Blazor WebAssemblyサンプルアプリの方の図は省略するが、上記に加えてJavaScriptレイヤーがあり、Blazor WebAssembly/JavaScript相互運用でやりとりしている ビューもエンジンに含めているので、Blazor WebAssemblyアプリとWinFormsアプリでまったく同じ見た目になっている スクロールバーもビューエンジンが描画している Blazor WebAssemblyアプリはHTML Canvas 1枚に、WinFormsアプリはUserControl 1枚にUIすべてのパーツを描画している 全体的な説明 以下のようになっています。 共通ライブラリ（Crash.Core） 汎用クラスの集まり 即席簡易GUIフレームワーク（Crash.Core.UI） UI部品の基底クラス、描画時のクリッピング領域保持、レンダリングの枠組みを提供 汎用UIコントロールとして、スクロールバーはここに用意した UIレイアウトの仕組みはなく、UI部品派生クラスが自分で自分の矩形を返す必要がある オフスクリーンバッファを使用してスクロール時に差分だけ描画するのをサポートするクラスは以下 ScrollableOffscreen.cs アプリケーション側に提供してもらう機能は以下 Crash.Core.UI/UIContext テキストエディタエンジン MVPアーキテクチャ（監視コントローラー式） ビューがモデルを監視し、モデルの変更に応じて描画を行う プレゼンターはモデルとビューを保持/使用 アプリケーション側からはプレゼンター経由で操作する プレゼンター（Crash.Editor.Engine.Presenter） もともとテキストエディタによくあるキー操作記録機能をこのレイヤーで実現していた（キー操作記録用コマンド/コマンドパターン） いまのところ不要と思い、削除 モデル（Crash.Editor.Engine.Model） データを保持するのは、全体を管理するTextDocumentと行を管理するTextLine ビューからは読み取り専用インターフェイスでのみ上記を参照 変更操作を直接行っているのはUndo/Redoコマンドクラス 行の管理はギャップバッファ GapBuffer.cs InternalGapBuffer.cs ギャップバッファとしての実装とC#のIListとしての実装を分けたかったので、クラスを分けた Span/Index/Range等のおかげでかなり簡潔にギャップバッファが実装できた SpanExtensions.cs 1行内の文字列の管理はただのstring Undo/Redoはコマンドパターンで、データ変更の差分はここで保持している Common/UndoRedo 実装を楽にするため、レイヤーを2つに分けた HighLevel LowLevel 1文字入力するだけでもコマンドを生成するので、単語単位にするとか工夫した方がいいかもしれない ビュー（Crash.Editor.Engine.View） 内部ではCrash.Core.UIを使用 モデルに変更があった場合、その変更があった範囲のみを再描画 描画範囲の文字を列挙しつつ座標とかサイズとかを計算するクラス Common/Measurement Measurementで列挙した文字を以下の描画用の文字列保持クラスに詰めなおす Common/Drawer 同じフォントの文字、同じ色の文字をまとめて1回で描画する。選択範囲の色も同様 モデルとビューを分けているので、同一内容を分割表示するようなことも、やろうと思えば可能 Blazor WebAssemblyサンプルアプリ 文字列入力やキーバインドはアプリケーション側が行う TextEditorComponent.razor.cs JavaScript相互運用 C#側でJavaScript側オブジェクトの参照を保持し（といっても直接ではなくJavaScript側のMapが実際には保持）、インスタンスメソッドを呼び出す仕組みを用意（その逆の仕組みは標準で用意されているが、これは見当たらなかった） JSObjectReference.ts JSObjectReference.cs C#側からJavaScript側のイベントをオブザーバーパターン風に捕捉する仕組みを用意 JSEvent.ts JSEvent.cs 共有メモリを使用したやりとり（ポインタ渡し） Emscripten.ts 2D描画は描画命令をJSONとして生成し、そのバッファのポインタをJavaScript側に渡す方法にした（JavaScript相互運用は処理が遅いので、なるべく呼び出し回数を減らした方がいいらしいので。効果のほどは計測してないので不明） Offscreen.ts CanvasRenderingContext2Dによる描画 Offscreen.cs IMEはブラウザでは直接制御する方法がないのでtextareaで代用。クリップボード処理もtextarea経由で行う（クリップボード処理ではC#側とは文字列バッファのポインタを使用してやりとり） InputMethod.ts Z順で普段はcanvasの後ろにいるが、フォーカスは常にtextareaに当てている。IME変換中のみ、Z順がcanvasより前になるようにしている textareaをIMEに見せかけるため、レイアウト調整用にラッパーとしてdivを用意している WinFormサンプルアプリ 文字列入力やキーバインドはアプリケーション側が行う TextEditorControl.cs 2D描画はGDI\u002Bを使用 Offscreen.cs IMEはIMM系のWin32APIを使用 InputMethod.cs 今回、独自にオフスクリーンバッファを使用する仕組みにしたため、System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle)によるクリッピングは使用していない 苦労した点 ビューが一番大変 どのシステムでもそうだがビューにはいろんなしわ寄せが来る 座標計算が面倒 描画系のバグはなにが原因か特定が難しい 描画が化けるのが一番やっかい ブレークポイントを使ったデバッグだけでは特定できないので、コンソールにログ出力したりとか、一部の処理をコメントアウトして動作の違いから推測したりとか イベント発生のタイミングとかもあるので、想定通り動いている箇所を1つ1つ確認していくことで、原因箇所を絞り込んでいったりとか Blazor WebAssemblyでのデバッグ C#コード/TypeScriptコードの両方ともVisual Studioでデバッグできるのは楽なのだが、デバッグが重いのと現時点ではC#側はローカル変数のみしか値の確認ができない（なのでテキストエディタエンジン自体のデバッグはWinFormsサンプルアプリの方で行った） 今後の対応予定 以下の対応までは終わらせたいです（いつになるかわかりませんが）。 リファクタリング、コメント追加、不具合対応 他のテキストエディタの実装を見て、参考になる部分の取り入れ 機能面 シンタックスハイライト 定義情報はhighlight.jsとかのをインポートできるようにしたい 文字列検索、ヒット箇所のハイライト表示/スクロールバーへの表示 改行時の自動インデント UI部品の色設定 変更があった行の垂直ルーラーへのマーク表示 以下は、たぶんやらないです。 サロゲートペア 印刷向けの描画 矩形選択 行の自動折り返し 横スクロール範囲の計算（現状は行の長さに制限はなく、表示上の限界は1000文字としている） Firefoxで日本語文字のベースライン位置がずれる現象の対応（アプリ側で対応できそうだけど面倒なので）"},{"url":"/articles/494cd9ee1be2439c805277f5db5c9227/","date":"2019-07-13","title":"[TS] OpenCV.jsで画像処理を行う","category":{"order":0,"name":"Demo","url":"/categories/demo/"},"tags":[{"name":"2D","url":"/tags/2d/"},{"name":"OpenCV","url":"/tags/opencv/"},{"name":"TypeScript","url":"/tags/typescript/"}],"content":"デモ \u003Cscript defer src=\u0022/files/cvdemo-ts/opencv-4.0.1.js\u0022\u003E\u003C/script\u003E \u003Cscript defer src=\u0022/files/cvdemo-ts/cvdemo.js?v=9b6b4392aa42418fbdeae5f6607ff23c\u0022\u003E\u003C/script\u003E \u003Cdiv id=\u0022demo-loading-progress\u0022\u003ELoading...\u003C/div\u003E \u003Cdiv id=\u0022demo-root\u0022 style=\u0022display: none;\u0022\u003E \u003Cdiv\u003E \u003C!-- 処理前の画像 --\u003E \u003Cspan id=\u0022img-src-wrapper\u0022 style=\u0022margin: 1px;\u0022\u003E \u003C/span\u003E \u003C!-- 処理後の表示 --\u003E \u003Cspan style=\u0022margin: 1px;\u0022\u003E \u003Ccanvas id=\u0022canvas-dst\u0022 width=\u00221\u0022 height=\u00221\u0022\u003E\u003C/canvas\u003E \u003C/span\u003E \u003C/div\u003E \u003Cdiv style=\u0022font-size: 75%;\u0022\u003E \u003Cdiv style=\u0022display: inline-grid; grid-template-columns: auto 5px auto;\u0022\u003E \u003C!-- ガンマ --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-gamma\u0022 type=\u0022checkbox\u0022 checked /\u003E \u003Clabel for=\u0022check-gamma\u0022\u003Eガンマ\u003C/label\u003E \u003C/div\u003E \u003Cdiv\u003E\u003C/div\u003E \u003Cdiv\u003E \u003Cinput id=\u0022range-gamma\u0022 type=\u0022range\u0022 style=\u0022width: 125px;\u0022 min=\u00220.5\u0022 max=\u00225.0\u0022 step=\u00220.1\u0022 value=\u00222.0\u0022 /\u003E \u003Cspan id=\u0022span-gamma\u0022\u003E\u003C/span\u003E \u003C/div\u003E \u003C!-- コントラスト --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-contrast\u0022 type=\u0022checkbox\u0022 checked /\u003E \u003Clabel for=\u0022check-contrast\u0022\u003Eコントラスト\u003C/label\u003E \u003C/div\u003E \u003Cdiv\u003E\u003C/div\u003E \u003Cdiv\u003E \u003Cinput id=\u0022range-contrast\u0022 type=\u0022range\u0022 style=\u0022width: 125px;\u0022 min=\u00221.0\u0022 max=\u002215.0\u0022 step=\u00220.1\u0022 value=\u00228.0\u0022 /\u003E \u003Cspan id=\u0022span-contrast\u0022\u003E\u003C/span\u003E \u003C/div\u003E \u003C!-- シャープネス --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-sharpness\u0022 type=\u0022checkbox\u0022 checked /\u003E \u003Clabel for=\u0022check-sharpness\u0022\u003Eシャープネス\u003C/label\u003E \u003C/div\u003E \u003Cdiv\u003E\u003C/div\u003E \u003Cdiv\u003E \u003Cinput id=\u0022range-sharpness\u0022 type=\u0022range\u0022 style=\u0022width: 125px;\u0022 min=\u00220.1\u0022 max=\u002210.0\u0022 step=\u00220.1\u0022 value=\u00223.0\u0022 /\u003E \u003Cspan id=\u0022span-sharpness\u0022\u003E\u003C/span\u003E \u003C/div\u003E \u003C!-- モザイク --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-mosaic\u0022 type=\u0022checkbox\u0022 /\u003E \u003Clabel for=\u0022check-mosaic\u0022\u003Eモザイク\u003C/label\u003E \u003C/div\u003E \u003Cdiv\u003E\u003C/div\u003E \u003Cdiv\u003E \u003Cinput id=\u0022range-mosaic\u0022 type=\u0022range\u0022 style=\u0022width: 125px;\u0022 min=\u00222\u0022 max=\u002230\u0022 step=\u00221\u0022 value=\u00225.0\u0022 /\u003E \u003Cspan id=\u0022span-mosaic\u0022\u003E\u003C/span\u003E \u003C/div\u003E \u003C/div\u003E \u003C!-- ディザリング --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-dithering\u0022 type=\u0022checkbox\u0022 /\u003E \u003Clabel for=\u0022check-dithering\u0022\u003Eディザリング（8色に減色）\u003C/label\u003E \u003C/div\u003E \u003C!-- グレイスケール --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-grayscale\u0022 type=\u0022checkbox\u0022 /\u003E \u003Clabel for=\u0022check-grayscale\u0022\u003Eグレイスケール\u003C/label\u003E \u003C/div\u003E \u003Cdiv id=\u0022require-grayscaled\u0022 style=\u0022margin-left: 1.5em;\u0022\u003E \u003C!-- 大津の二値化 --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-binary\u0022 type=\u0022checkbox\u0022 /\u003E \u003Clabel for=\u0022check-binary\u0022\u003E大津の二値化\u003C/label\u003E \u003C/div\u003E \u003C!-- 重心表示 --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-center\u0022 type=\u0022checkbox\u0022 /\u003E \u003Clabel for=\u0022check-center\u0022\u003E重心表示\u003C/label\u003E \u003C/div\u003E \u003C/div\u003E \u003C/div\u003E \u003C/div\u003E ソースコード HTML script defer src=/files/cvdemo-ts/opencv-4.0.1.js/script script defer src=/files/cvdemo-ts/cvdemo.js?v=9b6b4392aa42418fbdeae5f6607ff23c/script div id=demo-loading-progressLoading.../div div id=demo-root style=display: none; div !-- 処理前の画像 -- span id=img-src-wrapper style=margin: 1px; /span !-- 処理後の表示 -- span style=margin: 1px; canvas id=canvas-dst width=1 height=1/canvas /span /div div style=font-size: 75%; div style=display: inline-grid; grid-template-columns: auto 5px auto; !-- ガンマ -- div input id=check-gamma type=checkbox checked / label for=check-gammaガンマ/label /div div/div div input id=range-gamma type=range style=width: 125px; min=0.5 max=5.0 step=0.1 value=2.0 / span id=span-gamma/span /div !-- コントラスト -- div input id=check-contrast type=checkbox checked / label for=check-contrastコントラスト/label /div div/div div input id=range-contrast type=range style=width: 125px; min=1.0 max=15.0 step=0.1 value=8.0 / span id=span-contrast/span /div !-- シャープネス -- div input id=check-sharpness type=checkbox checked / label for=check-sharpnessシャープネス/label /div div/div div input id=range-sharpness type=range style=width: 125px; min=0.1 max=10.0 step=0.1 value=3.0 / span id=span-sharpness/span /div !-- モザイク -- div input id=check-mosaic type=checkbox / label for=check-mosaicモザイク/label /div div/div div input id=range-mosaic type=range style=width: 125px; min=2 max=30 step=1 value=5.0 / span id=span-mosaic/span /div /div !-- ディザリング -- div input id=check-dithering type=checkbox / label for=check-ditheringディザリング（8色に減色）/label /div !-- グレイスケール -- div input id=check-grayscale type=checkbox / label for=check-grayscaleグレイスケール/label /div div id=require-grayscaled style=margin-left: 1.5em; !-- 大津の二値化 -- div input id=check-binary type=checkbox / label for=check-binary大津の二値化/label /div !-- 重心表示 -- div input id=check-center type=checkbox / label for=check-center重心表示/label /div /div /div /div TypeScript declare var cv: any; class DemoApp { private _imgSrc: HTMLImageElement | null = null; private readonly _canvasDst = document.querySelectorHTMLCanvasElement(#canvas-dst)!; private readonly _checkGamma = document.querySelectorHTMLInputElement(#check-gamma)!; private readonly _rangeGamma = document.querySelectorHTMLInputElement(#range-gamma)!; private readonly _spanGamma = document.querySelectorHTMLSpanElement(#span-gamma)!; private readonly _checkContrast = document.querySelectorHTMLInputElement(#check-contrast)!; private readonly _rangeContrast = document.querySelectorHTMLInputElement(#range-contrast)!; private readonly _spanContrast = document.querySelectorHTMLSpanElement(#span-contrast)!; private readonly _checkSharpness = document.querySelectorHTMLInputElement(#check-sharpness)!; private readonly _rangeSharpness = document.querySelectorHTMLInputElement(#range-sharpness)!; private readonly _spanSharpness = document.querySelectorHTMLSpanElement(#span-sharpness)!; private readonly _checkMosaic = document.querySelectorHTMLInputElement(#check-mosaic)!; private readonly _rangeMosaic = document.querySelectorHTMLInputElement(#range-mosaic)!; private readonly _spanMosaic = document.querySelectorHTMLSpanElement(#span-mosaic)!; private readonly _checkDithering = document.querySelectorHTMLInputElement(#check-dithering)!; private readonly _checkGrayscale = document.querySelectorHTMLInputElement(#check-grayscale)!; private readonly _checkBinary = document.querySelectorHTMLInputElement(#check-binary)!; private readonly _checkCenter = document.querySelectorHTMLInputElement(#check-center)!; public start(): void { document.querySelectorHTMLElement(#demo-loading-progress)!.style.display = none; document.querySelectorHTMLElement(#demo-root)!.style.display = inline; const targets = document.querySelectorAllHTMLInputElement(#demo-root input); for (const target of targets) { target.addEventListener(change, () = { if (this._imgSrc?.complete) { this.refreshGui(); this.processCv(); } }); } this._imgSrc = document.createElement(img); this._imgSrc.onload = () = { this.refreshGui(); this.processCv(); }; this._imgSrc.src = /files/cvdemo-ts/test.jpg?v=9b6b4392aa42418fbdeae5f6607ff23c; document.querySelector(#img-src-wrapper)!.appendChild(this._imgSrc); } private refreshGui(): void { this._rangeGamma.disabled = !this._checkGamma.checked; this._spanGamma.textContent = this._rangeGamma.value; this._rangeContrast.disabled = !this._checkContrast.checked; this._spanContrast.textContent = this._rangeContrast.value; this._rangeSharpness.disabled = !this._checkSharpness.checked; this._spanSharpness.textContent = this._rangeSharpness.value; this._rangeMosaic.disabled = !this._checkMosaic.checked; this._spanMosaic.textContent = this._rangeMosaic.value; const targets = document.querySelectorAllHTMLInputElement(#require-grayscaled input); for (const target of targets) { target.disabled = !this._checkGrayscale.checked; } } private processCv(): void { const imageProc = new ImageProc(cv.imread(this._imgSrc!)); try { if (this._checkGamma.checked) { imageProc.gamma(this._rangeGamma.valueAsNumber); } if (this._checkContrast.checked) { imageProc.contrast(this._rangeContrast.valueAsNumber); } if (this._checkSharpness.checked) { imageProc.sharpness(this._rangeSharpness.valueAsNumber); } if (this._checkMosaic.checked) { imageProc.mosaic(this._rangeMosaic.valueAsNumber); } if (this._checkDithering.checked) { imageProc.dithering(); } if (this._checkGrayscale.checked) { imageProc.colorToGray(); if (this._checkBinary.checked) { imageProc.binary(); } if (this._checkCenter.checked) { imageProc.drawCenterOfMoments(); } } cv.imshow(this._canvasDst, imageProc.mat); } finally { imageProc.dispose(); } } } /** * 画像処理クラス */ class ImageProc { private _disposed = false; public get mat(): any { return this._mat; } public constructor(private _mat: any) { } public dispose(): void { if (!this._disposed) { this._mat.delete(); this._disposed = true; } } // ガンマ補正 public gamma(value: number): void { const GV = 1.0 / value; const lut = ImageProc.createLut(i = { return Math.pow(i / 255.0, GV) * 255.0; }); this.applyFunc((row, col, value) = lut[value]); } // コントラスト調整 public contrast(value: number): void { const lut = ImageProc.createLut(i = { return 255.0 / (1 \u002B Math.exp(-value * (i - 128) / 255.0)); }); this.applyFunc((row, col, value) = lut[value]); } // シャープネス public sharpness(value: number): void { this.exchange(dst = { value = value / 9.0; const kernelData = [ -value, -value, -value, -value, 1 \u002B (8 * value), -value, -value, -value, -value, ]; const kernel = cv.matFromArray(3, 3, cv.CV_64F, kernelData); cv.filter2D(this._mat, dst, -1, kernel); }); } // モザイク public mosaic(value: number): void { const ROWS = this._mat.rows; const COLS = this._mat.cols; this.exchange(dst = { const dstSize = new cv.Size(0, 0); const ratio = 1.0 / value; cv.resize(this._mat, dst, dstSize, ratio, ratio, cv.INTER_NEAREST); }); this.exchange(dst = { const dstSize = new cv.Size(COLS, ROWS); cv.resize(this._mat, dst, dstSize, 0, 0, cv.INTER_NEAREST); }); } // カラー to グレー public colorToGray(): void { this.exchange(dst = { cv.cvtColor(this._mat, dst, cv.COLOR_RGBA2GRAY, 0); }); } // グレー to カラー public grayToColor(): void { this.exchange(dst = { cv.cvtColor(this._mat, dst, cv.COLOR_GRAY2RGBA, 0); }); } // 大津の二値化 public binary(): void { this.exchange(dst = { cv.threshold(this._mat, dst, 0.0, 255.0, cv.THRESH_BINARY | cv.THRESH_OTSU); }); } // ディザリング public dithering(): void { const matrix = [[0, 8, 2, 10], [12, 4, 14, 6], [3, 11, 1, 9], [15, 7, 13, 5]]; for (let i = 0; i 4; i\u002B\u002B) { for (let j = 0; j 4; j\u002B\u002B) { matrix[i][j] *= 16; } } this.applyFunc((row, col, value) = { return (value matrix[row % 4][col % 4]) ? 0 : 255; }); } // 重心描画 public drawCenterOfMoments(): void { const center = this.getCenterOfMoments(); this.grayToColor(); this.fillCircle(center, 7, new cv.Scalar(255, 0, 0, 255)); } // 塗りつぶし円を描画 public fillCircle(point: any, radius: number, scalar: any): void { cv.circle(this._mat, point, radius, scalar, -1, cv.LINE_AA); } // 重心取得 public getCenterOfMoments(): any { const moments = cv.moments(this._mat); return new cv.Point(moments.m10 / moments.m00, moments.m01 / moments.m00); } // 画像処理時の共通処理 private exchange(callback: (dst: any) = void): void { const dst = new cv.Mat(); callback(dst); this._mat.delete(); this._mat = dst; } // 各RGBに対する処理 public applyFunc(callback: (row: number, col: number, value: number) = number): void { if (!this._mat.isContinuous()) { throw mat is not continuous.; } const ROWS = this._mat.rows; const COLS = this._mat.cols; const CHANNELS = this._mat.channels(); const TARGET_CHANNELS = Math.min(CHANNELS, 3); let index = 0; let beforeIndex = 0; const data = this._mat.data; for (let row = 0; row ROWS; row\u002B\u002B) { beforeIndex = row * COLS * CHANNELS; for (let col = 0; col COLS; col\u002B\u002B) { index = beforeIndex \u002B (col * CHANNELS); for (let ch = 0; ch TARGET_CHANNELS; ch\u002B\u002B) { data[index \u002B ch] = callback(row, col, data[index \u002B ch]); } } } } // ルックアップテーブル生成 public static createLut(callback: (i: number) = number): number[] { const LENGTH = 256; const lut = new Arraynumber(LENGTH); for (let i = 0; i LENGTH; i\u002B\u002B) { lut[i] = Math.floor(callback(i)); } return lut; } } const demoApp = new DemoApp(); demoApp.start();"},{"url":"/articles/8df409a9cfdf41e8b67099026cddbc66/","date":"2018-12-02","title":"[C\u002B\u002B] DirectX9で太陽系を描画する","category":{"order":0,"name":"Demo","url":"/categories/demo/"},"tags":[{"name":"3D","url":"/tags/3d/"},{"name":"DirectX","url":"/tags/directx/"},{"name":"C\u002B\u002B","url":"/tags/cpp/"}],"content":"はじめに 3Dプログラミング学習用に昔作成したアプリです。 https://github.com/yoshiheight/Sample.D3DGalaxy \u003Cdiv style=\u0022max-width: 640px;\u0022\u003E\u003Cvideo src=\u0022/files/d3d-galaxy.mp4\u0022 controls\u003E\u003C/video\u003E\u003C/div\u003E 仕様 惑星の大きさ、惑星間の距離は実際の値を反映 軌道傾斜角、楕円軌道は無視 カメラは「原点を注視するモード」「惑星を一定距離で注視するモード」を切り替え可能 「惑星を一定距離で注視するモード」の場合、惑星間を移動可能 太陽 \u003E 惑星公転 \u003E 衛星公転は、行列の親子関係で処理する 周囲の星々は天球を使って処理する 操作方法 キー |操作 -----|-------------- テンキー 1 / 3 |カメラX軸移動（\u002B Ctrl で回転） テンキー 5 / 2 |カメラY軸移動（\u002B Ctrl で回転） テンキー 9 / 6 |カメラZ軸移動（\u002B Ctrl で回転） テンキー \u002B / - |カメラズーム Q / W |公転半径割合変更 ESC |終了 F1 |固定FPSモード / FPS計測モードの切り替え F2 |惑星間のカメラ移動 F3 |カメラ切り替え（原点注視 / 惑星を一定距離で注視） F4 |ライトON / OFF F5 |Solid / Wireframe切り替え F6 |惑星サイズ実物 / 全て同一切り替え F7 |公転リセット"},{"url":"/articles/718ac1cb539c47edb70462354c110387/","date":"2018-12-01","title":"[C\u002B\u002B] DirectX9で高さマップから地形を生成する","category":{"order":0,"name":"Demo","url":"/categories/demo/"},"tags":[{"name":"3D","url":"/tags/3d/"},{"name":"DirectX","url":"/tags/directx/"},{"name":"C\u002B\u002B","url":"/tags/cpp/"}],"content":"はじめに 3Dプログラミング学習用に昔作成したアプリです。 https://github.com/yoshiheight/Sample.D3DField \u003Cdiv style=\u0022max-width: 640px;\u0022\u003E\u003Cvideo src=\u0022/files/d3d-field.mp4\u0022 controls\u003E\u003C/video\u003E\u003C/div\u003E 仕様 地形を表すメッシュ状のポリゴンを、外部からロードした高さマップによって生成する 高さマップは、グレースケールのBMP画像を使用する 1ピクセルがポリゴン1頂点を表す 各ピクセルが256段階の高さを表し、色が薄いほど高い標高とする 地形全体に地形画像用テクスチャをマッピング可能とする テクスチャのサイズは高さマップと同じでなくてもいい ポイントスプライトを使用して雪を降らせる 雪はαで抜きの入った画像を使用 操作方法 キー |操作 -----|-------------- ← / → |モデルX軸移動（\u002B Ctrl で回転） ↑ / ↓ |モデルY軸移動（\u002B Ctrl で回転） PgUp / PgDn |モデルZ軸移動（\u002B Ctrl で回転） テンキー 1 / 3 |カメラX軸移動（\u002B Ctrl で回転） テンキー 5 / 2 |カメラY軸移動（\u002B Ctrl で回転） テンキー 9 / 6 |カメラZ軸移動（\u002B Ctrl で回転） テンキー \u002B / - |カメラズーム 1 / Q |光源色R 2 / W |光源色G 3 / E |光源色B A / Z |光源方向X S / X |光源方向Y D / C |光源方向Z O / L |高さ単位 ESC |終了 F1 |固定FPSモード / FPS計測モードの切り替え F2 |頂点バッファ/ インデックスバッファの切り替え F3 |カメラ切り替え（原点注視 / 任意注視） F4 |ライトON / OFF F5 |Solid / Wireframe切り替え F6 |法線表示ON / OFF F7 |テクスチャON / OFF F8 |フォグON / OFF"},{"url":"","date":"","title":"","category":{"order":0,"name":"","url":""},"tags":[],"content":""}]
