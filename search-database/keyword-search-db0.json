[{"url":"/articles/3aef3dc23cbe4f27b736baab57f2cb04/","date":"2020-06-18","title":"[C#] 基底クラスが明示的に実装するインターフェイスを派生クラスでも実装できてしまう","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"概要 基底クラスと派生クラスで、同じインターフェイスを明示的に実装できてしまいます。コンパイル時に警告はでません。 この場合、派生クラス側が呼び出されます。 ソースコード using System; class Program { static void Main() { IHoge hoge = new Derived(); hoge.Write(); // Derived.Write() } } interface IHoge { void Write(); } class Base : IHoge { void IHoge.Write() { Console.WriteLine(Base.Write()); } } class Derived : Base, IHoge { void IHoge.Write() { Console.WriteLine(Derived.Write()); } }"},{"url":"/articles/0e2549ccc8914c358172b5a12ddd9c6f/","date":"2020-06-17","title":"[C#] Marshal.PtrToStructure[T](IntPtr, T)は参照型専用","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"はじめに Marshal.PtrToStructure\u003CT\u003E(IntPtr, T)はデータの格納先となる第2引数がT型の値渡しになっており、当然といえば当然ですが参照型専用のメソッドです。 値型を渡すと実行時に例外が発生します。 この場合の参照型とは、StructLayout属性を指定したクラスになります。 ソースコード using System; using System.Runtime.InteropServices; class Program { static void Main() { Hoge? hoge = null; var ptr = Marshal.AllocHGlobal(Marshal.SizeOfHoge()); try { unsafe { var p = (byte*)ptr; p[0] = 123; p[1] = 234; p \u002B= 2; *(int*)p = 68000; } hoge = new Hoge(); Marshal.PtrToStructure(ptr, hoge); } finally { Marshal.FreeHGlobal(ptr); } Console.WriteLine(hoge.foo); // 123 Console.WriteLine(hoge.bar); // 234 Console.WriteLine(hoge.piyo); // 68000 } } [StructLayout(LayoutKind.Sequential, Pack = 1)] sealed class Hoge { public byte foo; public byte bar; public int piyo; } おわりに 参照型専用であれば、型制約を付けておいてほしいところですが、付いてないです。なぜでしょうか。。"},{"url":"/articles/70187e20ef54497eb816fa8345b90f62/","date":"2020-06-16","title":"[C#] ボックス化された構造体のメモリを直接書き換える","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"はじめに GCHandleを使った遊びです。 ボックス化された構造体をアンボックス化前に読み書きすることは通常はできないですが、GCHandleを使って直接メモリにアクセスすることで実現可能です。 ソースコード using System; using System.Runtime.InteropServices; class Program { static void Main() { object boxedObj = new Hoge(); var handle = GCHandle.Alloc(boxedObj, GCHandleType.Pinned); try { unsafe { var p = (byte*)handle.AddrOfPinnedObject(); p[0] = 123; p[1] = 234; p \u002B= 2; *(int*)p = 68000; } } finally { handle.Free(); } var unboxedHoge = (Hoge)boxedObj; Console.WriteLine(unboxedHoge.foo); // 123 Console.WriteLine(unboxedHoge.bar); // 234 Console.WriteLine(unboxedHoge.piyo); // 68000 } } [StructLayout(LayoutKind.Sequential, Pack = 1)] struct Hoge { public byte foo; public byte bar; public int piyo; } おわりに やはりポインタ操作はワクワクしますね！"},{"url":"/articles/ab51e06a45444006810286b95be95970/","date":"2020-06-15","title":"[C#] オプション引数と可変長引数の落とし穴","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"概要 落とし穴というか、実際にはこういうコードは書いちゃダメという話です。 個人的にはオプション引数や可変長引数はあまり好きではないです。 極端にいえばオーバーロードもあまり好きではなく、実際には、 引数用の構造体を用意した方がいい 引数が違うということは、そもそもメソッド名を変えた方がいい というケースが多いです。 ソースコード 通常のメソッド／オプション引数のメソッド／可変長引数のメソッドで、同じシグネチャとして解釈できるコードと実行時の挙動 using System; class Program { static void Main() { Test(); // 出力：Test() Test(100); // 出力：Test(int) Test(100, 200); // 出力：Test(params int[]) } static void Test() { Console.WriteLine(Test()); } static void Test(int num = 0) { Console.WriteLine(Test(int)); } static void Test(params int[] nums) { Console.WriteLine(Test(params int[])); } } インターフェイス／抽象クラス／派生クラスで、同じメソッドにオプション引数を使用したコードと実行時の挙動 using System; class Program { static void Main() { var hoge = new HogeDerived(); (hoge as IHoge).Test(); // 出力：0 (hoge as HogeBase).Test(); // 出力：100 hoge.Test(); // 出力：999 } } interface IHoge { void Test(int num = 0); } abstract class HogeBase : IHoge { public abstract void Test(int num = 100); } class HogeDerived : HogeBase { public override void Test(int num = 999) { Console.WriteLine(num); } }"},{"url":"/articles/67ff5d3851ef498a9175879d5d16105c/","date":"2020-06-12","title":"[C#] Blazor WebAssemblyでGUIDを生成して表示するだけ","category":{"order":0,"name":"Demo","url":"/categories/demo/"},"tags":[{"name":"C#","url":"/tags/cs/"},{"name":"Blazor","url":"/tags/blazor/"},{"name":"WebAssembly","url":"/tags/webassembly/"},{"name":"ASP.NET Core","url":"/tags/aspnetcore/"}],"content":"デモ https://crash.jp/apps/guidgenerator/"},{"url":"/articles/3dfc4bf66bc94bd38cadd67f3b51d3db/","date":"2020-06-11","title":"[C#] Blazor WebAssemblyがキャッシュしたDLLの削除方法","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"},{"name":"Blazor","url":"/tags/blazor/"},{"name":"WebAssembly","url":"/tags/webassembly/"},{"name":"ASP.NET Core","url":"/tags/aspnetcore/"}],"content":"キャッシュの削除方法 Blazor WebAssembly がキャッシュした DLL は Cache API を使用して保存されているので、以下の方法で削除できます。 例）Chrome 開発ツールを開く Application タブへ移動 Cache \u003E Cache Storage の中から該当するものを削除"},{"url":"/articles/8076c162d46a4729ad45a3519b63b1bf/","date":"2020-06-10","title":"CanvasRenderingContext2Dに対する描画は同期的には画面表示されない","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"2D","url":"/tags/2d/"},{"name":"JavaScript","url":"/tags/javascript/"},{"name":"Web全般","url":"/tags/general-web/"}],"content":"CanvasRenderingContext2D に対する描画について HTML の Canvas は、JavaScript で CanvasRenderingContext2D を取得して使用することで 2D 描画が可能ですが、 その描画は即座には画面表示に反映されません。 マウス移動イベントやタイマーイベント等の短い間隔で負荷の高い描画を行うと、描画内容の変化が滑らかに画面表示されないので、 その場合は window.requestAnimationFrame を使用して描画すると解決します。"},{"url":"/articles/9accd8bd449647bcaacf0e5909ef74a6/","date":"2020-06-09","title":"[C#] PLINQのSelectを試す","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"},{"name":"PLINQ","url":"/tags/plinq/"}],"content":"概要 普段ほとんど使う機会のない PLINQ を、Select だけ試してみました。 ソースコード using System; using System.Linq; using System.Threading; #nullable enable class Program { static void Main() { var query = new[] { 4, 2, 1, 3 } .AsParallel() //.AsOrdered() .Select(n = { n *= 1000; Thread.Sleep(n); return n; }); foreach (var n in query) { Console.WriteLine(n); } // 実行結果： // 1000 ....... 1秒後 // 2000 ....... 2秒後 // 3000 ....... 3秒後 // 4000 ....... 4秒後 // 実行結果： AsOrdered()を使用した場合 // 4000 ....... 4秒後 // 2000 ....... 4秒後 // 1000 ....... 4秒後 // 3000 ....... 4秒後 } }"},{"url":"/articles/91c9b9e34c204d70824f6eca7d84b5bf/","date":"2020-06-08","title":"[C#] ジェネリックなクラスや構造体の中の静的フィールドは型指定毎に存在する","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"概要 ふと EqualityComparer\u003Choge\u003E.Default を見ていて、 Default ってジェネリックの型指定毎に別物なんだろうと思い（まぁそうとしか考えられないですが）、 確かめたくなったので試してみました。 実験１ using System; #nullable enable class Program { static void Main() { _ = Hogeint.Default; _ = Hogestring.Default; _ = Hoge(string, int).Default; // 実行結果： // System.Int32 // System.String // System.ValueTuple\u00602[[System.String, 長いので省略],[System.Int32, 長いので省略]] } } class HogeT { public static readonly HogeT Default = new HogeT(); public Hoge() { Console.WriteLine(typeof(T).FullName); } } 実験２ using System; #nullable enable class Program { static void Main() { _ = Hogeint.Fuga; _ = Hogestring.Fuga; _ = Hoge(string, int).Fuga; // 実行結果： // Fuga // Fuga // Fuga } } static class HogeT // class HogeT でも結果は同じ // struct HogeT でも結果は同じ { public static readonly Fuga Fuga = new Fuga(0); } struct Fuga { public Fuga(int _) { Console.WriteLine(Fuga); } } 結論 「ジェネリックなクラス（静的／非静的問わず）や構造体」の中の「静的フィールド」は、ジェネリックの型指定毎に独立して存在していました。"},{"url":"/articles/5347cbfd659f463487682f03434798b3/","date":"2020-06-07","title":"[C#] 値型とnullが比較できてしまうという話","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"概要 値型と null が比較できてしまう場合があります。 比較することに意味はないのでコンパイルエラーになってほしいですが。 ソースコード using System; #nullable enable class Program { static void Main() { // コンパイルは通り（警告は出るけど）、以下の比較結果は true となる。 var n = 100; if (n != null) { } // これはコンパイルエラーとなる。 var hoge = new Hoge(); if (hoge != null) { } // ==, != 演算子をオーバーロードすればコンパイルは通るけど、 // 演算子は実際には呼び出されないという謎の挙動。 // 以下の比較結果は true となる。 var fuga = new Fuga(); if (fuga != null) { } } } struct Hoge { } struct Fuga { public static bool operator ==(Fuga left, Fuga right) { throw new NotImplementedException(); } public static bool operator !=(Fuga left, Fuga right) { throw new NotImplementedException(); } }"},{"url":"/articles/6eae5c30c3624d17927d40648612dd93/","date":"2020-06-06","title":"[C#] 参照型の等値演算子は暗黙裡に機能してほしくないという話","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"概要 参照型に対する ==, != 比較は、デフォルトで参照の等値性の比較になります。 ですが、演算子はオーバーロードで挙動を変えられますし、 ==, != が参照を比較しているのか、内容を比較しているのか、どっちを表しているのかがあいまいです。 というわけで、参照比較は明示的に行った方がいい、という話です。 備考 まぁ基本的には参照型の ==, != 比較は「参照の比較」であるべきと Microsoft は推奨しているけど（Effective C# にそう書いてあった） これは Equals を内容比較するようにオーバーライドしていたとしても。つまり Equals が true を返すときに == は false を返す場合もあるということ ちなみに値型は ==, != 比較は演算子をオーバーロードしないと使用できない ソースコード using System.Runtime.CompilerServices; #nullable enable class Program { static void Main() { var hoge1 = new Hoge(); var hoge2 = hoge1; // 暗黙裡に ==、!= が機能するのが気に入らない // （デフォルトで参照比較だし、演算子をオーバーロードすれば挙動は変わるし） if (hoge1 == hoge2) { } // 明示的に参照比較にしたい場合、object.ReferenceEquals を使用すればいいが、 // このメソッドは引数が object? 型なのが気に入らない // （間違って値型を渡すとボックス化されるし） if (object.ReferenceEquals(hoge1, hoge2)) { } // 以下のようなメソッドを定義して使った方がメンテナンス性が高い if (hoge1.ClassReferenceEquals(hoge2)) { } } } class Hoge { } static class ObjectExtension { [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool ClassReferenceEqualsT(this T obj1, T obj2) where T : class? { return object.ReferenceEquals(obj1, obj2); } }"},{"url":"/articles/99e4791b441643eba63125fd592d59b8/","date":"2020-06-05","title":"[C#] ボックス化は暗黙裡に機能してほしくないという話","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"概要 値型は、object型変数やインターフェイス型変数に代入するだけでボックス化されます。 ある意味ではアップキャストなので、明示的なキャストが必要なく暗黙裡に行えるというのは言語仕様的にわからなくもないのですが、 気付かずにボックス化されるという副作用もあります。 気づきにくい例 object型を引数にとるメソッドに渡す場合 当初クラスとして実装したけどあとから構造体に変更した場合、その変数を使用している箇所とか というわけで、せめてボックス化／ボックス化解除用のメソッドを用意してそれを使おう、そうすればあとから探すときにも楽、という話です。 ソースコード using System.Diagnostics.CodeAnalysis; #nullable enable class Program { static void Main() { Hoge hoge = default; // 以下のように暗黙裡にボックス化されるのは好きじゃない object obj = hoge; // ボックス化 IHoge ihoge = hoge; // ボックス化 // 以下のように明示的にボックス化するコードの方がメンテナンス性が高い hoge.Boxing(out IHoge ihoge2); } } interface IHoge { } struct Hoge : IHoge { } static class ObjectExtension { public static void BoxingTSource, TResult(this TSource source, out TResult outResult) where TSource : struct where TResult : class { outResult = (TResult)(object)source; } public static void BoxingTSource, TResult(this TSource? source, [NotNullIfNotNull(source)] out TResult? outResult) where TSource : struct where TResult : class { outResult = (TResult?)(object?)source; } public static void UnboxingTSource, TResult(this TSource source, out TResult outResult) where TSource : class where TResult : struct { outResult = (TResult)(object)source; } public static void UnboxingTSource, TResult(this TSource? source, [NotNullIfNotNull(source)] out TResult? outResult) where TSource : class where TResult : struct { outResult = (TResult?)(object?)source; } }"},{"url":"/articles/3a91c1d948c44ed690435d18d903a582/","date":"2020-06-04","title":"[C#] foreachに必要な最低限のEnumerableとEnumerator","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"概要 foreach でループする際に必要になる最低限の Enumerable, Enumerator の実装です。実務で使ってはダメなコードです。 foreach の対象はダックタイピングなので、IEnumerable, IEnumerator インターフェイスの実装は必須ではありません（とはいえ必要なプロパティやメソッドを満たしているかはコンパイル時にチェックされる）。 （ダックタイピングといえば、C\u002B\u002B のテンプレートや TypeScript のインターフェイスは静的なダックタイピングといえる。C# にも同じ機能ほしいなぁ、とたまに思う。副作用はあるだろうけど） ソースコード using System; using System.Collections.Generic; #nullable enable class Program { static void Main() { var hoge = new HogeEnumerable(); foreach (var s in hoge) { Console.WriteLine(s); } // 実行結果： // hoge // fuga // piyo } } class HogeEnumerable { private string[] _data = new[] { hoge, fuga, piyo }; public ValueEnumeratorstring GetEnumerator() { return new ValueEnumeratorstring(_data); } } // ListT.Enumerator のように構造体にした。 // ヒープは消費したくないし。 struct ValueEnumeratorT { private readonly IReadOnlyListT _list; private int _index; public ValueEnumerator(IReadOnlyListT list) { _list = list; _index = 0; Current = default!; } public T Current { get; private set; } public bool MoveNext() { if (_index _list.Count) { Current = _list[_index\u002B\u002B]; return true; } return false; } }"},{"url":"/articles/f5546510b986466cba747d9644745029/","date":"2020-06-03","title":"[C#] IntelのCPUがリトルエンディアンであることを確認する","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"概要 自環境のCPU（Intel Core i3）がリトルエンディアンであることを、実際にメモリレイアウトを見て確認します。 ソースコード using System; using System.Runtime.InteropServices; #nullable enable class Program { static void Main() { // リトルエンディアンかどうか Console.WriteLine(BitConverter.IsLittleEndian); // True var union = new Union { num = 0x_0A_1B_2C_3D }; // 実際に下位バイトから格納されているか確認 Console.WriteLine(union.dword.byte0.ToString(X2)); // 3D Console.WriteLine(union.dword.byte1.ToString(X2)); // 2C Console.WriteLine(union.dword.byte2.ToString(X2)); // 1B Console.WriteLine(union.dword.byte3.ToString(X2)); // 0A // BitConverter.TryWriteBytesでも確認 Spanbyte bytes = stackalloc byte[4]; BitConverter.TryWriteBytes(bytes, union.num); Console.WriteLine(bytes[0].ToString(X2)); // 3D Console.WriteLine(bytes[1].ToString(X2)); // 2C Console.WriteLine(bytes[2].ToString(X2)); // 1B Console.WriteLine(bytes[3].ToString(X2)); // 0A // 備考：ビットシフト演算子の処理結果はエンディアンは関係ない Console.WriteLine((union.num 24).ToString(X2)); // 0A Console.WriteLine((union.num 16 0xFF).ToString(X2)); // 1B Console.WriteLine((union.num 8 0xFF).ToString(X2)); // 2C Console.WriteLine((union.num 0xFF).ToString(X2)); // 3D } } [StructLayout(LayoutKind.Explicit)] struct Union { [FieldOffset(0)] public uint num; [FieldOffset(0)] public DWord dword; } [StructLayout(LayoutKind.Sequential)] struct DWord { public byte byte0; public byte byte1; public byte byte2; public byte byte3; }"},{"url":"/articles/1fd038618df241c9adce790f10c0db52/","date":"2020-06-02","title":"[C#] FizzBuzz","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"今更ですが、C# で FizzBuzz です。 案）まず最初は using System; class Program { static void Main() { // とりあえずこう書くか for (var i = 1; i = 100; i\u002B\u002B) { var isFizz = (i % 3) == 0; var isBuzz = (i % 5) == 0; if (isFizz isBuzz) { Console.WriteLine(FizzBuzz); } else if (isFizz) { Console.WriteLine(Fizz); } else if (isBuzz) { Console.WriteLine(Buzz); } else { Console.WriteLine(i); } } // もしくはこう書くか for (var i = 1; i = 100; i\u002B\u002B) { var isFizz = (i % 3) == 0; var isBuzz = (i % 5) == 0; if (isFizz || isBuzz) { if (isFizz) { Console.Write(Fizz); } if (isBuzz) { Console.Write(Buzz); } } else { Console.Write(i); } Console.WriteLine(); } } } 案）StringBuilderを使用 using System; using System.Text; class Program { static void Main() { var sb = new StringBuilder(); for (var i = 1; i = 100; i\u002B\u002B) { if (i % 3 == 0) { sb.Append(Fizz); } if (i % 5 == 0) { sb.Append(Buzz); } if (sb.Length == 0) { sb.Append(i); } Console.WriteLine(sb); sb.Clear(); } } } 案）パターンマッチング using System; class Program { static void Main() { // プロパティパターンマッチング for (var i = 1; i = 100; i\u002B\u002B) { Console.WriteLine((modFizz: i % 3, modBuzz: i % 5) switch { { modFizz: 0, modBuzz: 0 } = FizzBuzz, { modFizz: 0 } = Fizz, { modBuzz: 0 } = Buzz, _ = Convert.ToString(i), }); } // 位置パターンマッチング for (var i = 1; i = 100; i\u002B\u002B) { Console.WriteLine((i % 3, i % 5) switch { (0, 0) = FizzBuzz, (0, _) = Fizz, (_, 0) = Buzz, _ = Convert.ToString(i), }); } // varパターンマッチング for (var i = 1; i = 100; i\u002B\u002B) { Console.WriteLine(i switch { var _ when i % 15 == 0 = FizzBuzz, var _ when i % 3 == 0 = Fizz, var _ when i % 5 == 0 = Buzz, _ = Convert.ToString(i), }); } } } 案）FizzBuzz値を表す構造体 using System; class Program { static void Main() { for (var v = new FizzBuzzValue(1); v = 100; v\u002B\u002B) { Console.WriteLine(v); } } } readonly struct FizzBuzzValue { private readonly int _num; public FizzBuzzValue(int num) { _num = num; } public static bool operator =(FizzBuzzValue fizzBuzzValue, int num) { return fizzBuzzValue._num = num; } public static bool operator =(FizzBuzzValue fizzBuzzValue, int num) { return fizzBuzzValue._num = num; } public static FizzBuzzValue operator \u002B\u002B(FizzBuzzValue fizzBuzzValue) { return new FizzBuzzValue(fizzBuzzValue._num \u002B 1); } public override string ToString() { return (_num % 3, _num % 5) switch { (0, 0) = FizzBuzz, (0, _) = Fizz, (_, 0) = Buzz, _ = Convert.ToString(_num), }; } } 案）コルーチンを使用 using System; using System.Collections.Generic; class Program { static void Main() { foreach (var s in FizzBuzzGenerator.Generate(1, 100)) { Console.WriteLine(s); } } } static class FizzBuzzGenerator { public static IEnumerablestring Generate(int start, int count) { for (var i = start; i = count; i\u002B\u002B) { yield return (i % 3, i % 5) switch { (0, 0) = FizzBuzz, (0, _) = Fizz, (_, 0) = Buzz, _ = Convert.ToString(i), }; } } } 案）外部から条件を指定 using System; using System.Collections.Generic; using System.Linq; class Program { static void Main() { var fb = new FizzBuzzGenerator(new (Funcint, bool condition, string value)[] { (n = n % 3 == 0, Fizz), (n = n % 5 == 0, Buzz), }); foreach (var s in fb.Generate(1, 100)) { Console.WriteLine(s); } } } class FizzBuzzGenerator { private readonly IReadOnlyList(Funcint, bool condition, string value) _rules; public FizzBuzzGenerator(IReadOnlyList(Funcint, bool, string) rules) { _rules = rules; } public IEnumerablestring Generate(int start, int count) { return Enumerable.Range(start, count).Select(n = _rules.Aggregate( (string?)null, (s, rule) = rule.condition(n) ? s \u002B rule.value : s, s = s ?? n.ToString())); } } 案）三項演算子でワンライナー using System; using System.Linq; class Program { static void Main() = Enumerable.Range(1, 100).Select(n = n % 15 == 0 ? FizzBuzz : n % 3 == 0 ? Fizz : n % 5 == 0 ? Buzz : n.ToString()).ToList().ForEach(Console.WriteLine); }"},{"url":"/articles/79f6f7e9a5e54d599af457ef07a4e129/","date":"2020-06-01","title":"[C#] IListがIReadOnlyListを継承していない理由を考える","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"概要 .NET には IReadOnlyList\u003CT\u003E というインターフェイスが途中から追加されましたが、 IList\u003CT\u003E は IReadOnlyList\u003CT\u003E を継承するように変更されてはいません。 その理由を考察してみます。 考察１：互換性問題 実験 実際にコードを書いて試してみます。 public interface IReadOnlyListT { T this[int index] { get; } } public interface IListT : IReadOnlyListT { // IReadOnlyListのインデクサを隠すのでコンパイル時に警告がでるので、new指定が必要 new T this[int index] { set; get; } // こうでもいいが、どちらにしてもインデクサを隠すことになるのでコンパイル時に警告がでる // T this[int index] { set; } } public class ListT : IListT { private T[] _array = Array.EmptyT(); public T this[int index] { get = _array[index]; set = _array[index] = value; } } new指定でコンパイル時の警告を消しているのは気持ち悪いですが、ビルドは通り、動作的にも問題ありません。 但し、以前の IList\u003CT\u003E を明示的インターフェイス実装しているクラスがあった場合、コンパイルエラーとなります。 コンパイルエラーとなる public class MyListT : IListT { private T[] _array = Array.EmptyT(); T IListT.this[int index] { get = _array[index]; set = _array[index] = value; } } こうする必要がある public class MyListT : IListT { private T[] _array = Array.EmptyT(); T IListT.this[int index] { get = _array[index]; set = _array[index] = value; } // これが必要 T IReadOnlyListT.this[int index] { get = _array[index]; } } 結論 互換性の問題が理由の一つとしてあります。 考察２：オブジェクト指向的な問題 オブジェクト指向的に見て、IList\u003CT\u003E は IReadOnlyList\u003CT\u003E を継承していいか、ですが、どちらかといえば「継承させない方がいい」と思うのですが、実際には、 業務で書くなら、継承させない 趣味で書くなら、継承させる と思います。 ReactiveProperty はどうなのか調べてみた IReactiveProperty.cs https://github.com/runceel/ReactiveProperty/blob/v6.1.3/Source/ReactiveProperty.NETStandard/IReactiveProperty.cs https://github.com/runceel/ReactiveProperty/blob/v6.1.4/Source/ReactiveProperty.NETStandard/IReactiveProperty.cs v6.1.4 から、IReactiveProperty\u003CT\u003E は IReadOnlyReactiveProperty\u003CT\u003E を継承するように変更されていました。 結論 オブジェクト指向的に見た場合、「こうするべき」という結論には至っていません。 何か思いついたらまた記載します。"},{"url":"/articles/3803c333c8184c37b10c60b0b40786a8/","date":"2020-05-27","title":"[C#] SeleniumでEdgeを操作してみた","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"},{"name":"Selenium","url":"/tags/selenium/"},{"name":"Edge","url":"/tags/edge/"}],"content":"概要 Selenium ブラウザを操作するライブラリ。各 Web ブラウザが提供する WebDriver 経由でブラウザを操作する https://www.selenium.dev/ https://www.selenium.dev/documentation/ja/ 環境構築 Selenium.WebDriver https://www.nuget.org/packages/Selenium.WebDriver/ Edge WebDriver 本体 Edge のバージョンに対応するものをダウンロードし、適当なディレクトリに解凍する https://developer.microsoft.com/ja-jp/microsoft-edge/tools/webdriver/ ソースコード using System; using OpenQA.Selenium; using OpenQA.Selenium.Edge; using OpenQA.Selenium.Support.UI; namespace Sample.Selenium { class Program { static void Main() { var driver = new EdgeDriver(EdgeDriverService.CreateDefaultService(@C:\\edgedriver_win64, msedgedriver.exe)); // URL遷移 driver.Navigate().GoToUrl(https://crash.jp/); // 検索アイコンをクリック driver.FindElement(By.Id(search-icon)).Click(); // 検索ボックスに文字列入力してサブミット var searchBox = driver.FindElement(By.CssSelector(input[type=\u0027search\u0027]:focus)); searchBox.SendKeys(SeleniumでEdgeを操作してみた); searchBox.Submit(); // 検索結果一覧から記事ページへ遷移 var articleLink = new WebDriverWait(driver, TimeSpan.FromSeconds(3)) .Until(d = d.FindElement(By.CssSelector(.article-list-title a))); articleLink.Click(); Console.ReadKey(); driver.Quit(); } } }"},{"url":"/articles/5ae9067e545146bc918f8ae4ca28f61c/","date":"2020-05-24","title":"[TS] Three.jsでWebGLを試す","category":{"order":0,"name":"Demo","url":"/categories/demo/"},"tags":[{"name":"3D","url":"/tags/3d/"},{"name":"Three.js","url":"/tags/threejs/"},{"name":"TypeScript","url":"/tags/typescript/"}],"content":"デモ \u003Cdiv id=\u0022my-progress\u0022\u003E初期化中...\u003C/div\u003E \u003Cdiv id=\u0022my-demo-fps\u0022\u003E\u003C/div\u003E \u003Cdiv id=\u0022my-demo-view\u0022\u003E\u003C/div\u003E はじめに 本屋でオライリーのThree.js本を見かけて面白そうだったので試してみました。 Three.js https://threejs.org/ CDN https://www.jsdelivr.com/package/npm/three 環境構築 npm install three 型定義ファイルは含まれてる ソースコード ThreeDemo.ts \u003Cdiv id=\u0022my-demo-ts-code\u0022\u003E\u003C/div\u003E \u003Cscript src=\u0022/files/threedemo-ts/app/bootloader.js?v=4dbb9813df864993afcfe24b3a44b8f2\u0022\u003E\u003C/script\u003E \u003Cscript\u003E $(async () =\u003E { await ThreeDemo.BootLoader.loadAsync(); await ThreeDemo.Application.start(\u0022#my-demo-view\u0022, \u0022#my-demo-fps\u0022); $(\u0022#my-progress\u0022).hide(); CrashPagesJS.Common.HljsUtil.createBlock(\u0022#my-demo-ts-code\u0022, \u0022ts\u0022, \u0060/files/threedemo-ts/source/ThreeDemo.ts?v=${ThreeDemo.Application.Version}\u0060); }); \u003C/script\u003E"},{"url":"/articles/fd421c4029954c7cbae5b75a125db1fc/","date":"2020-04-15","title":"モバイルディスプレイでVisual Studioを快適に使うための設定","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"Visual Studio","url":"/tags/visualstudio/"},{"name":"開発全般","url":"/tags/general-dev/"}],"content":"概要 最近、ASUS の MB16AC というモバイルディスプレイをメインで使っているのですが、Visual Studio で表示を見やすくする為に設定変更した箇所について記載します。 前提 Visual Studio 2019 15.6型フルHDディスプレイ Windowsの表示拡大率は100%のまま 備考：もし表示の実サイズを24型ディスプレイと同じにする場合、約150%の拡大率にする必要がある Visual Studio の設定 環境フォント Visual Studio のメニュー等のフォントは変更することができます。 オプション ＞ 環境 ＞ フォントおよび色 設定の表示＝環境 Yu Gothic UI, 11 エディタのフォント とにかく文字の線が細すぎて見づらいので、このフォント変更は必須です。 オプション ＞ 環境 ＞ フォントおよび色 設定の表示＝テキストエディタ Consolas, 14 ナビゲーションバー エディタ上部に配置されている、クラス一覧やメソッド一覧のコンボボックスのやつです。 使用しない人は非表示にしましょう。 オプション ＞ テキストエディタ ナビゲーションバーをオフ Shrink Empty Lines Productivity Power Tools の Shrink Empty Lines を使用することでエディタ内の表示行数を増やすことができます。 https://marketplace.visualstudio.com/items?itemName=VisualStudioPlatformTeam.SyntacticLineCompression 全画面表示 全画面表示した際はテキストエディタだけを表示するようにした方がいいです。 その他 Visual Studio 以外の通常のテキストエディタでもフォント設定は変更した方がいいです。 ASCII文字のフォント Consolas ASCII文字以外のフォント メイリオ にすると見やすいと思います。"},{"url":"/articles/087891ae08fd490d92e090ad3ef0d1f2/","date":"2020-03-05","title":"HTTP通信のキャプチャはFiddlerが便利","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"Fiddler","url":"/tags/fiddler/"},{"name":"開発全般","url":"/tags/general-dev/"}],"content":"概要 以前から仕事で使用していて便利なので、その紹介です。 https://www.telerik.com/fiddler 元マイクロソフト社員が開発したとかだったはず いつのまにかダウンロード時にメールアドレスの登録が必須になっていて、残念です。。 通信のキャプチャ Fiddler を起動すると自動的に HTTP プロキシとして動作するので、外部の Web サーバーにアクセスする場合は何もしなくても通信がキャプチャ可能 ブラウザのプロキシ設定（というより Windows のプロキシ設定？）についても、Fiddler が起動時に勝手に書き換え、終了時に勝手に元に戻す ローカルホストとの通信や HTTP クライアントが独自実装の場合 IP アドレスに ipv4.fiddler を指定する（厳密には Fiddler の IP/Port 設定にあわせる） 注意点 Fiddler のせいでプロキシ設定がおかしくなったことが過去にあった Fiddler を頻繁に使用している環境で突然ネットに繋がらなくなった場合、プロキシ設定を確認すべし"},{"url":"/articles/b27a5b2ea88d47d09e4364d4da11e266/","date":"2020-01-30","title":"Markdownについてざっくりと","category":{"order":1,"name":"Tech","url":"/categories/tech/"},"tags":[{"name":"Markdown","url":"/tags/markdown/"},{"name":"開発全般","url":"/tags/general-dev/"}],"content":"概要 Markdown の記法についてざっくりと記載 自分がよく使っているもの or 今後使うかもしれないもの CommonMark 準拠 Markdown とは 考案 https://daringfireball.net/projects/markdown/ CommonMark Markdown の仕様を詳細まで策定しよう、ということでできた Markdown 方言の一つ https://commonmark.org/ 見出し # 見出し1 ## 見出し2 ### 見出し3（末尾の連続した#は無視される） ############### #### 見出し4 ##### 見出し5 ###### 見出し6 段落 前後を空行にすると段落になる。 なので、この行は別段落になる。 コード コードブロック \u0060\u0060\u0060 ここはコードブロックになる。 \u0060\u0060\u0060 \u0060\u0060\u0060\u0060\u0060\u0060\u0060\u0060\u0060 バッククォート数は3つ以上でも可。 終了のバッククォート数は、開始のバッククォート数以上が必要。 \u0060\u0060\u0060\u0060\u0060\u0060\u0060\u0060\u0060 \u0060\u0060\u0060hoge hoge は code class=language-hoge というように展開される。 \u0060\u0060\u0060 インラインコード \u0060ここはインラインコードになる\u0060 リスト 箇条書き * リスト * リスト * リスト 番号リスト 1. リスト 1. リスト 1. リスト 1. リスト リスト間の空行 1. リスト 1. リスト 1. リスト（間に空行を入れることもできるが、その場合、全てのリストアイテムは段落扱いになる） リストにブロック要素を含める * リスト \u0060\u0060\u0060 あらゆるブロック要素を含めることができる。 前後を空行にする。 インデントは、属するリストの文言部分のインデントと同じにするか、それプラス3文字分までとする。 \u0060\u0060\u0060 * リスト リンク そのままリンク URL 文言リンク [文言](URL) 画像 alt 文言あり ![alt文言](URL) alt 文言なし ![](URL) 引用 引用1 引用2 水平線 ****************** 太字 __太字__ 改行 末尾にバックスラッシュで改行なので、ここは\\ 改行される エスケープ \\# バックスラッシュでエスケープされるので、ここは見出しにはならない HTML のブロック要素 divHTMLのブロック要素がそのまま使える。ブロック要素内のMarkdownは処理されない/div コメント !-- Markdownにはコメントが存在しないので、HTMLコメントで代用する 生成されるHTMLにはコメントそのものが含まれる --"},{"url":"/articles/352e6cf04d564298a009be5d38cb68e9/","date":"2019-11-02","title":"[C#] SpanとRangeを使って配列中の要素を移動させる","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"はじめに SpanとRangeを使って、配列中の要素を移動させる処理を書いてみました。 移動によってできた隙間は、要素型のデフォルト値で埋めています。 ソースコード 環境は .NET Core 3.0 / C# 8.0 using System; #nullable enable class Program { static void Main() { var buffer = new byte[10]; var range = ..3; var span = buffer.AsSpan(); span[range].Fill(1); var offset = 0; range = span.Move(range, offset); Write(buffer, offset); offset = 1; range = span.Move(range, offset); Write(buffer, offset); offset = 3; range = span.Move(range, offset); Write(buffer, offset); offset = 3; range = span.Move(range, offset); Write(buffer, offset); offset = -2; range = span.Move(range, offset); Write(buffer, offset); offset = -5; range = span.Move(range, offset); Write(buffer, offset); // 出力 static void Write(byte[] buffer, int num) { foreach (var elem in buffer) { Console.Write(elem == 1 ? ■ : □); } Console.WriteLine( \u002B (num = 0 ? \u002B : ) \u002B num); } } } static class SampleExtension { /// summary /// スパン内の指定範囲を移動し、移動後の範囲を返す。 /// 移動によってできた隙間は要素型のデフォルト値で埋める。 /// /summary public static Range MoveT(this SpanT span, Range range, int offset) { var srcSpan = span[range]; var dstRange = range.Offset(span.Length, offset); var dstSpan = span[dstRange]; srcSpan.CopyTo(dstSpan); var clearLength = Math.Min(srcSpan.Length, Math.Abs(offset)); var clearRange = (offset = 0) ? ..clearLength : ^clearLength..; srcSpan[clearRange].Clear(); return dstRange; } /// summary /// 範囲をオフセットして返す。 /// /summary public static Range Offset(this Range range, int length, int offset) { var item = range.GetOffsetAndLength(length); return new Range(item.Offset \u002B offset, item.Offset \u002B offset \u002B item.Length); } } 実行結果 ■■■□□□□□□□ \u002B0 □■■■□□□□□□ \u002B1 □□□□■■■□□□ \u002B3 □□□□□□□■■■ \u002B3 □□□□□■■■□□ -2 ■■■□□□□□□□ -5 おわりに SpanとRange便利すぎる！"},{"url":"/articles/3a42096b869d4348a920b05b4c0038c0/","date":"2019-10-19","title":"[C#] IronPythonでC#側のオブジェクトを操作するだけのサンプル","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"},{"name":"IronPython","url":"/tags/ironpython/"}],"content":"はじめに IronPython https://www.nuget.org/packages/IronPython/ ソースコード 環境は .NET Core 3.0 / C# 8.0 using System; using IronPython.Hosting; #nullable enable class Program { static void Main() { var sample = new Sample(); var engine = Python.CreateEngine(); var source = engine.CreateScriptSourceFromString(sample.Num = 100;); var scope = engine.CreateScope(); scope.SetVariable(sample, sample); source.Execute(scope); Console.WriteLine(sample.Num); } } public class Sample { public int Num { get; set; } }"},{"url":"/articles/6bb33eff6daa4d1381d187d61cfa2fd6/","date":"2019-10-18","title":"[C#] DispatchProxyでREST Clientを実装して非同期でQiita APIをたたいてみる","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"},{"name":"REST","url":"/tags/rest/"},{"name":"AOP","url":"/tags/aop/"}],"content":"はじめに 以前書いた以下の記事を .NET Core の DispatchProxy を使用するように変更し、更にRESTでの取得処理を非同期にしました。 透過プロキシでREST Clientを実装してQiita APIをたたいてみる https://crash.jp/pages/b771882b37214e448ddbac04f105f7e0/ ソースコード 環境は .NET Core 3.0 / C# 8.0 using System; using System.Linq; using System.Net; using System.Reflection; using System.Runtime.CompilerServices; using System.Runtime.Serialization; using System.Threading.Tasks; using Newtonsoft.Json; using Newtonsoft.Json.Converters; using Newtonsoft.Json.Linq; using RestSharp; #nullable enable class Program { static async Task Main() { var client = RestClientProxy.CreateIQiitaApiClient(https://qiita.com); foreach (var tagInfo in await client.GetTagsAsync(1, 20, QiitaTagSortMode.Count)) { Console.Write(tagInfo.Id.PadRight(15)); Console.Write(tagInfo.Count.ToString().PadRight(10)); Console.WriteLine(tagInfo.FollowersCount); } } } // 以下、Qiita API クライアント public interface IQiitaApiClient { [RestApi(Path = /api/v2/tags, Method = RequestMethod.Get)] TaskQiitaTagInfo[] GetTagsAsync( [RestParam(page)] int page, [RestParam(per_page)] int perPage, [RestParam(sort)] QiitaTagSortMode sortMode); } [DataContract] public enum QiitaTagSortMode { [EnumMember(Value = count)] Count, [EnumMember(Value = name)] Name, } [DataContract] public sealed class QiitaTagInfo { [DataMember(Name = id)] public string Id { get; set; } = string.Empty; [DataMember(Name = items_count)] public int Count { get; set; } [DataMember(Name = followers_count)] public int FollowersCount { get; set; } } // 以下、共通部品 // DispatchProxyから派生する場合、sealedにはできない。あとpublicなデフォルトコンストラクタが必要 public class RestClientProxy : DispatchProxy { private RestClient _client = null!; public static TRestApiClient CreateTRestApiClient(string baseUrl) where TRestApiClient : class { var proxy = CreateTRestApiClient, RestClientProxy(); ((RestClientProxy)(object)proxy).Init(baseUrl); return proxy; } private void Init(string baseUrl) { _client = new RestClient(baseUrl); } protected override object Invoke(MethodInfo methodInfo, object[] args) { var apiAttr = methodInfo.GetCustomAttributeRestApiAttribute()!; var request = new RestRequest(apiAttr.Path, Enum.ParseMethod(apiAttr.Method.ToString(), true)); var serializer = new JsonSerializer(); serializer.Converters.Add(new StringEnumConverter()); var jsonArgs = JArray.FromObject(args, serializer); var paramInfos = methodInfo.GetParameters(); foreach (var item in jsonArgs.Zip(paramInfos, (arg, paramInfo) = (arg, paramInfo))) { var paramAttr = item.paramInfo.GetCustomAttributeRestParamAttribute()!; request.AddParameter(paramAttr.Name, item.arg); } var resultType = methodInfo.ReturnType.GenericTypeArguments[0]; return ResultTypedTaskFactory.Create( DeserializeResultAsync(_client.ExecuteTaskAsync(request), resultType), resultType); // 戻り値のデシリアライズ static async Taskobject? DeserializeResultAsync(TaskIRestResponse executeTask, Type resultType) { var response = await executeTask.ConfigureAwait(false); if (response.ResponseStatus != ResponseStatus.Completed) { throw new RestException(response.StatusCode, response.ErrorMessage, response.ErrorException); } return JsonConvert.DeserializeObject(response.Content, resultType); } } } public enum RequestMethod { Get, Post, } [AttributeUsage(AttributeTargets.Method)] public sealed class RestApiAttribute : Attribute { public string Path { get; set; } = string.Empty; public RequestMethod Method { get; set; } } [AttributeUsage(AttributeTargets.Parameter)] public sealed class RestParamAttribute : Attribute { public string Name { get; } public RestParamAttribute(string name) { Name = name; } } public sealed class RestException : Exception { public HttpStatusCode StatusCode { get; } public RestException(HttpStatusCode statusCode, string errorMessage, Exception errorException) : base(errorMessage, errorException) { StatusCode = statusCode; } } public static class ResultTypedTaskFactory { public static object Create(Taskobject? task, Type resultType) { var genericType = typeof(TaskInvoker).MakeGenericType(resultType); var taskGetter = (ITaskGetter)Activator.CreateInstance(genericType, task).AsNotNullable(); return taskGetter.ResultTypedTask; } private interface ITaskGetter { object ResultTypedTask { get; } } private sealed class TaskInvokerTResult : ITaskGetter { public object ResultTypedTask { get; } public TaskInvoker(Taskobject? task) { ResultTypedTask = InvokeAsync(); async TaskTResult InvokeAsync() { return (TResult)(await task.ConfigureAwait(false))!; } } } } 実行結果 Python 32273 62544 JavaScript 28966 65017 Ruby 23669 36895 Rails 19410 24176 PHP 17307 40479 AWS 14834 6928 iOS 14642 32042 Android 13140 39289 Java 13062 42886 Swift 12597 6856 Docker 11643 6509 Linux 10820 40215 Node.js 9787 29395 Git 8969 38904 Mac 8198 31382 Python3 8130 3156 Unity 8119 4759 C# 8035 25641 Go 7201 5068 MySQL 6721 32644 おわりに 以前はJavaScriptの記事が一番多かったですが、現在はPythonが多いですね。"},{"url":"/articles/8f834044a63f4cef9d41bb4da9709d4d/","date":"2019-10-11","title":"[C#] async／awaitについてざっくりと","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"説明 今更ですが、async/awaitについて。 非同期処理の呼び出し側の利点 継続処理を同期的に書けるし、try-catchで例外捕捉できる 同期コンテキストにより、継続処理や例外捕捉後の処理を呼び出し側スレッド上で実行できる 非同期メソッドはasyncを指定し、メソッド名のサフィックスはAsync 戻り値はTaskかTask\u003CT\u003E、もしくは同期的な処理のみで終わる場合もあるならValueTaskかValueTask\u003CT\u003E async voidなメソッドは、GUIアプリのイベントハンドラのように、待つ必要がない場合のみ使う async voidなメソッドはawaitで待機できないので 同期コンテキストを使用する必要がない場合は、Task.ConfigureAwait(false)を呼び出しておく その方が効率がいいのと、非同期メソッドを使う側でTask.Wait()されてもデッドロックしない ライブラリ側でタスク開始する場合、リソース的に問題ないか要検討 スレッド数の調整やスケジューリングはアプリ側じゃないと正しく判断できないので ソースコード 環境は .NET Core 3.0 / C# 8.0 using System.Threading.Tasks; using System.Windows.Forms; #nullable enable namespace WindowsFormsApp1 { public partial class Form1 : Form { public Form1() { InitializeComponent(); } protected override async void OnMouseDown(MouseEventArgs e) { base.OnMouseDown(e); var result = await Sample.Test1Async(); Text = result.ToString(); } } } static class Sample { // パターン1 public static async Taskint Test1Async() { await Task.Delay(100).ConfigureAwait(false); await Task.Delay(200).ConfigureAwait(false); return await Task.Factory.StartNew(() = { // なにかの重い処理... return 0; }).ConfigureAwait(false); } // パターン2 public static async Taskint Test2Async() { await Task.Delay(100).ConfigureAwait(false); await Task.Delay(200).ConfigureAwait(false); await Task.Delay(300).ConfigureAwait(false); return 0; } // 同期的な処理だけで返す場合があるパターン public static async ValueTaskint Test3Async(int value) { if (value 0) { return -1; } await Task.Delay(100).ConfigureAwait(false); await Task.Delay(200).ConfigureAwait(false); await Task.Delay(300).ConfigureAwait(false); return 0; } }"},{"url":"/articles/38a4689d90be46a18af46d9679fa01e2/","date":"2019-10-10","title":"[C#] Enum.HasFlagの結果を確認","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"はじめに Enum.HasFlagメソッドの結果を確認してみました。 ついでに数値リテラルに2進数リテラルとアンダースコア区切り文字を使用してみました。 ソースコード 環境は .NET Core 3.0 / C# 8.0 class Program { static void Main() { // 0値に対してHasFlagは使用しないけど試してみる Console.WriteLine(SampleOptions.Default.HasFlag(SampleOptions.Default)); // true Console.WriteLine(SampleOptions.Read.HasFlag(SampleOptions.Default)); // true Console.WriteLine(SampleOptions.ReadWrite.HasFlag(SampleOptions.Read)); // true Console.WriteLine(SampleOptions.ReadWrite.HasFlag(SampleOptions.Write)); // true Console.WriteLine(SampleOptions.Read.HasFlag(SampleOptions.ReadWrite)); // false } } [Flags] public enum SampleOptions { Default = 0b_0000_0000, Read = 0b_0000_0001, Write = 0b_0000_0010, ReadWrite = Read | Write, } おわりに 結果としては当然なんですが、 var hasFlag = (Enum値 確認したいEnum値) == 確認したいEnum値; と同じでした。"},{"url":"/articles/cf8e618370ab439c99b273f9158eba44/","date":"2019-10-08","title":"[C#] yieldを使用したメソッドを逆コンパイルしてみた","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"はじめに 以下のコードを逆コンパイルしてみました。 class Sample { public IEnumerableint GetNums() { yield return 1; yield return 2; yield return 3; } } 環境 .NET Core 3.0 / C# 8.0 逆コンパイル internal class Sample { [CompilerGenerated] private sealed class GetNumsd__0 : IEnumerableint, IEnumerable, IEnumeratorint, IEnumerator, IDisposable { private int 1__state; private int 2__current; private int l__initialThreadId; int IEnumeratorint.Current { [DebuggerHidden] get { return 2__current; } } object IEnumerator.Current { [DebuggerHidden] [return: System.Runtime.CompilerServices.Nullable(2)] get { return 2__current; } } [DebuggerHidden] public GetNumsd__0(int 1__state) { this.1__state = 1__state; l__initialThreadId = Environment.CurrentManagedThreadId; } [DebuggerHidden] void IDisposable.Dispose() { } private bool MoveNext() { switch (1__state) { default: return false; case 0: 1__state = -1; 2__current = 1; 1__state = 1; return true; case 1: 1__state = -1; 2__current = 2; 1__state = 2; return true; case 2: 1__state = -1; 2__current = 3; 1__state = 3; return true; case 3: 1__state = -1; return false; } } bool IEnumerator.MoveNext() { //ILSpy generated this explicit interface implementation from .override directive in MoveNext return this.MoveNext(); } [DebuggerHidden] void IEnumerator.Reset() { throw new NotSupportedException(); } [DebuggerHidden] [return: System.Runtime.CompilerServices.Nullable(1)] IEnumeratorint IEnumerableint.GetEnumerator() { if (1__state == -2 l__initialThreadId == Environment.CurrentManagedThreadId) { 1__state = 0; return this; } return new GetNumsd__0(0); } [DebuggerHidden] [return: System.Runtime.CompilerServices.Nullable(1)] IEnumerator IEnumerable.GetEnumerator() { return ((IEnumerableint)this).GetEnumerator(); } } [System.Runtime.CompilerServices.NullableContext(1)] [IteratorStateMachine(typeof(GetNumsd__0))] public IEnumerableint GetNums() { return new GetNumsd__0(-2); } } まとめ 以下のインナークラスが定義され、 private sealed class GetNumsd__0 : IEnumerableint, IEnumerable, IEnumeratorint, IEnumerator, IDisposable GetNums()メソッドで戻り値としてnewされていました。 public IEnumerableint GetNums() { return new GetNumsd__0(-2); }"},{"url":"/articles/cd1787b5df934eaf81c81f44f3b91cd5/","date":"2019-10-07","title":"[C#] クロージャやデリゲートは暗黙的にインスタンス生成されるので注意","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"はじめに クロージャやデリゲートを使用した場合、実際にはインスタンスがヒープ上に確保されています。 クロージャ（ローカル変数をキャプチャする匿名関数/ローカル関数） ローカル変数をキャプチャすると、その変数をフィールドに持つクラスが自動的に定義され、そのインスタンスが暗黙的に生成される デリゲート 匿名関数や通常のメソッドをデリゲート変数に代入すると、デリゲートのインスタンスが暗黙的に生成される パフォーマンス的に問題ない場合は特に対応は不要ですが、インスタンス生成されていることは意識しておいた方がいいです。 また、コンパイラによって最適化されるケースもあるらしいので、ufcppさんの記事を参考に確認してみました。 [雑記] 匿名関数のコンパイル結果 https://ufcpp.net/study/csharp/sp2_anonymousmethod.html [雑記] デリゲートの内部 https://ufcpp.net/study/csharp/functional/miscdelegateinternal/ 環境は以下。 .NET Core 3.0 / C# 8.0 ILSpy（逆コンパイルツール） https://github.com/icsharpcode/ILSpy ILSpy起動後、ツールバーの言語バージョン選択で「C# 1.0 / VS.NET」を指定 クロージャに対して最適化が行われるケース1 ローカル関数のクロージャで且つデリゲートに代入せずに直接呼び出している場合、構造体を使用した最適化が行われるそうなので試してみました。 ソースコード using System; class Program { static void Main(string[] args) { var sample = new Sample(); sample.Test(10, あいうえ); } } class Sample { public void Test(int n, string str) { Update(); Console.WriteLine(n \u002B str); void Update() { n\u002B\u002B; str \u002B= お; } } } 逆コンパイル internal class Sample { [StructLayout(LayoutKind.Auto)] [CompilerGenerated] private struct c__DisplayClass0_0 { public int n; public string str; } public void Test(int n, string str) { c__DisplayClass0_0 c__DisplayClass0_ = default(c__DisplayClass0_0); c__DisplayClass0_.n = n; c__DisplayClass0_.str = str; Testg__Update|0_0(ref c__DisplayClass0_); Console.WriteLine(c__DisplayClass0_.n.ToString() \u002B c__DisplayClass0_.str); } [CompilerGenerated] private static void Testg__Update|0_0(ref c__DisplayClass0_0 P_0) { P_0.n\u002B\u002B; P_0.str \u002B= お; } } キャプチャした変数は構造体に格納され、その構造体はref渡しされるように最適化されていました。 クロージャに対して最適化が行われるケース2 同じスコープ内に複数の匿名関数がある場合、それらは同じクラスにまとめられるそうなので試してみました。 ソースコード using System; class Program { static void Main(string[] args) { var sample = new Sample(); sample.Test(); } } class Sample { public void Test() { var num = 0; Invoke(() = num \u002B= 10); Invoke(() = num \u002B= 100); } private void Invoke(Action action) { action(); } } 逆コンパイル internal class Sample { [CompilerGenerated] private sealed class c__DisplayClass0_0 { public int num; internal void Testb__0() { num \u002B= 10; } internal void Testb__1() { num \u002B= 100; } } public void Test() { int num = 0; c__DisplayClass0_0 @object; Invoke(new Action(@object.Testb__0)); Invoke(new Action(@object.Testb__1)); } private void Invoke(Action action) { action(); } } 複数の匿名関数が、同じクラスにまとめられていました。 デリゲートに対して最適化が行われるケース1 匿名関数が静的メソッドに展開可能な場合、シングルトンとして展開されるそうなので試してみました。 ソースコード using System; class Program { static void Main(string[] args) { var func1 = Sample.GetFunc(); var func2 = Sample.GetFunc(); Console.WriteLine(ReferenceEquals: \u002B ReferenceEquals(func1, func2)); } } class Sample { public static Funcint, int GetFunc() { return n = n * n; // (1) //return n = Squared(n); // (2) //return Squared; // (3) } private static int Squared(int n) { return n * n; } } 実行結果 (1)の場合 ReferenceEquals: True (2)の場合 ReferenceEquals: True (3)の場合 ReferenceEquals: False (1)と(2)は常に同じインスタンスを返していました。 逆コンパイル internal class Sample { [Serializable] [CompilerGenerated] private sealed class c { public static readonly c 9 = new c(); public static Funcint, int 9__0_0; internal int GetFuncb__0_0(int n) { return n * n; } } public static Funcint, int GetFunc() { return c.9__0_0 ?? (c.9__0_0 = new Funcint, int(c.9.GetFuncb__0_0)); } private static int Squared(int n) { return n * n; } } ufcppさんの記事によると、静的メソッドのデリゲートは効率が悪いそうで、最適化としてシングルトンとして展開され、更にデリゲート変数は静的フィールドで保持されていました。 但し、(3)のように静的メソッドを直接デリゲート変数に代入した場合、最適化は行われませんでした（なので、(2)のように匿名関数をはさんだ方が効率がいい）。 デリゲートに対して最適化が行われるケース2 いろいろ試していて気付いたケースです。 ループ中の匿名関数に対するデリゲートですが、その匿名関数がループ外のローカル変数をキャプチャしている場合、デリゲート変数を保持する最適化が行われていました （その匿名関数についてはインスタンスフィールドやインスタンスメソッドを使用している/いないは関係ない）。 ソースコード using System; using System.Collections.Generic; class Program { static void Main(string[] args) { var sample = new Sample(); sample.Test(); Console.WriteLine(ReferenceEquals: \u002B ReferenceEquals(sample.List1[0], sample.List1[1])); Console.WriteLine(ReferenceEquals: \u002B ReferenceEquals(sample.List2[0], sample.List2[1])); } } class Sample { public readonly ListAction List1 = new ListAction(); public readonly ListAction List2 = new ListAction(); public void Test() { var num = 0; for (var i = 0; i 2; i\u002B\u002B) { List1.Add(() = num \u002B= 10); List2.Add(() = num \u002B= 100); } } } 実行結果 ReferenceEquals: True ReferenceEquals: True 逆コンパイル internal class Sample { [CompilerGenerated] private sealed class c__DisplayClass2_0 { public int num; public Action 9__0; public Action 9__1; internal void Testb__0() { num \u002B= 10; } internal void Testb__1() { num \u002B= 100; } } public readonly ListAction List1 = new ListAction(); public readonly ListAction List2 = new ListAction(); public void Test() { int num = 0; for (int i = 0; i 2; i\u002B\u002B) { c__DisplayClass2_0 c__DisplayClass2_; Action action; List1.Add(c__DisplayClass2_.9__0 ?? (action = new Action(c__DisplayClass2_.Testb__0))); Action action2; List2.Add(c__DisplayClass2_.9__1 ?? (action2 = new Action(c__DisplayClass2_.Testb__1))); } } } ループ中でデリゲート変数を使い回すように最適化されていました。 但し、「ループ外のローカル変数のキャプチャ」という条件を満たさない場合、この最適化は行われませんでした。 その他、対策 自分が確認した限りでは、今回最適化が行われたケース以外については、自動的に最適化されることはありませんでした（将来的には分かりませんが）。 もし最適化に頼らず実装を明示的にしたい場合や、パフォーマンス的に問題になる場合、 不要なローカル変数のキャプチャは避ける デリゲート変数を保持して使い回す 等の対策をした方がいいです。 また .NET のクラスライブラリには、不要なローカル変数のキャプチャを回避する為のシグネチャが用意されているものがあります。 例えばConcurrentDictionary\u003CTKey, TValue\u003E.GetOrAddメソッドですが、以下のシグネチャがありますが、 1. TValue GetOrAdd(TKey key, TValue value) 2. TValue GetOrAdd(TKey key, FuncTKey, TValue valueFactory) 3. TValue GetOrAddTArg(TKey key, FuncTKey, TArg, TValue valueFactory, TArg factoryArgument) 値生成用のvalueFactoryに渡したいパラメータ（ローカル変数 or インスタンス変数）がある場合、 2ではなく3を使用することでfactoryArgumentでパラメータを渡す valueFactory自体は静的メソッドに展開可能な匿名関数にしておく とすることで、不要なローカル変数のキャプチャを回避でき、また最適化によってデリゲート変数も静的フィールドで保持されるので、 GetOrAdd呼び出し時に発生するクロージャやデリゲートのインスタンス生成を無くすことができます。 おわりに GCがある言語ではヒープの使用状況、確保/解放の負荷、断片化などについてあまり意識しなくなってきましたが、処理によってはパフォーマンスに影響がでる場合もあるので注意が必要です。"},{"url":"/articles/e115432cfb1e4d7298e45c1d5f7e94d5/","date":"2019-10-06","title":"[C#] IDisposableをインターフェイスのデフォルト実装で処理してみた","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"はじめに C# 8.0 でインターフェイスのデフォルト実装が可能になりました。 真っ先に思いついたのが IDisposable の実装で、うまくいったので記載します。 ソースコード using System; using System.Collections.Concurrent; using System.IO; using System.Linq; using System.Reflection; using System.Threading; #nullable enable class Program { static void Main() { using var sample = new SampleClass(); } } /// summary /// サンプルクラス。 /// /summary class SampleClass : IFieldAutoDisposable { public DisposeContext DisposeContext { get; } = new DisposeContext(); [DisposableField] private readonly MemoryStream _stream1 = new MemoryStream(); [field: DisposableField] public MemoryStream Stream2 { get; } = new MemoryStream(); } /// summary /// フィールドを自動破棄するデフォルト実装を持つインターフェイス。 /// /summary public interface IFieldAutoDisposable : IDisposable { /// summary破棄対象のメタデータのキャッシュ。/summary private static readonly ConcurrentDictionaryType, LazyTargetInfo[] _targetInfosTable = new ConcurrentDictionaryType, LazyTargetInfo[](); /// summary破棄コンテキスト。/summary DisposeContext DisposeContext { get; } /// summary /// 破棄処理。 /// /summary void IDisposable.Dispose() { if (Interlocked.CompareExchange(ref DisposeContext._disposedObject, this, null) == null) { DisposeFields(this); } } /// summary /// フィールドの自動破棄処理。 /// /summary private static void DisposeFields(object obj) { foreach (var targetInfo in GetTargetInfos(obj.GetType())) { var targetObj = targetInfo.FieldInfo.GetValue(obj); if (targetObj is IDisposable disposableObj) { disposableObj.Dispose(); } } // 破棄対象のメタデータの取得、キャッシュ static TargetInfo[] GetTargetInfos(Type type) { return _targetInfosTable.GetOrAdd(type, key = new LazyTargetInfo[](() = CreateTargetInfos(key))).Value; static TargetInfo[] CreateTargetInfos(Type type) { return type .GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly) .Select(fi = (fi, attr: fi.GetCustomAttributeDisposableFieldAttribute())) .Where(tuple = tuple.attr != null) .Select(tuple = new TargetInfo(tuple.fi, tuple.attr!)) .ToArray(); } } } /// summary /// 破棄対象のメタデータ。 /// /summary private sealed class TargetInfo { public FieldInfo FieldInfo { get; } public DisposableFieldAttribute FieldAttr { get; } public TargetInfo(FieldInfo fieldInfo, DisposableFieldAttribute fieldAttr) { FieldInfo = fieldInfo; FieldAttr = fieldAttr; } } } /// summary /// 破棄コンテキスト。 /// /summary public sealed class DisposeContext { internal volatile object? _disposedObject; public bool IsDisposed = _disposedObject != null; } /// summary /// 自動破棄するフィールドに指定する属性。 /// /summary [AttributeUsage(AttributeTargets.Field)] public sealed class DisposableFieldAttribute : Attribute { } おわりに 今回は対象の継承階層は考慮してませんが、本来は必要です。 あと、DisposableFieldAttribute に破棄する順序やグループも指定できるようにすると、より実用的だと思います。"},{"url":"/articles/36eaaa325d5749ac95afdaba275e1916/","date":"2019-10-03","title":"[C#] 不変クラスを不変構造体に変更した際に修正が必要になった箇所","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"はじめに intのフィールドを2つだけ持つ不変クラスを不変構造体に変更した際に少しハマったという話です。 前提 C# 8.0 で参照型をnull非許容とし、一通り警告はつぶしてある 不変クラスではEqualsとGetHashCodeのオーバーライド、IEquatable\u003CT\u003Eの実装、==と!=演算子のオーバーロードは実装済み object.ReferenceEqualsは使用していない 構造体にした際にボックス化が発生するような箇所はない default!で初期化している箇所（null非許容であっても初期値がnullになるような箇所）は把握済み 修正が必要だった箇所 不変構造体に変更後にバグが出ていて調査した結果、LINQのLastOrDefaultを使用している箇所でnullチェックしているのが原因でした。 メソッドの戻り値やout引数で「参照型でnull非許容」であってもデータが無い場合はnullになるのでnullチェック必須といった箇所があり、当然値型はnullではないので不具合が起きていました。 おわりに 今回は以下の拡張メソッドを自作して対応しました。 public static TElem? LastOrNullTElem(this IEnumerableTElem source) where TElem : class { return source.LastOrDefault(); } public static TElem? LastOrNullValueTElem(this IEnumerableTElem source) where TElem : struct { if (source is IListTElem list) { return (list.Count 0) ? list[list.Count - 1] : (TElem?)null; } TElem? result = null; foreach (var elem in source) { result = elem; } return result; } null非許容だとしても参照型と値型はそもそも異なるので注意が必要です。"},{"url":"/articles/def677425dd6446f85a152c9b5958b33/","date":"2019-10-01","title":"[C#] Awaitableパターンを試してみた","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"はじめに async/awaitで非同期的に呼び出す処理は自作可能なので、試してみました。 ソースコード .NET Core 3.0 で Windowsフォームアプリケーションを作成し、Control.BeginInvoke 経由でメソッドを呼び出す処理をawaitできるようにしてみます。 #nullable enable public partial class Form1 : Form { public Form1() { InitializeComponent(); } protected override void OnCreateControl() { base.OnCreateControl(); Debug.WriteLine(#OnCreateControl: start.); Test(); Debug.WriteLine(#OnCreateControl: end.); // SumAndToString メソッドを Control.BeginInvoke 経由で呼び出す実験 async void Test() { var result = await new Awaitablestring( (FuncIEnumerableint, string)SumAndToString, Enumerable.Range(1, 100)); Debug.WriteLine(#結果表示: \u002B result); } } private string SumAndToString(IEnumerableint nums) { return 合計 = \u002B nums.Sum(); } } public sealed class AwaitableTResult { private readonly AwaiterTResult _awaiter; public Awaitable(Delegate func, params object[] args) { _awaiter = new AwaiterTResult(func, args); } public AwaiterTResult GetAwaiter() { return _awaiter; } } public sealed class AwaiterTResult : INotifyCompletion { private readonly Delegate _func; private readonly object[] _args; private TResult _result = default!; public bool IsCompleted { get; private set; } public Awaiter(Delegate func, params object[] args) { _func = func; _args = args; } public void OnCompleted(Action continuation) { Application.OpenForms[0].BeginInvoke((Action)(() = { _result = (TResult)_func.DynamicInvoke(_args)!; IsCompleted = true; continuation.Invoke(); })); } public TResult GetResult() { // 例外が発生していた場合、その例外を保持しておいてここで throw すること return _result; } } 実行結果 意図した順序で呼び出されていることが確認できました。 #OnCreateControl: start. #OnCreateControl: end. #結果表示: 合計 = 5050 おわりに 後付けですが、以下がAwaitableパターンの必須条件なので、自前でインターフェイスを用意しておくと便利です。 public interface IAwaitableTResult { IAwaiterTResult GetAwaiter(); } public interface IAwaiterTResult : INotifyCompletion { bool IsCompleted { get; } TResult GetResult(); }"},{"url":"/articles/494cd9ee1be2439c805277f5db5c9227/","date":"2019-07-13","title":"[TS] OpenCV.jsで画像処理を試してみた","category":{"order":0,"name":"Demo","url":"/categories/demo/"},"tags":[{"name":"2D","url":"/tags/2d/"},{"name":"OpenCV","url":"/tags/opencv/"},{"name":"TypeScript","url":"/tags/typescript/"}],"content":"デモ \u003Cscript defer src=\u0022/files/cvdemo-ts/opencv-4.0.1.js\u0022\u003E\u003C/script\u003E \u003Cscript defer src=\u0022/files/cvdemo-ts/cvdemo.js?v=9b6b4392aa42418fbdeae5f6607ff23c\u0022\u003E\u003C/script\u003E \u003Cdiv id=\u0022demo-loading-progress\u0022\u003ELoading...\u003C/div\u003E \u003Cdiv id=\u0022demo-root\u0022 style=\u0022display: none;\u0022\u003E \u003Cdiv\u003E \u003C!-- 処理前の画像 --\u003E \u003Cspan id=\u0022img-src-wrapper\u0022 style=\u0022margin: 1px;\u0022\u003E \u003C/span\u003E \u003C!-- 処理後の表示 --\u003E \u003Cspan style=\u0022margin: 1px;\u0022\u003E \u003Ccanvas id=\u0022canvas-dst\u0022 width=\u00221\u0022 height=\u00221\u0022\u003E\u003C/canvas\u003E \u003C/span\u003E \u003C/div\u003E \u003Cdiv style=\u0022font-size: 75%;\u0022\u003E \u003Cdiv style=\u0022display: inline-grid; grid-template-columns: auto 5px auto;\u0022\u003E \u003C!-- ガンマ --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-gamma\u0022 type=\u0022checkbox\u0022 checked /\u003E \u003Clabel for=\u0022check-gamma\u0022\u003Eガンマ\u003C/label\u003E \u003C/div\u003E \u003Cdiv\u003E\u003C/div\u003E \u003Cdiv\u003E \u003Cinput id=\u0022range-gamma\u0022 type=\u0022range\u0022 style=\u0022width: 125px;\u0022 min=\u00220.5\u0022 max=\u00225.0\u0022 step=\u00220.1\u0022 value=\u00222.0\u0022 /\u003E \u003Cspan id=\u0022span-gamma\u0022\u003E\u003C/span\u003E \u003C/div\u003E \u003C!-- コントラスト --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-contrast\u0022 type=\u0022checkbox\u0022 checked /\u003E \u003Clabel for=\u0022check-contrast\u0022\u003Eコントラスト\u003C/label\u003E \u003C/div\u003E \u003Cdiv\u003E\u003C/div\u003E \u003Cdiv\u003E \u003Cinput id=\u0022range-contrast\u0022 type=\u0022range\u0022 style=\u0022width: 125px;\u0022 min=\u00221.0\u0022 max=\u002215.0\u0022 step=\u00220.1\u0022 value=\u00228.0\u0022 /\u003E \u003Cspan id=\u0022span-contrast\u0022\u003E\u003C/span\u003E \u003C/div\u003E \u003C!-- シャープネス --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-sharpness\u0022 type=\u0022checkbox\u0022 checked /\u003E \u003Clabel for=\u0022check-sharpness\u0022\u003Eシャープネス\u003C/label\u003E \u003C/div\u003E \u003Cdiv\u003E\u003C/div\u003E \u003Cdiv\u003E \u003Cinput id=\u0022range-sharpness\u0022 type=\u0022range\u0022 style=\u0022width: 125px;\u0022 min=\u00220.1\u0022 max=\u002210.0\u0022 step=\u00220.1\u0022 value=\u00223.0\u0022 /\u003E \u003Cspan id=\u0022span-sharpness\u0022\u003E\u003C/span\u003E \u003C/div\u003E \u003C!-- モザイク --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-mosaic\u0022 type=\u0022checkbox\u0022 /\u003E \u003Clabel for=\u0022check-mosaic\u0022\u003Eモザイク\u003C/label\u003E \u003C/div\u003E \u003Cdiv\u003E\u003C/div\u003E \u003Cdiv\u003E \u003Cinput id=\u0022range-mosaic\u0022 type=\u0022range\u0022 style=\u0022width: 125px;\u0022 min=\u00222\u0022 max=\u002230\u0022 step=\u00221\u0022 value=\u00225.0\u0022 /\u003E \u003Cspan id=\u0022span-mosaic\u0022\u003E\u003C/span\u003E \u003C/div\u003E \u003C/div\u003E \u003C!-- ディザリング --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-dithering\u0022 type=\u0022checkbox\u0022 /\u003E \u003Clabel for=\u0022check-dithering\u0022\u003Eディザリング（8色に減色）\u003C/label\u003E \u003C/div\u003E \u003C!-- グレイスケール --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-grayscale\u0022 type=\u0022checkbox\u0022 /\u003E \u003Clabel for=\u0022check-grayscale\u0022\u003Eグレイスケール\u003C/label\u003E \u003C/div\u003E \u003Cdiv id=\u0022require-grayscaled\u0022 style=\u0022margin-left: 1.5em;\u0022\u003E \u003C!-- 大津の二値化 --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-binary\u0022 type=\u0022checkbox\u0022 /\u003E \u003Clabel for=\u0022check-binary\u0022\u003E大津の二値化\u003C/label\u003E \u003C/div\u003E \u003C!-- 重心表示 --\u003E \u003Cdiv\u003E \u003Cinput id=\u0022check-center\u0022 type=\u0022checkbox\u0022 /\u003E \u003Clabel for=\u0022check-center\u0022\u003E重心表示\u003C/label\u003E \u003C/div\u003E \u003C/div\u003E \u003C/div\u003E \u003C/div\u003E はじめに もともと OpenCvSharp で遊んでいたんですが、OpenCV.js なるものが存在することを知ったので試してみました。 OpenCV.jsですが、npm管理されているわけではなく、またts定義ファイルがないのがかなりつらいです。 OpenCV.js https://opencv.org/ https://docs.opencv.org/4.0.1/d5/d10/tutorial_js_root.html OpenCvSharp https://www.nuget.org/profiles/schimatk ソースコード HTML script defer src=/files/cvdemo-ts/opencv-4.0.1.js/script script defer src=/files/cvdemo-ts/cvdemo.js?v=9b6b4392aa42418fbdeae5f6607ff23c/script div id=demo-loading-progressLoading.../div div id=demo-root style=display: none; div !-- 処理前の画像 -- span id=img-src-wrapper style=margin: 1px; /span !-- 処理後の表示 -- span style=margin: 1px; canvas id=canvas-dst width=1 height=1/canvas /span /div div style=font-size: 75%; div style=display: inline-grid; grid-template-columns: auto 5px auto; !-- ガンマ -- div input id=check-gamma type=checkbox checked / label for=check-gammaガンマ/label /div div/div div input id=range-gamma type=range style=width: 125px; min=0.5 max=5.0 step=0.1 value=2.0 / span id=span-gamma/span /div !-- コントラスト -- div input id=check-contrast type=checkbox checked / label for=check-contrastコントラスト/label /div div/div div input id=range-contrast type=range style=width: 125px; min=1.0 max=15.0 step=0.1 value=8.0 / span id=span-contrast/span /div !-- シャープネス -- div input id=check-sharpness type=checkbox checked / label for=check-sharpnessシャープネス/label /div div/div div input id=range-sharpness type=range style=width: 125px; min=0.1 max=10.0 step=0.1 value=3.0 / span id=span-sharpness/span /div !-- モザイク -- div input id=check-mosaic type=checkbox / label for=check-mosaicモザイク/label /div div/div div input id=range-mosaic type=range style=width: 125px; min=2 max=30 step=1 value=5.0 / span id=span-mosaic/span /div /div !-- ディザリング -- div input id=check-dithering type=checkbox / label for=check-ditheringディザリング（8色に減色）/label /div !-- グレイスケール -- div input id=check-grayscale type=checkbox / label for=check-grayscaleグレイスケール/label /div div id=require-grayscaled style=margin-left: 1.5em; !-- 大津の二値化 -- div input id=check-binary type=checkbox / label for=check-binary大津の二値化/label /div !-- 重心表示 -- div input id=check-center type=checkbox / label for=check-center重心表示/label /div /div /div /div TypeScript declare var cv: any; class CvDemoApp { private _imgSrc: HTMLImageElement | null = null; private readonly _canvasDst = document.querySelectorHTMLCanvasElement(#canvas-dst)!; private readonly _checkGamma = document.querySelectorHTMLInputElement(#check-gamma)!; private readonly _rangeGamma = document.querySelectorHTMLInputElement(#range-gamma)!; private readonly _spanGamma = document.querySelectorHTMLSpanElement(#span-gamma)!; private readonly _checkContrast = document.querySelectorHTMLInputElement(#check-contrast)!; private readonly _rangeContrast = document.querySelectorHTMLInputElement(#range-contrast)!; private readonly _spanContrast = document.querySelectorHTMLSpanElement(#span-contrast)!; private readonly _checkSharpness = document.querySelectorHTMLInputElement(#check-sharpness)!; private readonly _rangeSharpness = document.querySelectorHTMLInputElement(#range-sharpness)!; private readonly _spanSharpness = document.querySelectorHTMLSpanElement(#span-sharpness)!; private readonly _checkMosaic = document.querySelectorHTMLInputElement(#check-mosaic)!; private readonly _rangeMosaic = document.querySelectorHTMLInputElement(#range-mosaic)!; private readonly _spanMosaic = document.querySelectorHTMLSpanElement(#span-mosaic)!; private readonly _checkDithering = document.querySelectorHTMLInputElement(#check-dithering)!; private readonly _checkGrayscale = document.querySelectorHTMLInputElement(#check-grayscale)!; private readonly _checkBinary = document.querySelectorHTMLInputElement(#check-binary)!; private readonly _checkCenter = document.querySelectorHTMLInputElement(#check-center)!; public start(): void { document.querySelectorHTMLElement(#demo-loading-progress)!.style.display = none; document.querySelectorHTMLElement(#demo-root)!.style.display = inline; const targets = document.querySelectorAllHTMLInputElement(#demo-root input); for (const target of targets) { target.addEventListener(change, () = { if (this._imgSrc?.complete) { this.refreshGui(); this.processCv(); } }); } this._imgSrc = document.createElement(img); this._imgSrc.onload = () = { this.refreshGui(); this.processCv(); }; this._imgSrc.src = /files/cvdemo-ts/test.jpg?v=9b6b4392aa42418fbdeae5f6607ff23c; document.querySelector(#img-src-wrapper)!.appendChild(this._imgSrc); } private refreshGui(): void { this._rangeGamma.disabled = !this._checkGamma.checked; this._spanGamma.textContent = this._rangeGamma.value; this._rangeContrast.disabled = !this._checkContrast.checked; this._spanContrast.textContent = this._rangeContrast.value; this._rangeSharpness.disabled = !this._checkSharpness.checked; this._spanSharpness.textContent = this._rangeSharpness.value; this._rangeMosaic.disabled = !this._checkMosaic.checked; this._spanMosaic.textContent = this._rangeMosaic.value; const targets = document.querySelectorAllHTMLInputElement(#require-grayscaled input); for (const target of targets) { target.disabled = !this._checkGrayscale.checked; } } private processCv(): void { const imageProc = new ImageProc(cv.imread(this._imgSrc!)); try { if (this._checkGamma.checked) { imageProc.gamma(this._rangeGamma.valueAsNumber); } if (this._checkContrast.checked) { imageProc.contrast(this._rangeContrast.valueAsNumber); } if (this._checkSharpness.checked) { imageProc.sharpness(this._rangeSharpness.valueAsNumber); } if (this._checkMosaic.checked) { imageProc.mosaic(this._rangeMosaic.valueAsNumber); } if (this._checkDithering.checked) { imageProc.dithering(); } if (this._checkGrayscale.checked) { imageProc.colorToGray(); if (this._checkBinary.checked) { imageProc.binary(); } if (this._checkCenter.checked) { imageProc.drawCenterOfMoments(); } } cv.imshow(this._canvasDst, imageProc.mat); } finally { imageProc.dispose(); } } } /** * 画像処理クラス */ class ImageProc { private _disposed = false; public get mat(): any { return this._mat; } public constructor(private _mat: any) { } public dispose(): void { if (!this._disposed) { this._mat.delete(); this._disposed = true; } } // ガンマ補正 public gamma(value: number): void { const GV = 1.0 / value; const lut = ImageProc.createLut(i = { return Math.pow(i / 255.0, GV) * 255.0; }); this.applyFunc((row, col, value) = lut[value]); } // コントラスト調整 public contrast(value: number): void { const lut = ImageProc.createLut(i = { return 255.0 / (1 \u002B Math.exp(-value * (i - 128) / 255.0)); }); this.applyFunc((row, col, value) = lut[value]); } // シャープネス public sharpness(value: number): void { this.exchange(dst = { value = value / 9.0; const kernelData = [ -value, -value, -value, -value, 1 \u002B (8 * value), -value, -value, -value, -value, ]; const kernel = cv.matFromArray(3, 3, cv.CV_64F, kernelData); cv.filter2D(this._mat, dst, -1, kernel); }); } // モザイク public mosaic(value: number): void { const ROWS = this._mat.rows; const COLS = this._mat.cols; this.exchange(dst = { const dstSize = new cv.Size(0, 0); const ratio = 1.0 / value; cv.resize(this._mat, dst, dstSize, ratio, ratio, cv.INTER_NEAREST); }); this.exchange(dst = { const dstSize = new cv.Size(COLS, ROWS); cv.resize(this._mat, dst, dstSize, 0, 0, cv.INTER_NEAREST); }); } // カラー to グレー public colorToGray(): void { this.exchange(dst = { cv.cvtColor(this._mat, dst, cv.COLOR_RGBA2GRAY, 0); }); } // グレー to カラー public grayToColor(): void { this.exchange(dst = { cv.cvtColor(this._mat, dst, cv.COLOR_GRAY2RGBA, 0); }); } // 大津の二値化 public binary(): void { this.exchange(dst = { cv.threshold(this._mat, dst, 0.0, 255.0, cv.THRESH_BINARY | cv.THRESH_OTSU); }); } // ディザリング public dithering(): void { const matrix = [[0, 8, 2, 10], [12, 4, 14, 6], [3, 11, 1, 9], [15, 7, 13, 5]]; for (let i = 0; i 4; i\u002B\u002B) { for (let j = 0; j 4; j\u002B\u002B) { matrix[i][j] *= 16; } } this.applyFunc((row, col, value) = { return (value matrix[row % 4][col % 4]) ? 0 : 255; }); } // 重心描画 public drawCenterOfMoments(): void { const center = this.getCenterOfMoments(); this.grayToColor(); this.fillCircle(center, 7, new cv.Scalar(255, 0, 0, 255)); } // 塗りつぶし円を描画 public fillCircle(point: any, radius: number, scalar: any): void { cv.circle(this._mat, point, radius, scalar, -1, cv.LINE_AA); } // 重心取得 public getCenterOfMoments(): any { const moments = cv.moments(this._mat); return new cv.Point(moments.m10 / moments.m00, moments.m01 / moments.m00); } // 画像処理時の共通処理 private exchange(callback: (dst: any) = void): void { const dst = new cv.Mat(); callback(dst); this._mat.delete(); this._mat = dst; } // 各RGBに対する処理 public applyFunc(callback: (row: number, col: number, value: number) = number): void { if (!this._mat.isContinuous()) { throw mat is not continuous.; } const ROWS = this._mat.rows; const COLS = this._mat.cols; const CHANNELS = this._mat.channels(); const TARGET_CHANNELS = Math.min(CHANNELS, 3); let index = 0; let beforeIndex = 0; const data = this._mat.data; for (let row = 0; row ROWS; row\u002B\u002B) { beforeIndex = row * COLS * CHANNELS; for (let col = 0; col COLS; col\u002B\u002B) { index = beforeIndex \u002B (col * CHANNELS); for (let ch = 0; ch TARGET_CHANNELS; ch\u002B\u002B) { data[index \u002B ch] = callback(row, col, data[index \u002B ch]); } } } } // ルックアップテーブル生成 public static createLut(callback: (i: number) = number): number[] { const LENGTH = 256; const lut = new Arraynumber(LENGTH); for (let i = 0; i LENGTH; i\u002B\u002B) { lut[i] = Math.floor(callback(i)); } return lut; } } const demoApp = new CvDemoApp(); demoApp.start();"},{"url":"/articles/5b247fcd204244cbba2e046bb2f09381/","date":"2019-04-04","title":"[TS] TypeScriptざっくりメモ","category":{"order":1,"name":"Tech","url":"/categories/tech/"},"tags":[{"name":"TypeScript","url":"/tags/typescript/"}],"content":"はじめに TypeScriptの言語仕様の自分用ざっくりメモです。 TypeScriptを使う際、とりあえず知っておけばいいことを適当に記載 ECMAScript 2015（ES 6）の話も混ざってる 現時点のTypeScriptのバージョンは3.4 言語仕様やコンパイラオプションの詳細は公式サイトで https://www.typescriptlang.org/ 型定義の検索は以下で https://microsoft.github.io/TypeSearch/ 型 boolean number string null, undefined オブジェクト型 any型 他にもあるけど省略 変数 ブロックスコープ let グローバルスコープ var let hoge: string = abc; let fuga = xyz; // 初期化する場合、型指定は省略可能 let piyo; // この場合、any型となる 定数 ブロックスコープ const const length = 100; 数値リテラル let decimal = 6; // 10進数リテラル let hex = 0xFF; // 16進数リテラル let octal = 0o66; // 8進数 let binary = 0b1011; // 2進数 let exp1 = 7.2E5 // 指数 let exp2 = 3.4E-3 // 指数 テンプレート文字列 let hoge = \u0060私の名前は ${name} です。\u0060; let fuga = \u0060ここは 改行となる。\u0060; 演算子、条件分岐、ループ JavaScriptと同じ。 分割代入 let hoge, fuga: number; [hoge, fuga] = [100, 200]; console.log(hoge); console.log(fuga); const [foo, bar] = [FOO, BAR]; console.log(foo); console.log(bar); any型 なんでも代入できる型。用途としては、型定義が提供されていない場合に使用する等。 declare 外部のJavaScriptで定義されたグローバル変数を使用する。 declare var hoge: any; 配列 let array1: string[] = [abc, xyz]; let array2: string[] = []; // 空の配列で初期化 let array3 = [abc, xyz]; let array4 = [abc, 123]; // この場合は (string | number)[] 型になる // 多次元配列 let data: number[][] = [[10, 20], [30, 40], [50, 60]]; タプル // 型指定は必須（省略すると配列になってしまう） let tuple: [string, number, boolean] = [hoge, 123, true]; 列挙型 enum Color { Red, // 0 Green, // 1 Blue, // 2 } enum Color { Red = 1, // 1 Green, // 2 Blue, // 3 } let currentColor = Color.Red; let name: string = Color[currentColor]; // 文字列として取得する場合 // 文字列も可 enum Direction { Up = Up, Down = Down, Left = Left, Right = Right, } 共用体型 let userId: number | string = 007; // 数値と文字列の両方OKな型 userId = 007; 交差型 省略。 型エイリアス type HogeType = number | string; type FugaType = [string, number, boolean]; 型アサーション キャストのこと。記述方法が2種類ある。 let anyText: any = hoge; let text1 = stringanyText; // 方法1 let text2 = anyText as string; // 方法2 Set let mySet = new Setstring([hoge, fuga]); mySet.add(piyo); for (const item of mySet) { console.log(item); } Map let myMap = new Mapstring, number(); myMap.set(hoge, 100); myMap.set(fuga, 200); for (const [key, value] of myMap) { console.log(key); console.log(value); } リテラル型 let direction: up | down | left | right; direction = up; // OK direction = abc; // Error type Direction = up | down | left | right | 0 | 1 | 2 | 3; let direction: Direction = up; direction = 3; null許容型 デフォルトでは変数はnull許容だが、コンパイラオプションでnull非許容に変更可能。 その場合、以下のようにするとnull許容型となる。 let hoge: string | null = null; let fuga: string | undefined = undefined; オブジェクト型リテラル 省略。 例外処理 JavaScriptと同じ。 関数 外部関数 JavaScriptと同じ。 関数の引数 通常の引数 デフォルト引数 function hoge(num: number = 0) オプション引数 省略した場合、undefined になる function hoge(num?: number) 可変長引数 function hoge(...nums: number[]) 関数のオーバーロード やりかたが特殊で、まずオーバーロードする関数の宣言のみを書き、実際に実装する関数は1つのみとする。 その実装する関数の引数は、宣言した関数とつじつまが合うようにする。 クラス /** * ドキュメンテーションコメント。 */ class Hoge { // フィールド /** 名前 */ private readonly _name: string; /** 年齢 */ private _age: number; // コンストラクタ public constructor(name: string, age: number) { this._name = name; this._age = age; } // アクセサ public get name(): string { return this._name; } public get age(): number { return this._age; } public set age(age: number) { this._age = age; } // メソッド public update(): void { } // 静的フィールド public static readonly __Foo = 999; private static __bar = 0; // 静的アクセサ public static get bar(): number { return Hoge.__bar; } public static set bar(bar: number) { Hoge.__bar = bar; } // 静的メソッド public static init(): void { } } class Hoge { // コンストラクタでインスタンスフィールドを定義する場合 public constructor( private readonly _name: string, private _age: number) { } } 自身のメソッドやフィールドにアクセスする際 インスタンスメソッド/インスタンスフィールドを使用する場合、this. は必須 staticメソッド/staticフィールドを使用する場合、クラス名. は必須 クラスの継承 // 基底クラス class Hoge { public constructor(name: string) { } protected update(): void { } } // 派生クラス class Fuga extends Hoge { public constructor() { // 基底クラスのコンストラクタ呼び出し super(fuga); } // 同シグネチャにすることでオーバーライドとなる protected update(): void { } } // 抽象基底クラス abstract class Hoge { protected abstract update(): void; } // 派生クラス class Fuga extends Hoge { protected update(): void { } } 戻り値の型としてのthis インスタンスメソッドの戻り値の型に this を指定する事が可能（メソッドチェーンにする場合等） クラス型を戻り値の型にしてもいいが、this だと派生クラスがある場合に戻り値の型が派生クラス型扱いになるので便利 ユーティリティークラス staticクラスはないので、コンストラクタをprivateにすること。 class Hoge { private constructor() { } } 名前空間 namespace Foo { class Hoge { } } namespace Foo.Bar { class Fuga { } } namespace Foo { // 別の名前空間からPiyoを参照できるようにする export class Piyo { } } ジェネリック 基本的な構文はC#と大体同じ。 制約 // T は Hoge を満たしていることを制約として指定する T extends Hoge アロー関数 ラムダ式のこと。アロー関数を使用するでthis問題を回避できる。 インターフェイス interface Hoge { name: string; age?: number; // ?指定の場合、実装は任意 init(): void; update?(): void; // ?指定の場合、実装は任意 } class Fuga implements Hoge { public name = fuga; public init(): void { } } TypeScriptのインターフェイスは、implementsしていなくても対象がそのインターフェイスのシグネチャを満たしていればいい 型が一致するかではなく、構造が一致するかどうかで互換性があるかを判断しているから（構造的部分型） 型ガード if文で instanceof 型名 や typeof value === \u0022型名\u0022 で判定したあとは、その型として使える機能。 let value: any = abc; if (typeof value === string) { // string型のtoUpperCase()メソッドが使用可能 let upperCase = value.toUpperCase(); } // 型ガードをメソッド化する場合 public static isString(value: any): value is string { return typeof value === string; } その他、参考 async/await、コルーチンは以下の記事で使用例あり。 https://crash.jp/pages/938a2b72c7174014b7ce6005cd4bda9e/ おわりに JavaScriptよさらば！"},{"url":"/articles/7258d4e6eb3c4e3e9f5ceaf5afa197b0/","date":"2019-03-26","title":"WinSCPのミラーリングアップロードをコマンドラインから実行する","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"WinSCP","url":"/tags/winscp/"},{"name":"開発全般","url":"/tags/general-dev/"}],"content":"概要 自サイトにファイルをアップするのに WinSCP のミラーリングアップロードを使用しているのですが、そのやり方について記載します。 ミラーリングアップロードとは ローカルディレクトリを監視し、変更があれば随時リモートにアップする機能 ミラーリングアップロードを開始すると監視中の状態となる ミラーリングアップロードを停止すると監視は解除される インストール WinSCP https://forest.watch.impress.co.jp/library/software/winscp/ 前準備 WinSCP を起動し、新しいセッションを作成してログイン情報を登録しておきます。 バッチファイル用意 ＜WinSCP.exeパス＞ ＜登録したセッション名＞ /keepuptodate ＜ローカルディレクトリパス＞ ＜リモートディレクトリパス＞ /defaults /keepuptodate ミラーリングアップロードを実行する /defaults 転送オプションについて、最後に実行した際の GUI の設定のままとする 実行 バッチファイルを実行すれば自動的にミラーリングアップロード用の GUI が起動します。 転送オプションは GUI から設定する必要があり、自環境では サブディレクトリも更新する 起動時に同期する をオンにしています。"},{"url":"/articles/5f0728ea41fe4692ac33d6289424e4e9/","date":"2019-01-14","title":"プログラマーの修行内容","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"開発全般","url":"/tags/general-dev/"}],"content":"はじめに プログラミング未経験者に対して開発会社がどういう研修を行うかは、とても重要です。 自分のときはどうだったか、思い出してみました。 テスター兼、修行 当時はWindowsバブルの頃で、Windows向け市販パッケージソフトを開発していました。 最初の1年はアルバイト扱いで、テスターをしながら研修（修行と呼ばれていた）を受けます。 テスター作業：4～6ヵ月 プログラマー修行：6～8ヵ月 修行中も時給はもらえますが、正社員プログラマーとして開発に参画できるのは見込みがある人だけでした。 プログラマー採用は見極めが難しいので、いい採用システムだったのではないかと思います。 修行内容 開発製品はWindowsアプリケーションだったので、その技術（C\u002B\u002B, Win32API, MFC）を習得する内容になっています。 PC基礎 ブラインドタッチ 練習ソフトで1セット15分を1日3セット OSに触れる MS-DOS Windows 3.1 Windows 95 言語 C言語 書籍（教本と問題集）を使用して言語、アルゴリズム、データ構造の基礎 atoi, strlen, strcpy, strcmp等と同じ物を自作 コンソールアプリ作成 dir/copy/typeコマンド等と同じ物を自作 簡易住所録アプリ C\u002B\u002B言語 書籍：CプログラマのためのC\u002B\u002B入門（柴田 望洋） Windowsプログラミング Win32API 書籍：プログラミングWindows MFC 書籍：MFCによるWindowsプログラミング アプリ作成 テキストビューア ドロー系お絵描きアプリ 簡易住所録アプリ 修行後 自主的に以下の書籍で学習。 現実的なC\u002B\u002Bプログラミング（Robert B. Murray） Effective C\u002B\u002B（Scott Meyers） おわりに 研修内容としてはかなり充実していたと思います。"},{"url":"/articles/dbada619baf24d05b33a216b0871ebe3/","date":"2019-01-07","title":"[C#] WPFでソフトウェア「Neko」的なものを作ってみた","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"2D","url":"/tags/2d/"},{"name":"C#","url":"/tags/cs/"},{"name":"WPF","url":"/tags/wpf/"}],"content":"概要 かなり前に作ったやつで、ソースコードをアップしました。 https://github.com/yoshiheight/Sample.WpfNeko 動作内容は、以下と同じです。 PixiJS＋TypeScriptでソフトウェア「Neko」的なものを作ってみた https://crash.jp/pages/938a2b72c7174014b7ce6005cd4bda9e/"},{"url":"/articles/938a2b72c7174014b7ce6005cd4bda9e/","date":"2019-01-06","title":"[TS] PixiJSでソフトウェア「Neko」的なものを作ってみた","category":{"order":0,"name":"Demo","url":"/categories/demo/"},"tags":[{"name":"2D","url":"/tags/2d/"},{"name":"PixiJS","url":"/tags/pixijs/"},{"name":"TypeScript","url":"/tags/typescript/"}],"content":"デモ \u003Cdiv id=\u0022my-demo-pixi-view\u0022\u003E\u003C/div\u003E マウスカーソルを追いかけます 「読み込み中...」の表示は、（すぐ読み込めた場合でも）わざと表示しています はじめに PixiJSを使うと2Dスプライト描画が簡単にできる（しかもWebGLで処理してくれる）ということで、試してみました。 PixiJS http://www.pixijs.com/ Neko https://ja.wikipedia.org/wiki/Neko_(%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2) 環境構築 とりあえずTypeScriptを試すために行ったこと。 環境 Visual Studio 2017 TypeScript 3.1 Node.jsのLTS版（推奨版）をインストール https://nodejs.org/ja/ 「ASP.NET Core Web アプリケーション」の空プロジェクトを作成 Startup.csのConfigureメソッド内を以下の2文のみにする app.UseDefaultFiles(); app.UseStaticFiles(); プロジェクトルートで以下のnpmコマンド実行 npm init --yes npm install @types/jquery --save-dev npm install @types/pixi.js --save-dev jsファイル本体はCDNを使う wwwrootディレクトリに以下を追加 index.html TypeScriptソースファイル （本当は別途ディレクトリを用意して、gulpとかwebpackとか使った方がいい） 既存のtsファイルを追加した場合、ファイルプロパティでビルドアクションを TypeScriptファイル に変更 プロジェクト設定でTypeScriptのビルド設定を変更 ECMAScriptバージョン：ECMAScript 6 暗黙的な any 型を許可：オフ Null非許容の設定にする場合、.csprojファイルに以下を追加 \u003CTypeScriptStrictNullChecks\u003ETrue\u003C/TypeScriptStrictNullChecks\u003E 参考 公式サイトは重いのでGitHubの方を見た方がいい https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/tutorials/ASP.NET%20Core.md https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/tsconfig.json.md https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/Compiler%20Options.md ソースコード Neko.ts \u003Cdiv id=\u0022my-neko-ts-code\u0022\u003E\u003C/div\u003E image-list.json \u003Cdiv id=\u0022my-image-list-json-code\u0022\u003E\u003C/div\u003E \u003Cscript src=\u0022/files/neko-ts/app/bootloader.js?v=39ecd7f7620d4a9f898c081e9d2429a4\u0022\u003E\u003C/script\u003E \u003Cscript\u003E $(async () =\u003E { await NekoDemo.BootLoader.loadAsync(); await NekoDemo.PixiView.startAsync(\u0022#my-demo-pixi-view\u0022); CrashPagesJS.Common.HljsUtil.createBlock(\u0022#my-neko-ts-code\u0022, \u0022ts\u0022, \u0060/files/neko-ts/source/Neko.ts?v=${NekoDemo.PixiView.Version}\u0060); CrashPagesJS.Common.HljsUtil.createBlock(\u0022#my-image-list-json-code\u0022, \u0022json\u0022, \u0060/files/neko-ts/app/images/neko/image-list.json?v=${NekoDemo.PixiView.Version}\u0060); }); \u003C/script\u003E"},{"url":"/articles/02f4ef48df76409889545a7eca17ac1e/","date":"2018-12-17","title":"[C#][TS] 静的サイトジェネレーター「Sitedig」の紹介","category":{"order":1,"name":"Tech","url":"/categories/tech/"},"tags":[{"name":"静的サイトジェネレーター","url":"/tags/static-site-generator/"},{"name":"C#","url":"/tags/cs/"},{"name":"TypeScript","url":"/tags/typescript/"}],"content":"この記事は「静的サイトジェネレーター Advent Calendar 2018」17日目の記事です。 はじめに 静的サイトジェネレーターを作ってみたので、その話と使い方の紹介です。 GitHubリポジトリ https://github.com/yoshiheight/Crash.Pages サイト生成処理にはC#を使用しています。サイト内でのWebフロントエンド処理には（現在開発中の次期版では）TypeScriptを使用しています。 自作した話 サイトの特徴 どういうサイトが生成されるか、ですが、このサイト自体が自作の静的サイトジェネレーターで生成しています。 以下、主な特徴です。 ページ構成 トップページ（記事一覧） タグページ 検索結果ページ 各記事ページ 検索機能 目次機能 レスポンシブデザイン 自作した理由 既存のサービスや静的サイトジェネレーターを使うことも考えたのですが、最終的には以下の理由で自作することにしました。 WordPress等のCMSではオーバースペックだし、構築や設定が面倒 既存のサービスだと外部のJavaScriptライブラリ等を組み込めない、組み込むのが面倒 既存のサービスだと他へ移行するときに面倒 広告を表示したくないし、有料プランにするぐらいならホスティングサービスを使う 表示速度を上げたい 独自ドメインを使用したい Qiitaの様な技術情報限定のサービスの場合、他の人と記事内容がかぶっていると、なんか上げにくい 自サイトの方が内容を気にせず、また自分用備忘録的なものも上げやすい シンプルな画面構成にしたい、デザインを好きなようにしたい 一覧表示はページングしないで全部表示したい Markdownの記事はGitで管理してVisual Studio Codeで編集したい HTML、CSS、JavaScriptは最近さわっていなかったので、ちょっとさわっておきたい C#製MarkdownライブラリのMarkDigを試してみたい ただ単に.NET Coreでなにか作りたかった 既存のものをいろいろカスタムするより、自作した方が早いと思った 自分にとって上記を全て満たす方法が「自作＋好きなホスティングサービスで公開」だったわけです。 フロントエンドで使用しているライブラリ、リソース https://jquery.com/ https://fonts.google.com/ 以下は現在開発中の次期Crash.Pagesの場合 https://lodash.com/ https://highlightjs.org/ https://mermaidjs.github.io/ 環境構築 配布用バイナリは用意していません。もともと自分用に作っていたというのもあり、ちょっと面倒なんですが、前述のGitHubリポジトリから取得してVisual Studioでビルドが必要です。 というか、テンプレートにT4Templateを使用しているので、サイトヘッダーやフッター、プロフィールの記述など、Visual Studioがないとできません。 プロジェクト構成 プロジェクト |内容 |形態 --------------------|-----------------------------|------------------------------- Crash.Core |共通ライブラリ |.NET Standardライブラリ Crash.Pages |静的サイトジェネレーター本体 |.NET Coreコンソールアプリ Crash.Pages.Model |処理モデル |.NET Coreライブラリ Crash.Pages.Storage |ファイルIO関連 |.NET Coreライブラリ SimpleWebServer |簡易Webサーバー |ASP.NET Core SimpleWebServerは独立したプロジェクトです。必要に応じて、ローカル環境でのサイト内容確認に使用してください ユーザー指定部分 文字列「ユーザー指定部分」で検索するとヒットする以下の箇所がユーザー固有の記述部分ですので、書き換えてください。 Page.cs サイト名 LayoutTemplate.tthtml サイトヘッダー プロフィール サイトフッター ビルド手順 「すべてのT4テンプレートの変換」を実行 Release版でソリューションのリビルドを実行 ディレクトリの用意 入力元ディレクトリを以下の構成で用意してください。 \u002B 入力元ディレクトリ（任意の名前） \u002B _drafts 下書き用 \u002B _posts 公開用 出力先ディレクトリのルートを用意してください。サブディレクトリはモードに応じて自動生成されます。 \u002B 出力先ディレクトリ（任意の名前） \u002B _preview プレビューモードでの生成先 \u002B _site 本番モードでの生成先 サイト生成 記事の作成 Markdownファイルを以下のファイル名で文字コードUTF-8で作成してください。BOMの有無や改行コードは何でも大丈夫です。 YYYY-MM-DD-記事タイトル.md ファイルの先頭にはYAMLで記事のメタデータを埋め込む必要があります。 --- id: my-page tags: [Markdown, 静的サイト] --- 記事IDはパーマリンクの一部として使用されます /pages/記事ID/ 記事内での見出しはh3からh5を使用してください 出力されるHTMLファイルの文字コードはUTF-8 BOM無し、改行コードはLFになります 出力されるHTMLファイルのタイムスタンプは、もとのMarkdownファイルと同じになります Markdown以外のファイルはそのまま出力先ディレクトリにコピーされます サイト生成の実行 以下のコマンドを実行します。 dotnet ＜Crash.Pages.dllパス＞ --src=＜入力元ディレクトリパス＞ --dest=＜出力先ディレクトリパス＞ --previewオプション プレビューモードで実行します。下書き記事もHTML変換され、また全記事の先頭にMarkdownファイルパスが表示されます サイト内容の確認 SimpleWebServerでサイト内容を確認する場合、以下のコマンドを実行します。 dotnet ＜SimpleWebServer.dllパス＞ ＜ポート番号＞ ＜生成先ディレクトリパス＞ おわりに 実際に作ってみて、自分の欲しかったものができ、更に HTML5, CSS3, ECMAScript 2015 もいろいろ試すことができました。 既存のものが気に入らなければ、自分で作ってしまうのも、たまにはいいのではないでしょうか。"},{"url":"/articles/6c5c4b03b6ff4518ae7960a6fd2e4fc9/","date":"2018-12-09","title":"GoFデザインパターン","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"GoF","url":"/tags/gof/"},{"name":"デザインパターン","url":"/tags/design-pattern/"},{"name":"開発全般","url":"/tags/general-dev/"}],"content":"GoFの23のデザインパターンのチートシートです。 生成、構造、振る舞いの順に記載 記載している例は、一例にすぎない デザインパターンが絶対というわけではない \u003Cdiv style=\u0022background-color: lightblue;\u0022\u003E工事中の記事\u003C/div\u003E （Abstract Factory） （Builder） （Factory Method） （Prototype） Singleton インスタンスが一つしか生成されないようにする 応用 派生可能にして実体は別にするとか 内部にDictionaryを用意して複数保持できるようにするとか 外部から登録可能な仕組みにするとか classDiagram Singleton *-- Singleton : static変数で保持 Singleton : instance public class MySingleton { public static MySingleton Instance { get; } = new MySingleton(); private MySingleton() { } } // Lazy（ダブルチェックロッキング）で遅延生成にする場合 private static readonly LazyMySingleton __lazy = new LazyMySingleton(() = new MySingleton()); public static MySingleton Instance = __lazy.Value; （Adapter） （Bridge） （Composite） （Decorator） （Facade） （Flyweight） （Proxy） （Chain of Responsibility） （Command） （Interpreter） （Iterator） （Mediator） （Memento） （Observer） State 状態を多態性で表現する 状態の変化（次にどの状態にするか）は誰が管理してもいい classDiagram ねこ *-- ねこ状態 ねこ状態 |-- 眠っている ねこ状態 |-- 走っている ねこ状態 |-- 食べている ねこ状態 |-- 爪をといでいる （Strategy） （Template Method） （Visitor）"},{"url":"/articles/f8166079e7ab4762a1b69df4a54fc83f/","date":"2018-12-08","title":"[C#] IDisposableなメンバーをまとめて破棄する方法を考えてみる","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"はじめに メンバーにIDisposableなオブジェクトを保持している場合、自分もIDisposableにしてDispose()メソッドで全てのメンバーの破棄処理を行う必要があり、面倒です。 以下のような仕組みを考え、実装してみました。 // こんな感じの仕組みがほしい public class SampleClass : IDisposable { [DisposableMember] private MemoryStream _stream1 = new MemoryStream(); [DisposableMember] private MemoryStream _stream2 = new MemoryStream(); [DisposableMember] private MemoryStream _stream3 = new MemoryStream(); public void Dispose() { // 対象メンバーを自動で破棄する Disposer.DisposeAll(this); } } カスタム属性とリフレクション 仕組みの実装です。リフレクションでまとめて処理します。 // カスタム属性 [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)] public sealed class DisposableMemberAttribute : Attribute { } // 破棄処理用 public static class Disposer { public static void DisposeAll(object obj) { var disposableType = typeof(IDisposable); var type = obj.GetType(); foreach (var fi in type .GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance) .Where(fi = fi.GetCustomAttributeDisposableMemberAttribute() != null)) { if (!disposableType.IsAssignableFrom(fi.FieldType)) { throw new InvalidOperationException(); } DisposeField(obj, fi); } foreach (var pi in type .GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance) .Where(pi = pi.GetCustomAttributeDisposableMemberAttribute() != null)) { if (!disposableType.IsAssignableFrom(pi.PropertyType)) { throw new InvalidOperationException(); } DisposeProperty(obj, pi); } } private static void DisposeField(object obj, FieldInfo fi) { if (fi.GetValue(obj) is IDisposable disposeObj) { disposeObj.Dispose(); fi.SetValue(obj, null); } } private static void DisposeProperty(object obj, PropertyInfo pi) { if (pi.GetValue(obj) is IDisposable disposeObj) { disposeObj.Dispose(); pi.SetValue(obj, null); } } } おわりに リフレクションを使っていますが、もともとDispose等の破棄処理自体がコストがかかるケースが多いため、この方法でもいいのではないかと思っています。 以下の点を改善すれば、より実用的になるかもしれません。 FieldInfoやPropertyInfoはキャッシュする（高速化対応） Disposeする順序やグループを指定できるようにする"},{"url":"/articles/2b51eaa06de848fcb569116b82ada4be/","date":"2018-12-06","title":"[C#] オブジェクトの状態が勝手に変更されるのを防ぐ方法","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"}],"content":"意図しない箇所でオブジェクトがいつのまにか内容変更されてしまうのを防ぐ方法について記載します。 対策：イミュータブル コンストラクタでのみ状態設定できるようにする手法です。同一インスタンスを持ちまわしても問題なく、またスレッドセーフです。 状態変更するメソッドを用意する場合は、自身の内容は変えず、別インスタンスを戻り値で返すようにします。 対策：ディープコピー 同一インスタンスを持ちまわすのではなく、ディープコピーを使う手法です。 実装方法がいくつかあります。 シリアライズを使う メモリ上にシリアライズ／デシリアライズすることでディープコピーを実現します。ディープコピー手法の中では一番おすすめです。 DataContract属性とMessagePack for C#の組み合わせがいいと思います。 MessagePack https://www.nuget.org/packages/MessagePack/ ICloneable System.ICloneableを実装する方法です。ちなみにICloneable\u003CT\u003Eといったジェネリック版は存在しません。 ICloneable.Clone()メソッドは戻り値がシャロ―コピーかディープコピーか規定しておらず、また戻り値の型がobjectだったりと不便です。 基本的に使用しない方がいいです。 独自クローンメソッド＋MemberwiseClone 独自のクローンメソッドを用意する方法です。結局のところ、実装すべき内容はICloneableを実装する場合と同じです。 継承階層がある場合の実装コストや、今後フィールドが増えた場合のメンテナンスコストがかかります。 メソッド内部でobject.MemberwiseClone（自分のシャロ―コピーを自動生成してくれる）を使えばミュータブルなフィールドのみディープコピーすればいいので、多少楽できます。 独自クローンメソッド＋コピーコンストラクタ 独自のクローンメソッドを用意し、内部ではコピーコンストラクタを使ってインスタンス生成する方法です。 コピーコンストラクタのみ クローンメソッドは用意せず、コピーコンストラクタは用意する方法です。 この方法だと、継承階層があり派生型のオブジェクトを基底型の変数に代入して保持している場合、そこから実体をディープコピーすることはできません。 対策：読み取り専用インターフェイス 読み取り専用インターフェイスを用意する手法です。 interface IReadOnlyPerson { } class Person : IReadOnlyPerson { } この手法の場合、もとのオブジェクトはミュータブルなので、もとのオブジェクトの状態が変われば使用している側にも影響がでます。 対策：ラップ ミュータブルなオブジェクトをラップし、ラップオブジェクトからは読み取り専用の操作しかできないようにする手法です。 ヒープを消費したくない場合、構造体でラップするのを検討してもいいかもしれません。 この手法の場合、もとのオブジェクトはミュータブルなので、もとのオブジェクトの状態が変われば使用している側にも影響がでます。 対策：internal アクセス修飾子をinternalにすることで、別アセンブリからは変更操作をできないようにする手法です。 この手法の場合、もとのオブジェクトはミュータブルなので、もとのオブジェクトの状態が変われば使用している側にも影響がでます。"},{"url":"/articles/420af11cac47421f800985af465d6750/","date":"2018-12-05","title":"[C\u002B\u002B] 参照カウント式スマートポインタを自作","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C\u002B\u002B","url":"/tags/cpp/"}],"content":"はじめに かなり前に久しぶりにC\u002B\u002Bで仕事をする機会があり、リハビリ用になにか適当に作ろうと思い、なんとなく書いた「参照カウント式スマートポインタ」です。 boost::shared_ptrの簡易版みたいなものです。 実装 templateclass T class SharedPtr { // Constructors public: SharedPtr(); SharedPtr(const SharedPtrT src); explicit SharedPtr(T* ptr); ~SharedPtr(); static SharedPtrT Create(T* ptr) { return SharedPtrT(ptr); } // Operations public: // アロー演算子 T* operator -() const { return m_ptr; } // 変換演算子 operator T*() const { return m_ptr; } // 参照演算子 T operator *() const { return *m_ptr; } // 代入演算子 SharedPtrT operator =(const SharedPtrT src); // Member Function public: T* Get() const { return m_ptr; } int __UseCount() const { return (m_ptr == NULL) ? 0 : (*m_pCount); } private: void CopyImpl(const SharedPtrT src); void DeleteCheck(); // Data Member private: T* m_ptr; int* m_pCount; }; templateclass T SharedPtrT::SharedPtr() : m_ptr(NULL), m_pCount(NULL) { std::cout SharedPtrT::SharedPtr() std::endl; } templateclass T SharedPtrT::SharedPtr(const SharedPtrT src) : m_ptr(NULL), m_pCount(NULL) { CopyImpl(src); std::cout SharedPtrT::SharedPtr(const SharedPtr src) std::endl; } templateclass T SharedPtrT::SharedPtr(T* ptr) : m_ptr(NULL), m_pCount(NULL) { m_ptr = ptr; m_pCount = new int(1); std::cout SharedPtrT::SharedPtr(T* ptr) std::endl; } templateclass T SharedPtrT::~SharedPtr() { std::cout SharedPtrT::~SharedPtr() std::endl; DeleteCheck(); } templateclass T SharedPtrT SharedPtrT::operator =(const SharedPtr src) { CopyImpl(src); return *this; } templateclass T void SharedPtrT::CopyImpl(const SharedPtrT src) { if (this != src) { if (m_ptr != src.m_ptr) { DeleteCheck(); if (src.m_ptr != NULL) { m_ptr = src.m_ptr; m_pCount = src.m_pCount; (*m_pCount)\u002B\u002B; } } } } templateclass T void SharedPtrT::DeleteCheck() { if (m_ptr != NULL) { (*m_pCount)--; if ((*m_pCount) == 0) { delete m_ptr; m_ptr = NULL; delete m_pCount; m_pCount = NULL; } } } テストコード class ShareTest { public: ShareTest() : num(-1) {} ~ShareTest() {} int num; }; int main(int argc, char* argv[]) { // スコープを作っておいて最後に _CrtDumpMemoryLeaksを呼び出す { SharedPtrShareTest spTest1(new ShareTest()); { SharedPtrShareTest spTest2(spTest1); SharedPtrShareTest spTest3; SharedPtrShareTest spTest4; ((ShareTest*) spTest1)-num = 5; spTest3 = spTest1; std::cout spTest1-num = spTest1-num std::endl; std::cout spTest2-num = spTest2-num std::endl; std::cout spTest3-num = spTest3-num std::endl; std::cout spTest4.use_count() = spTest4.__UseCount() std::endl; std::cout spTest3.use_count() = spTest3.__UseCount() std::endl; std::cout spTest2.use_count() = spTest2.__UseCount() std::endl; if (spTest4 == NULL) { std::cout NULL std::endl; } } std::cout spTest1.use_count() = spTest1.__UseCount() std::endl; } _CrtDumpMemoryLeaks(); return 0; } 実行結果 SharedPtrT::SharedPtr(T* ptr) SharedPtrT::SharedPtr(const SharedPtr src) SharedPtrT::SharedPtr() SharedPtrT::SharedPtr() spTest1-num = 5 spTest2-num = 5 spTest3-num = 5 spTest4.use_count() = 0 spTest3.use_count() = 3 spTest2.use_count() = 3 NULL SharedPtrT::~SharedPtr() SharedPtrT::~SharedPtr() SharedPtrT::~SharedPtr() spTest1.use_count() = 1 SharedPtrT::~SharedPtr() とりあえず、ちゃんと機能しているようです。"},{"url":"/articles/baec0664c919499cab78040ac178c61c/","date":"2018-12-04","title":"Flexboxで可変幅の子ボックスが親ボックスからはみ出る現象の回避","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"CSS","url":"/tags/css/"},{"name":"Web全般","url":"/tags/general-web/"}],"content":"はじめに 久しぶりにWeb系の技術を調べていて、CSS3でFlexboxレイアウトなるものが追加されたと最近知りました。 Web系の、 なんでこんな基本的なことが標準機能にないんだ！ なんでベンダー毎で仕様が違うんだ！ といった不満が、HTML5、CSS3、ECMAScript 2015でやっと改善されてきた気がします。 floatなんか使わない、横並びはFlexboxで統一しよう、と書き換えていたのですが、子ボックスが親ボックスからはみ出る現象が起きていたので、解決策を記載します。 現象 以下のようなHTMLを書くと、 div style=width: 200px; display: flex; border: solid 3px black; div style=flex: none; width: 100px; background-color: lightblue; 固定幅Box /div div style=flex: 1; background-color: pink; 可変幅Box pre style=overflow-x: auto; overflow-wrap: normal;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/pre /div /div 以下のように可変幅の子ボックスが、親ボックスからはみ出てしまいます。 \u003Cdiv style=\u0022width: 200px; display: flex; border: solid 3px black;\u0022\u003E \u003Cdiv style=\u0022flex: none; width: 100px; background-color: lightblue;\u0022\u003E 固定幅Box \u003C/div\u003E \u003Cdiv style=\u0022flex: 1; background-color: pink;\u0022\u003E 可変幅Box \u003Cpre style=\u0022overflow-x: auto; overflow-wrap: normal;\u0022\u003Eaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u003C/pre\u003E \u003C/div\u003E \u003C/div\u003E 本来はpre要素に横スクロールバーが出てほしいところです。 解決策 min-widthの初期値がautoになっているのが原因のようです。 https://developer.mozilla.org/ja/docs/Web/CSS/min-width 以下のようにすると解決します。 div style=width: 200px; display: flex; border: solid 3px black; div style=flex: none; width: 100px; background-color: lightblue; 固定幅Box /div !-- min-width: 0; を追加 -- div style=flex: 1; min-width: 0; background-color: pink; 可変幅Box pre style=overflow-x: auto; overflow-wrap: normal;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/pre /div /div ちゃんと親に収まり、pre要素には横スクロールバーが表示されるようになりました。 \u003Cdiv style=\u0022width: 200px; display: flex; border: solid 3px black;\u0022\u003E \u003Cdiv style=\u0022flex: none; width: 100px; background-color: lightblue;\u0022\u003E 固定幅Box \u003C/div\u003E \u003C!-- min-width: 0; を追加 --\u003E \u003Cdiv style=\u0022flex: 1; min-width: 0; background-color: pink;\u0022\u003E 可変幅Box \u003Cpre style=\u0022overflow-x: auto; overflow-wrap: normal;\u0022\u003Eaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u003C/pre\u003E \u003C/div\u003E \u003C/div\u003E"},{"url":"/articles/dd6ee3d74e8943ca82721feb84aaf48e/","date":"2018-12-03","title":"[C#] Pandocを外部プロセスとして起動し標準入出力でやりとりする","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"},{"name":"Pandoc","url":"/tags/pandoc/"}],"content":"はじめに ドキュメント変換ツール「Pandoc」を、表題のとおり試してみました。 Pandoc http://pandoc.org/ 静的サイトジェネレーターを自作中なのですが、Pandocは以前使ったことがあったので、C#から使用できないかと色々試していました。 最終的には外部プロセスとして起動する関係上、時間がかかりすぎるのであきらめたのですが、 標準入出力でやりとりする際に文字コードを指定するといった工夫が必要だったので、備忘録としてサンプルコードを記載します。 単純にMarkdownをHTMLに変換するのが目的であればMarkDigをおすすめします。 MarkDig https://www.nuget.org/packages/Markdig/ 実装 class Program { static void Main() { var markdown = @ # はじめに * これはPandocでHTML変換するサンプルです。 \u0060\u0060\u0060 var i = 3; \u0060\u0060\u0060 ; Console.WriteLine( StartPandoc(@C:\\Pandoc\\pandoc.exe, -f markdown -t html5, markdown)); } static string StartPandoc(string pandocPath, string args, string input) { using (var process = new Process()) { process.StartInfo.FileName = pandocPath; process.StartInfo.Arguments = args; process.StartInfo.UseShellExecute = false; process.StartInfo.CreateNoWindow = true; process.StartInfo.RedirectStandardInput = true; process.StartInfo.RedirectStandardOutput = true; process.StartInfo.StandardOutputEncoding = Encoding.UTF8; process.Start(); using (process.StandardInput) using (var sw = new StreamWriter(process.StandardInput.BaseStream, Encoding.UTF8, 1024, true)) { sw.Write(input); } var output = process.StandardOutput.ReadToEnd(); process.WaitForExit(); return output; } } } 実行結果 h1 id=はじめにはじめに/h1 ul lipこれはPandocでHTML変換するサンプルです。/p precodevar i = 3;/code/pre/li /ul ちゃんとHTMLに変換されています。"},{"url":"/articles/8df409a9cfdf41e8b67099026cddbc66/","date":"2018-12-02","title":"[C\u002B\u002B] DirectX9で太陽系を描画する","category":{"order":0,"name":"Demo","url":"/categories/demo/"},"tags":[{"name":"3D","url":"/tags/3d/"},{"name":"DirectX","url":"/tags/directx/"},{"name":"C\u002B\u002B","url":"/tags/cpp/"}],"content":"はじめに 3Dプログラミング学習用に昔作成したサンプルをアップしました。 https://github.com/yoshiheight/Sample.D3DGalaxy \u003Cdiv style=\u0022max-width: 640px;\u0022\u003E\u003Cvideo src=\u0022/files/d3d-galaxy/d3d-galaxy.mp4\u0022 controls\u003E\u003C/video\u003E\u003C/div\u003E 仕様 惑星の大きさ、惑星間の距離は実際の値を反映 軌道傾斜角、楕円軌道は無視 カメラは「原点を注視するモード」「惑星を一定距離で注視するモード」を切り替え可能 「惑星を一定距離で注視するモード」の場合、惑星間を移動可能 太陽 \u003E 惑星公転 \u003E 衛星公転は、行列の親子関係で処理する 周囲の星々は天球を使って処理する 操作方法 キー |操作 -----|-------------- テンキー 1 / 3 |カメラX軸移動（\u002B Ctrl で回転） テンキー 5 / 2 |カメラY軸移動（\u002B Ctrl で回転） テンキー 9 / 6 |カメラZ軸移動（\u002B Ctrl で回転） テンキー \u002B / - |カメラズーム Q / W |公転半径割合変更 ESC |終了 F1 |固定FPSモード / FPS計測モードの切り替え F2 |惑星間のカメラ移動 F3 |カメラ切り替え（原点注視 / 惑星を一定距離で注視） F4 |ライトON / OFF F5 |Solid / Wireframe切り替え F6 |惑星サイズ実物 / 全て同一切り替え F7 |公転リセット"},{"url":"/articles/718ac1cb539c47edb70462354c110387/","date":"2018-12-01","title":"[C\u002B\u002B] DirectX9で高さマップから地形を生成する","category":{"order":0,"name":"Demo","url":"/categories/demo/"},"tags":[{"name":"3D","url":"/tags/3d/"},{"name":"DirectX","url":"/tags/directx/"},{"name":"C\u002B\u002B","url":"/tags/cpp/"}],"content":"はじめに 3Dプログラミング学習用に昔作成したサンプルをアップしました。 https://github.com/yoshiheight/Sample.D3DField \u003Cdiv style=\u0022max-width: 640px;\u0022\u003E\u003Cvideo src=\u0022/files/d3d-field/d3d-field.mp4\u0022 controls\u003E\u003C/video\u003E\u003C/div\u003E 仕様 地形を表すメッシュ状のポリゴンを、外部からロードした高さマップによって生成する 高さマップは、グレースケールのBMP画像を使用する 1ピクセルがポリゴン1頂点を表す 各ピクセルが256段階の高さを表し、色が薄いほど高い標高とする 地形全体に地形画像用テクスチャをマッピング可能とする テクスチャのサイズは高さマップと同じでなくてもいい ポイントスプライトを使用して雪を降らせる 雪はαで抜きの入った画像を使用 操作方法 キー |操作 -----|-------------- ← / → |モデルX軸移動（\u002B Ctrl で回転） ↑ / ↓ |モデルY軸移動（\u002B Ctrl で回転） PgUp / PgDn |モデルZ軸移動（\u002B Ctrl で回転） テンキー 1 / 3 |カメラX軸移動（\u002B Ctrl で回転） テンキー 5 / 2 |カメラY軸移動（\u002B Ctrl で回転） テンキー 9 / 6 |カメラZ軸移動（\u002B Ctrl で回転） テンキー \u002B / - |カメラズーム 1 / Q |光源色R 2 / W |光源色G 3 / E |光源色B A / Z |光源方向X S / X |光源方向Y D / C |光源方向Z O / L |高さ単位 ESC |終了 F1 |固定FPSモード / FPS計測モードの切り替え F2 |頂点バッファ/ インデックスバッファの切り替え F3 |カメラ切り替え（原点注視 / 任意注視） F4 |ライトON / OFF F5 |Solid / Wireframe切り替え F6 |法線表示ON / OFF F7 |テクスチャON / OFF F8 |フォグON / OFF"},{"url":"/articles/9adc3a386df24055a69dbeb63c7d58f2/","date":"2018-11-30","title":"DirectX9について書いたメモ","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"3D","url":"/tags/3d/"},{"name":"DirectX","url":"/tags/directx/"},{"name":"開発全般","url":"/tags/general-dev/"}],"content":"はじめに 昔書いたDirectX9のメモが出てきたので、とりあえずアップしました。 メモ メッセージループは一般的には60FPSで描画する メッセージループ中では適度なスリープを入れる。ウィンドウアクティブ状態によりスリープ量を可変にするとより最適。(アクティブ時:スリープなし、非アクティブ時:スリープ多め、等) ベンチマーク的な事をしたい場合はFPS固定にしないで、とにかくぶん回す(FPSを測定したい場合など。その場合でもスクリプト更新処理は60FPSにしておく事) プレゼンテーションパラメータのVSync同期はオフにしておく(VSync同期がオンの場合、描画結果の転送時(m_pD3DDevice-\u003EPresent())に同期が行われる) 時間測定はウィンドウズマルチメディアタイマ(timeGetTime)を使用し精度を高めておく 基本的にゲーム内での絶対的な時間はフレームである FPSが異なる環境で同じ速度にする場合や処理落ちしても通常と同じ分だけ移動させる場合、1フレームでの経過時間に速度をかける方法がある ビューのOnPaintでもレンダリングしておくと描画もれを防げる 座標はスクリーン座標とワールド座標がある デバイス消失(ロスト)を考慮する必要がある(ユーザーが解像度を変えたりとか)。デバイス再作成やテクスチャー作り変えをしないとだめ GetDeviceCaps → これにより事前にデバイスの詳細情報を取得して適切な量のVRam確保を行ったりする VertexBuffer → VRamに確保した頂点バッファ。Lockでシステムメモリにコピー、UnLockで逆にVRamにコピーされる。 Z順比較は無効にして、自分で描画する順番でZ順になるようにする事もある。(２Ｄだけ?) Zソート法では物体が交差する場合、うまく描画できないので、Zバッファ法を使う。半透明のものはZソート法を使って後から描画。またZバッファ法では出来るだけ手前の物体から描画すると後ろの物体を描画するときに余計な書き込みが起こるのを防げるのでパフォーマンスが上がる。 行列で合成の繰り返しは誤差を生む(30度の行列と60度の行列の合成とか)。その場合は一度リセットし、新たに90度の回転行列を生成してそれを適用するべし。 回転は X軸、Y軸、Z軸 でどの順番で回転させるかで意味が違ってくる。(例: X軸回転後 → Y軸回転 と Y軸回転後 → X軸回転 では意味が違う) フォントによる文字列描画はDrawPrimitiveに比べると格段に遅い。(スプライトを使っても遅かった) Xファイルのデータはマテリアル単位になっているので、その単位で描画する(DrawSubset) カメラ設定で D3DXMatrixLookAtLH を使って注視点を任意で動的に設定する場合、X軸回転が90度を越えてもカメラの上下は逆にならない。(カメラの上方向ベクトルを D3DXVECTOR3(0.0f, 1.0f, 0.0f) で指定しているので当たり前だが) 頂点バッファ(CreateVertexBuffer)を使用しない場合 → DrawPrimitiveUP 2Dで使う場合 → D3DFVF_XYZRHW 半透明にするものは後から描画する。(先に描画したら半透明にならないので) 半透明でない物は手前から描画する。(町を描いた後にそれを覆う山を書く場合、町の描画が無駄になる為)(2Dの場合、Z値は0.0固定にして描画処理順でZ順を制御してもいい) DirectX9.0から SetVertexShader が SetFVF に変更された SetRenderStateとかSetTextureとか、設定変えたらちゃんと元に戻さないとダメ。 ポリゴン数が多くてFPSが下がる場合、クリッピング、矩形分割、見える範囲のみ描画する。メモリもフィールドを一定矩形で分割し、必要な分だけ読み込むとか。 描画する時、SetRenderStateがいろいろ切り替わると描画効率が下がる。なので同じRenderStateで描画できる物は一まとめで描画する。 頂点フォグとピクセルフォグがあるが、どうやら頂点フォグの方がよく使う？らしい ビュー行列→単位行列にした場合、位置は(0,0,0)、方向はZ軸プラス方向だった。 アルファテストでZソートしなくてもいい Zソートする場合、単純に中心座標だけで比較はできない(内包する場合とか) テクスチャとか、D3DXCreateSphereで作成したモデルとか、Xファイル読み込みモデルとか、１つあればそれを使いまわして描画可能。(大きさの違いは描画時にスケーリング。また読み込み時に頂点バッファをロックして直接座標を×2とかして最初にスケーリングしておく事も可。但し通常は読み込んだデータをその後スケーリングする場合は少ない。) 背景描画には天球を使ったりする。 プレゼンテーションパラメータ指定でアンチエイリアスできる 座標でW値？ SetRenderState、これからSetしようとする場合、Getして現状と違うならSetする D3DXBoxBoundProbe 関数 D3DCLIPSTATUS9 構造体 視錐台 D3DXIntersect 関数 pD3DDevice-\u003ESetRenderState(D3DRS_ZENABLE, D3DZB_TRUE); // Ｚ比較を有効 pD3DDevice-\u003ESetRenderState(D3DRS_CULLMODE, D3DCULL_CCW); // 左回りでカリング pD3DDevice-\u003ESetRenderState(D3DRS_ALPHABLENDENABLE, FALSE); // アルファブレンドを無効 フレームスキップ時、当たり判定考慮 頂点データ配列 → DrawPrimitiveUP 頂点バッファ → SetStreamSource → SetFVF → DrawPrimitive ビルボード： 常にカメラに対して正対する表現方法 ポイントスプライト： パーティクル(火花、雪といった粒子状の物)の描画に適した手法。1頂点で常にカメラに対して自動的に正対してくれる。2Dテクスチャを張っただけの板ポリゴンでも、常にカメラの方向を向いてくれるので、手動で向きの計算を行う必要がない。 座標系：モデル座標を以下の順で変換される(最終的にはスクリーン座標になる) モデル座標系: モデルの中心が原点の座標系(論理座標) ワールド座標系: シーンの座標系。原点にあまり意味はない。(論理座標) ビュー座標系: カメラ視点(カメラの位置と方向)にあわせて再定義した座標系。原点はカメラ。(論理座標) 射影座標系: 視点からの距離を基準にスケーリングした座標系。(論理座標)。カメラから見える全てのものを含んだ空間を「視錐台」という。 スクリーン座標系: 画面の座標系。(物理座標)。 行列の合成: 座標変換は原点を基準に処理されるため、拡大縮小→回転→移動、の順番を守って合成しないとだめ。回転はX軸、Y軸、Z軸のどの順で回転させるかによって結果が異なる。"},{"url":"/articles/f638d5988257491e917c4ed14fbf5b38/","date":"2018-11-29","title":"[C#] Socketを使ってP2Pでやりとりするチャットアプリを作る","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"},{"name":"Socket","url":"/tags/socket/"},{"name":"P2P","url":"/tags/p2p/"}],"content":"はじめに Socketを使ってTCPで非同期P2Pでやりとりするチャットアプリサンプルを作ってみました。 GUIイメージ画像 構成 「通信ライブラリ」と「画面」に分けます。 ・通信ライブラリ側 ITcpSerializer.cs 送受信するメッセージのシリアライザ用インターフェイス TcpPeer.cs TCPで非同期P2P通信するクラス ・画面側 MainWindow.xaml 画面 StringSerializer.cs メッセージシリアライザ 通信ライブラリ側 送受信するデータのシリアライザは画面側が実装するので、通信ライブラリ側ではインターフェイスを提供します。 public interface ITcpSerializerTMessage { void Serialize(Stream stream, TMessage message); TMessage Deserialize(Stream stream); } TcpPeerは一番重要な送受信する為のクラスです。 // TCPで非同期P2P通信するクラス public sealed class TcpPeerTMessage where TMessage : class { public event ActionTMessage Sended; public event ActionTMessage Recved; private Socket _socket; private ITcpSerializerTMessage _serializer; private SynchronizationContext _sc = SynchronizationContext.Current; private ConcurrentQueueTMessage _sendQueue = new ConcurrentQueueTMessage(); // コンストラクタ（接続待機側で、相手からの接続要求Socketに対して使用） public TcpPeer(Socket socket, ITcpSerializerTMessage serializer) { _socket = socket; _serializer = serializer; } // コンストラクタ（接続する側で使用） public TcpPeer(ITcpSerializerTMessage serializer) { _socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); _serializer = serializer; } // 指定のIPアドレス・ポートに接続する public async Task ConnectAsync(string ipAddr, int port) { await Task.Factory.StartNew(() = _socket.Connect(IPAddress.Parse(ipAddr), port)); } // 非同期送受信を開始する public async Task StartMessagingAsync() { try { await Task.WhenAll( Task.Factory.StartNew(DoSendMain, TaskCreationOptions.LongRunning), Task.Factory.StartNew(DoRecvMain, TaskCreationOptions.LongRunning)); } finally { _socket.Close(); } } // メッセージ送信 public void Send(TMessage message) { _sendQueue.Enqueue(message); } // 送信キュー内の全てのメッセージが送信された後、送受信を終了させる public void Terminate() { _sendQueue.Enqueue(null); } // 送信メイン private void DoSendMain() { try { using (var stream = new NetworkStream(_socket, FileAccess.Write, false)) { while (_socket.Connected) { if (_sendQueue.TryDequeue(out var message)) { if (message == null) { break; } _serializer.Serialize(stream, message); stream.Flush(); _sc.Post(_ = Sended?.Invoke(message), null); } else { // CPU占有回避（本来はManualResetEventを使ってキューに追加された時だけ処理する方がいい） Thread.Sleep(1); } } } } finally { _socket.Shutdown(SocketShutdown.Send); } } // 受信メイン private void DoRecvMain() { try { using (var stream = new NetworkStream(_socket, FileAccess.Read, false)) { var peekBuff = new byte[1]; while (_socket.Receive(peekBuff, SocketFlags.Peek) 0) { var message = _serializer.Deserialize(stream); _sc.Post(_ = Recved?.Invoke(message), null); } } } finally { Terminate(); } } } TcpPeerは実装をシンプルにする為、以下のようにしています。 送信用と受信用にスレッドを用意 Socketクラスはスレッドセーフなので同期の必要はない Task、async/awaitを使用 送信キューを用意 画面側への通知にはSynchronizationContextを使用 通信終了時の処理フローは以下です。 自分が送信側をシャットダウン 相手の受信側が終わる 相手が送信側シャットダウン 自分の受信側が終わる 画面側 送受信に使用するメッセージクラスとシリアライザ（つまり通信プロトコルにあたる部分）は画面側で用意します。 今回はメッセージクラスは用意せずstringをそのまま使うことにして、シリアライザのみ用意します。 // メッセージシリアライザ public sealed class StringSerializer : ITcpSerializerstring { // シリアライズ public void Serialize(Stream stream, string message) { var bytes = Encoding.UTF8.GetBytes(message); // データ長の書き込み stream.WriteByte((byte)bytes.Length); // データの書き込み stream.Write(bytes, 0, bytes.Length); } // デシリアライズ public string Deserialize(Stream stream) { // データ長の読み込み var len = stream.ReadByte(); // データの読み込み return Encoding.UTF8.GetString(ReadDataFromNetwork(stream, len)); } // ネットワークストリームからバイト列を読み込む private static byte[] ReadDataFromNetwork(Stream stream, int readLength) { // ネットワークの場合、一度に読み込めるとは限らないのでループする var buffer = new byte[readLength]; var readTotal = 0; while (readTotal readLength) { readTotal \u002B= stream.Read(buffer, readTotal, readLength - readTotal); } return buffer; } } 画面レイアウトはXAMLで適当に作ってください。 Window x:Class=WpfTcpChat.MainWindow xmlns=http://schemas.microsoft.com/winfx/2006/xaml/presentation xmlns:x=http://schemas.microsoft.com/winfx/2006/xaml xmlns:d=http://schemas.microsoft.com/expression/blend/2008 xmlns:mc=http://schemas.openxmlformats.org/markup-compatibility/2006 mc:Ignorable=d Title=TCP P2P Chat Height=250 Width=300 DockPanel StackPanel DockPanel.Dock=Top Orientation=Horizontal Button Content=待機を開始 Click=WaitButton_Click Margin=4 / Button Content=接続 Click=ConnectButton_Click Margin=4 / /StackPanel DockPanel DockPanel.Dock=Bottom Button DockPanel.Dock=Right IsDefault=True Content=送信 Click=SendButton_Click / TextBox Name=textboxInput / /DockPanel TextBox Name=textboxChatContent AcceptsReturn=True IsReadOnly=True VerticalScrollBarVisibility=Visible / /DockPanel /Window 画面側の処理は通信ライブラリを使うだけで、いたってシンプルです。 private TcpPeerstring _peer; // チャットのメイン処理 private async void ChatProc() { // メッセージを送受信した際のイベント処理 _peer.Sended \u002B= message = textboxChatContent.AppendText($ 自分: {message}\\n); _peer.Recved \u002B= message = textboxChatContent.AppendText($ 相手: {message}\\n); textboxChatContent.AppendText(チャット開始\\n); await _peer.StartMessagingAsync(); textboxChatContent.AppendText(チャット終了\\n); } // 相手からの接続を待機する private async void WaitButton_Click(object sender, RoutedEventArgs e) { textboxChatContent.AppendText(待機中...\\n); var listener = new TcpListener(new IPEndPoint(IPAddress.Any, 10000)); listener.Start(); var socket = await listener.AcceptSocketAsync(); listener.Stop(); _peer = new TcpPeerstring(socket, new StringSerializer()); ChatProc(); } // 相手に接続する private async void ConnectButton_Click(object sender, RoutedEventArgs e) { textboxChatContent.AppendText(接続中...\\n); _peer = new TcpPeerstring(new StringSerializer()); await _peer.ConnectAsync(127.0.0.1, 10000); ChatProc(); } // メッセージを送信する private void SendButton_Click(object sender, RoutedEventArgs e) { if (string.IsNullOrEmpty(textboxInput.Text)) { // 終了 _peer.Terminate(); return; } // メッセージ送信 _peer.Send(textboxInput.Text); textboxInput.Clear(); } おわりに async/await（エイシンク/アウェイト）最高！！"},{"url":"/articles/c963f0fbaf4e4adf9a7a391c725b6858/","date":"2018-11-28","title":"[C#] .NET CoreでT4Templateを使う場合の注意点","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"},{"name":"T4Template","url":"/tags/t4template/"},{"name":".NET Core","url":"/tags/netcore/"}],"content":"はじめに Visual Studio で .NET Core プロジェクトに T4Template を追加すると、とある問題が発生しており（自分の環境だけかもしれませんが）、その回避方法について記載します。 環境 Visual Studio Community 2017 Version 15.9.3 .NET Core 2.1 コンソールアプリ ランタイムテキストテンプレート 現象 ランタイムテキストテンプレートを新規追加すると、以下の現象が発生する。 常に発生 砂時計アイコンのままになってしまい、動作も重く操作がままならない（Visual Studio を再起動するまで続く） たまに発生 Visual Studio でランタイムテキストテンプレートのプロパティを確認すると、カスタムツールが TextTemplatingFileGenerator になっている（正しくは TextTemplatingFilePreprocessor） 回避方法 テキストファイルを新規作成し、プロパティのカスタムツールに以下を設定する TextTemplatingFilePreprocessor 更にファイルの先頭に以下のコードを記載する #@ template language=C# # #@ assembly name=System.Core # #@ import namespace=System.Linq # #@ import namespace=System.Text # #@ import namespace=System.Collections.Generic # 任意だが、テキストファイルの拡張子を「.tt」など、分かりやすいものに変更する リビルド もう一つ注意点 .NET Core 2.1 には CodeDom が含まれていない為、T4Template でビルドエラーになります。NuGet から追加する必要があります。 CodeDom https://www.nuget.org/packages/System.CodeDom/ おわりに T4Template は外部ファイル化はできないのですが、 \u003C# #\u003E の間に C# コードをそのまま記述できるという学習コストの低さと、 構文エラーをビルド時に見つけてくれるという利点があります。 今後も使う機会はあるので、この現象が Visual Studio の不具合であれば今後改善されることを期待します。"},{"url":"/articles/b771882b37214e448ddbac04f105f7e0/","date":"2018-11-26","title":"[C#] 透過プロキシでREST Clientを実装してQiita APIをたたいてみる","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"},{"name":"REST","url":"/tags/rest/"},{"name":"AOP","url":"/tags/aop/"}],"content":"はじめに RestSharpを試してみようと思い、Qiita APIでタグ一覧を取得してみました。 https://qiita.com/api/v2/docs 普通にRestSharpを使うのでは面白くないので、 以下のようにインターフェイスを用意すれば簡単にREST Clientが作れる仕組みを実装してみます。 // こんな風にRESTクライアントを定義 public interface IQiitaApi { [RestApi(Path = /api/v2/tags, Method = RequestMethod.Get)] QiitaTagInfo[] GetTags( [RestParam(page)] int page, [RestParam(per_page)] int perPage, [RestParam(sort)] QiitaTagSortMode sortMode); } [DataContract] public enum QiitaTagSortMode { [EnumMember(Value = count)] Count, [EnumMember(Value = name)] Name, } // 関係ないけど、あえて [JsonObject(MemberSerialization.OptIn)] を試す [JsonObject(MemberSerialization.OptIn)] public sealed class QiitaTagInfo { [JsonProperty(id)] public string Id { get; set; } [JsonProperty(items_count)] public int Count { get; set; } [JsonProperty(followers_count)] public int FollowersCount { get; set; } } // こんな風に使う var factory = new RestApiFactory(https://qiita.com); var api = factory.CreateIQiitaApi(); var result = api.GetTags(1, 20, QiitaTagSortMode.Count); 実装 使用ライブラリ RestSharp https://www.nuget.org/packages/RestSharp/ Json.NET https://www.nuget.org/packages/Newtonsoft.Json/ C#でAOP（アスペクト指向的）なことを実現するにはRealProxyクラスを使用します。 public sealed class RestApiFactory { private readonly string _baseUrl; public RestApiFactory(string baseUrl) { _baseUrl = baseUrl; } public TApi CreateTApi() { var proxy = new RestApiProxyTApi(_baseUrl); return (TApi)proxy.GetTransparentProxy(); } } public sealed class RestApiProxyTApi : RealProxy { private readonly RestClient _client; public RestApiProxy(string baseUrl) : base(typeof(TApi)) { _client = new RestClient(baseUrl); } public override IMessage Invoke(IMessage message) { var methodMessage = (IMethodCallMessage)message; var methodInfo = (MethodInfo)methodMessage.MethodBase; var apiAttr = methodInfo.GetCustomAttributeRestApiAttribute(); var request = new RestRequest(apiAttr.Path, (Method)Enum.Parse(typeof(Method), apiAttr.Method.ToString(), true)); var serializer = new JsonSerializer(); serializer.Converters.Add(new StringEnumConverter()); var args = JArray.FromObject(methodMessage.Args, serializer); var paramInfos = methodMessage.MethodBase.GetParameters(); foreach (var item in args.Zip(paramInfos, (arg, paramInfo) = new { arg, paramInfo })) { var paramAttr = item.paramInfo.GetCustomAttributeRestParamAttribute(); request.AddParameter(paramAttr.Name, item.arg); } var response = _client.Execute(request); if (response.ResponseStatus != ResponseStatus.Completed) { throw new RestException(response.StatusCode, response.ErrorMessage, response.ErrorException); } var result = JsonConvert.DeserializeObject(response.Content, methodInfo.ReturnType); return new ReturnMessage(result, null, 0, methodMessage.LogicalCallContext, methodMessage); } } public enum RequestMethod { Get, Post, } public sealed class RestApiAttribute : Attribute { public string Path { get; set; } public RequestMethod Method { get; set; } } public sealed class RestParamAttribute : Attribute { public string Name { get; } public RestParamAttribute(string name) { Name = name; } } public sealed class RestException : Exception { public HttpStatusCode StatusCode { get; } public RestException(HttpStatusCode statusCode, string errorMessage, Exception errorException) : base(errorMessage, errorException) { StatusCode = statusCode; } } 動かしてみる // SSL関連で必要であれば呼ぶ // ServicePointManager.ServerCertificateValidationCallback = (sender, certificate, chain, sslPolicyErrors) = true; // ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls12; var factory = new RestApiFactory(https://qiita.com); var api = factory.CreateIQiitaApi(); var result = api.GetTags(1, 20, QiitaTagSortMode.Count); foreach (var tagInfo in result) { Console.Write(tagInfo.Id.PadRight(15)); Console.Write(tagInfo.Count.ToString().PadRight(10)); Console.WriteLine(tagInfo.FollowersCount); } [実行結果] JavaScript 21990 48870 Python 21863 41067 Ruby 18711 27500 PHP 13818 30173 Rails 12594 16450 iOS 12455 23069 Android 10915 29762 AWS 10528 5003 Java 10359 31906 Swift 10273 6167 Linux 8773 28311 docker 8226 4966 Git 7125 27652 Node.js 7021 20220 Mac 6631 22047 Unity 5970 3849 C# 5970 17342 MySQL 5301 22457 C\u002B\u002B 5065 19147 Xcode 4844 16773 JavaScriptの記事が一番多いですね。"},{"url":"/articles/72a14c413389404d85f946326a2b2e7e/","date":"2018-11-24","title":"Windows10メモ","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"Windows","url":"/tags/windows/"},{"name":"開発全般","url":"/tags/general-dev/"}],"content":"Windows 10 Pro 備忘録 ショートカット 情報/ツール表示 Win \u002B Pause/Break ： システム情報の表示 Win \u002B A ： アクションセンターを開く Win \u002B I ： 設定画面を開く Win \u002B G ： GameDVR 起動/終了 Win \u002B R ： ファイル名を指定して実行を開く シャットダウン Alt \u002B F4 ： Windowsシャットダウン（タスクバーorデスクトップがアクティブ時） 仮想デスクトップ Ctrl \u002B Win \u002B D ： 新しい仮想デスクトップを作成 Ctrl \u002B Win \u002B ←/→ ： 仮想デスクトップの切り替え Ctrl \u002B Win \u002B F4 ： 仮想デスクトップを閉じる ウィンドウ操作 Alt \u002B F4 ： ウィンドウを閉じる Alt \u002B スペース ： ウィンドウのシステムメニューを表示 Alt \u002B Tab ： ウィンドウ切り替え Win \u002B Tab ： タスクビューの表示/終了 Win \u002B D ： デスクトップを表示/復帰 Win \u002B ↑/↓ ： ウィンドウの最大化/元のサイズに戻す/最小化の切り替え Win \u002B ←/→ ： ウィンドウを左右2分の1にスナップ Win \u002B ↑/↓ ： 左右にスナップした状態で、ウィンドウを上下4分の1にスナップ ゴッドモード ゴッドモードとは、Windows の各種設定にまとめてアクセスできる機能 やり方：新規フォルダを作成し、名前を以下にする 任意の名前.{ED7BA470-8E54-465E-825C-99712043E01C} Windows10 Creators Update以降ではフォルダ名が空白になる問題があるので、ショートカットの作成で以下のパスを設定する explorer.exe shell:::{ED7BA470-8E54-465E-825C-99712043E01C} Windows10のタスクバーで「最近使ったもの」を非表示にする スタートメニュー \u003E 設定 \u003E パーソナル設定 \u003E スタート スタート画面またはタスクバーのジャンプリストに最近開いた項目を表示するをオフ パフォーマンス設定 システム \u003E システムの詳細設定 \u003E 詳細設定 \u003E パフォーマンス メニューが左側に出る場合の対処 レジストリエディタで、以下の設定を行う キー: HKEY_CURRENT_USER\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\MenuDropAlignment 値: 0 タスクマネージャーでGDIオブジェクトの使用数を表示する タスクマネージャー \u003E 詳細タブ \u003E 列ヘッダーで右メニュー \u003E 列の選択 GDIオブジェクトを選択"},{"url":"/articles/a136415738cd4a589fe9a7d1fc5f8687/","date":"2018-11-23","title":"[C#] EnumをJson変換した際のシリアライズ値","category":{"order":2,"name":"Scrap","url":"/categories/scrap/"},"tags":[{"name":"C#","url":"/tags/cs/"},{"name":"JSON","url":"/tags/json/"}],"content":"はじめに Json.NETでEnumをシリアライズした際、どういう値になるのか調べてみました。 Json.NET https://www.nuget.org/packages/Newtonsoft.Json/ FlagsなEnumで試します。 デフォルトの動作 class Program { static void Main(string[] args) { Console.WriteLine(JsonConvert.SerializeObject(Colors.Red)); Console.WriteLine(JsonConvert.SerializeObject(Colors.Red | Colors.Blue)); Console.WriteLine(JsonConvert.SerializeObject(Colors.Red | Colors.Blue | Colors.Yellow)); } } [Flags] public enum Colors { Red = 0x01, Blue = 0x02, Yellow = 0x04, } [実行結果] 1 3 7 デフォルトでは数値として出力されます。 この場合、Json.NETではEnumに特別な属性は指定不要ですが、以下のように書くこともできます。 [Flags] [DataContract] public enum Colors { [EnumMember] Red = 0x01, [EnumMember] Blue = 0x02, [EnumMember] Yellow = 0x04, } 文字列として出力する場合 Json.NETのStringEnumConverterを使用します。 シリアライズ時に指定する方法と、Enum自体に指定する方法と、Enumを保持する側のプロパティに指定する方法があります。 // シリアライズ時に指定する方法（ちなみにデシリアライズ時はStringEnumConverterの指定は不要） JsonConvert.SerializeObject(Colors.Red, new StringEnumConverter()); // Enum自体に指定する方法 [JsonConverter(typeof(StringEnumConverter))] public enum Colors // Enumを保持する側のプロパティに指定する方法 public class Person { [JsonConverter(typeof(StringEnumConverter))] public Colors PersonColors { get; set; } } [実行結果] Red Red, Blue Red, Blue, Yellow 文字列で別名を指定する場合 EnumMember属性でValueを指定します。 この場合も、StringEnumConverterを使用しないと文字列として出力されません。 [Flags] [DataContract] public enum Colors { [EnumMember(Value = 赤)] Red = 0x01, [EnumMember(Value = 青)] Blue = 0x02, [EnumMember(Value = 黄)] Yellow = 0x04, } [実行結果] 赤 赤, 青 赤, 青, 黄 どの方法がいいのか？ 状況に応じてだと思いますが、どの方法でもシリアライズするEnumには明示的にDataContract属性、EnumMember属性を指定した方がいいと思います。 Enumに限った話ではないですが、以下の理由でシリアライズ関連の属性はDataContract系をよく使用します。 シリアライズするモデルクラスについてはシリアライザのベンダーロックインは避けたい DataContract系のオプトイン仕様（属性を付加したものだけがシリアライズ対象になる）が明示的でいい"},{"url":"","date":"","title":"","category":{"order":0,"name":"","url":""},"tags":[],"content":""}]
