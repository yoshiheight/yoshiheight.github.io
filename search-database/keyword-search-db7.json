[{
  "url": "/articles/5ae9067e545146bc918f8ae4ca28f61c/",
  "date": "2020-05-24",
  "title": "[TS] Three.jsでWebGLを試す",
  "category": {
    "order": 0,
    "name": "Demo",
    "url": "/categories/demo/"
  },
  "tags": [
    {
      "name": "3D",
      "url": "/tags/3d/"
    },
    {
      "name": "Three.js",
      "url": "/tags/threejs/"
    },
    {
      "name": "TypeScript",
      "url": "/tags/typescript/"
    }
  ],
  "content": "デモ \u003Cdiv id=\u0022my-progress\u0022\u003E初期化中...\u003C/div\u003E \u003Cdiv id=\u0022my-demo-fps\u0022\u003E\u003C/div\u003E \u003Cdiv id=\u0022my-demo-view\u0022\u003E\u003C/div\u003E はじめに 本屋でオライリーのThree.js本を見かけて面白そうだったので試してみました。 Three.js https://threejs.org/ CDN https://www.jsdelivr.com/package/npm/three 環境構築 npm install three 型定義ファイルは含まれてる ソースコード ThreeDemo.ts \u003Cdiv id=\u0022my-demo-ts-code\u0022\u003E\u003C/div\u003E \u003Cscript src=\u0022/files/threedemo-ts/app/bootloader.js?v=4dbb9813df864993afcfe24b3a44b8f2\u0022\u003E\u003C/script\u003E \u003Cscript\u003E $(async () =\u003E { await ThreeDemo.BootLoader.loadAsync(); await ThreeDemo.Application.start(\u0022#my-demo-view\u0022, \u0022#my-demo-fps\u0022); $(\u0022#my-progress\u0022).hide(); CrashPagesJS.Common.HljsUtil.createBlock(\u0022#my-demo-ts-code\u0022, \u0022ts\u0022, \u0060/files/threedemo-ts/source/ThreeDemo.ts?v=${ThreeDemo.Application.Version}\u0060); }); \u003C/script\u003E"
},{
  "url": "/articles/fd421c4029954c7cbae5b75a125db1fc/",
  "date": "2020-04-15",
  "title": "モバイルディスプレイでVisual Studioを快適に使うための設定",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "Visual Studio",
      "url": "/tags/visualstudio/"
    },
    {
      "name": "開発全般",
      "url": "/tags/general-dev/"
    }
  ],
  "content": "概要 最近、ASUS の MB16AC というモバイルディスプレイをメインで使っているのですが、Visual Studio で表示を見やすくする為に設定変更した箇所について記載します。 前提 Visual Studio 2019 15.6型フルHDディスプレイ Windowsの表示拡大率は100%のまま 備考：もし表示の実サイズを24型ディスプレイと同じにする場合、約150%の拡大率にする必要がある Visual Studio の設定 環境フォント Visual Studio のメニュー等のフォントは変更することができます。 オプション ＞ 環境 ＞ フォントおよび色 設定の表示＝環境 Yu Gothic UI, 11 エディタのフォント とにかく文字の線が細すぎて見づらいので、このフォント変更は必須です。 オプション ＞ 環境 ＞ フォントおよび色 設定の表示＝テキストエディタ Consolas, 14 ナビゲーションバー エディタ上部に配置されている、クラス一覧やメソッド一覧のコンボボックスのやつです。 使用しない人は非表示にしましょう。 オプション ＞ テキストエディタ ナビゲーションバーをオフ Shrink Empty Lines Productivity Power Tools の Shrink Empty Lines を使用することでエディタ内の表示行数を増やすことができます。 https://marketplace.visualstudio.com/items?itemName=VisualStudioPlatformTeam.SyntacticLineCompression 全画面表示 全画面表示した際はテキストエディタだけを表示するようにした方がいいです。 その他 Visual Studio 以外の通常のテキストエディタでもフォント設定は変更した方がいいです。 ASCII文字のフォント Consolas ASCII文字以外のフォント メイリオ にすると見やすいと思います。"
},{
  "url": "/articles/087891ae08fd490d92e090ad3ef0d1f2/",
  "date": "2020-03-05",
  "title": "HTTP通信のキャプチャはFiddlerが便利",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "Fiddler",
      "url": "/tags/fiddler/"
    },
    {
      "name": "開発全般",
      "url": "/tags/general-dev/"
    }
  ],
  "content": "概要 以前から仕事で使用していて便利なので、その紹介です。 https://www.telerik.com/fiddler 元マイクロソフト社員が開発したとかだったはず いつのまにかダウンロード時にメールアドレスの登録が必須になっていて、残念です。。 通信のキャプチャ Fiddler を起動すると自動的に HTTP プロキシとして動作するので、外部の Web サーバーにアクセスする場合は何もしなくても通信がキャプチャ可能 ブラウザのプロキシ設定（というより Windows のプロキシ設定？）についても、Fiddler が起動時に勝手に書き換え、終了時に勝手に元に戻す ローカルホストとの通信や HTTP クライアントが独自実装の場合 IP アドレスに ipv4.fiddler を指定する（厳密には Fiddler の IP/Port 設定にあわせる） 注意点 Fiddler のせいでプロキシ設定がおかしくなったことが過去にあった Fiddler を頻繁に使用している環境で突然ネットに繋がらなくなった場合、プロキシ設定を確認すべし"
},{
  "url": "/articles/b27a5b2ea88d47d09e4364d4da11e266/",
  "date": "2020-01-30",
  "title": "Markdownについてざっくりと",
  "category": {
    "order": 1,
    "name": "Tech",
    "url": "/categories/tech/"
  },
  "tags": [
    {
      "name": "Markdown",
      "url": "/tags/markdown/"
    },
    {
      "name": "開発全般",
      "url": "/tags/general-dev/"
    }
  ],
  "content": "概要 Markdown の記法についてざっくりと記載 自分がよく使っているもの or 今後使うかもしれないもの CommonMark 準拠 Markdown とは 考案 https://daringfireball.net/projects/markdown/ CommonMark Markdown の仕様を詳細まで策定しよう、ということでできた Markdown 方言の一つ https://commonmark.org/ 見出し # 見出し1 ## 見出し2 ### 見出し3（末尾の連続した#は無視される） ############### #### 見出し4 ##### 見出し5 ###### 見出し6 段落 前後を空行にすると段落になる。 なので、この行は別段落になる。 コード コードブロック \u0060\u0060\u0060 ここはコードブロックになる。 \u0060\u0060\u0060 \u0060\u0060\u0060\u0060\u0060\u0060\u0060\u0060\u0060 バッククォート数は3つ以上でも可。 終了のバッククォート数は、開始のバッククォート数以上が必要。 \u0060\u0060\u0060\u0060\u0060\u0060\u0060\u0060\u0060 \u0060\u0060\u0060hoge hoge は code class=language-hoge というように展開される。 \u0060\u0060\u0060 インラインコード \u0060ここはインラインコードになる\u0060 リスト 箇条書き * リスト * リスト * リスト 番号リスト 1. リスト 1. リスト 1. リスト 1. リスト リスト間の空行 1. リスト 1. リスト 1. リスト（間に空行を入れることもできるが、その場合、全てのリストアイテムは段落扱いになる） リストにブロック要素を含める * リスト \u0060\u0060\u0060 あらゆるブロック要素を含めることができる。 前後を空行にする。 インデントは、属するリストの文言部分のインデントと同じにするか、それプラス3文字分までとする。 \u0060\u0060\u0060 * リスト リンク そのままリンク URL 文言リンク [文言](URL) 画像 alt 文言あり ![alt文言](URL) alt 文言なし ![](URL) 引用 引用1 引用2 水平線 ****************** 太字 __太字__ 改行 末尾にバックスラッシュで改行なので、ここは\\ 改行される エスケープ \\# バックスラッシュでエスケープされるので、ここは見出しにはならない HTML のブロック要素 divHTMLのブロック要素がそのまま使える。ブロック要素内のMarkdownは処理されない/div コメント !-- Markdownにはコメントが存在しないので、HTMLコメントで代用する 生成されるHTMLにはコメントそのものが含まれる --"
},{
  "url": "/articles/352e6cf04d564298a009be5d38cb68e9/",
  "date": "2019-11-02",
  "title": "[C#] SpanとRangeを使って配列中の要素を移動させる",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "C#",
      "url": "/tags/cs/"
    }
  ],
  "content": "はじめに SpanとRangeを使って、配列中の要素を移動させる処理を書いてみました。 移動によってできた隙間は、要素型のデフォルト値で埋めています。 ソースコード 環境は .NET Core 3.0 / C# 8.0 using System; #nullable enable class Program { static void Main() { var buffer = new byte[10]; var range = ..3; var span = buffer.AsSpan(); span[range].Fill(1); var offset = 0; range = span.Move(range, offset); Write(buffer, offset); offset = 1; range = span.Move(range, offset); Write(buffer, offset); offset = 3; range = span.Move(range, offset); Write(buffer, offset); offset = 3; range = span.Move(range, offset); Write(buffer, offset); offset = -2; range = span.Move(range, offset); Write(buffer, offset); offset = -5; range = span.Move(range, offset); Write(buffer, offset); // 出力 static void Write(byte[] buffer, int num) { foreach (var elem in buffer) { Console.Write(elem == 1 ? ■ : □); } Console.WriteLine( \u002B (num = 0 ? \u002B : ) \u002B num); } } } static class SampleExtension { /// summary /// スパン内の指定範囲を移動し、移動後の範囲を返す。 /// 移動によってできた隙間は要素型のデフォルト値で埋める。 /// /summary public static Range MoveT(this SpanT span, Range range, int offset) { var srcSpan = span[range]; var dstRange = range.Offset(span.Length, offset); var dstSpan = span[dstRange]; srcSpan.CopyTo(dstSpan); var clearLength = Math.Min(srcSpan.Length, Math.Abs(offset)); var clearRange = (offset = 0) ? ..clearLength : ^clearLength..; srcSpan[clearRange].Clear(); return dstRange; } /// summary /// 範囲をオフセットして返す。 /// /summary public static Range Offset(this Range range, int length, int offset) { var item = range.GetOffsetAndLength(length); return new Range(item.Offset \u002B offset, item.Offset \u002B offset \u002B item.Length); } } 実行結果 ■■■□□□□□□□ \u002B0 □■■■□□□□□□ \u002B1 □□□□■■■□□□ \u002B3 □□□□□□□■■■ \u002B3 □□□□□■■■□□ -2 ■■■□□□□□□□ -5 おわりに SpanとRange便利すぎる！"
},{
  "url": "/articles/3a42096b869d4348a920b05b4c0038c0/",
  "date": "2019-10-19",
  "title": "[C#] IronPythonでC#側のオブジェクトを操作するだけのサンプル",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "C#",
      "url": "/tags/cs/"
    },
    {
      "name": "IronPython",
      "url": "/tags/ironpython/"
    }
  ],
  "content": "はじめに IronPython https://www.nuget.org/packages/IronPython/ ソースコード 環境は .NET Core 3.0 / C# 8.0 using System; using IronPython.Hosting; #nullable enable class Program { static void Main() { var sample = new Sample(); var engine = Python.CreateEngine(); var source = engine.CreateScriptSourceFromString(sample.Num = 100;); var scope = engine.CreateScope(); scope.SetVariable(sample, sample); source.Execute(scope); Console.WriteLine(sample.Num); } } public class Sample { public int Num { get; set; } }"
},{
  "url": "/articles/6bb33eff6daa4d1381d187d61cfa2fd6/",
  "date": "2019-10-18",
  "title": "[C#] DispatchProxyでREST Clientを実装して非同期でQiita APIをたたいてみる",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "C#",
      "url": "/tags/cs/"
    },
    {
      "name": "REST",
      "url": "/tags/rest/"
    },
    {
      "name": "AOP",
      "url": "/tags/aop/"
    }
  ],
  "content": "はじめに 以前書いた以下の記事を .NET Core の DispatchProxy を使用するように変更し、更にRESTでの取得処理を非同期にしました。 透過プロキシでREST Clientを実装してQiita APIをたたいてみる https://crash.jp/pages/b771882b37214e448ddbac04f105f7e0/ ソースコード 環境は .NET Core 3.0 / C# 8.0 using System; using System.Linq; using System.Net; using System.Reflection; using System.Runtime.CompilerServices; using System.Runtime.Serialization; using System.Threading.Tasks; using Newtonsoft.Json; using Newtonsoft.Json.Converters; using Newtonsoft.Json.Linq; using RestSharp; #nullable enable class Program { static async Task Main() { var client = RestClientProxy.CreateIQiitaApiClient(https://qiita.com); foreach (var tagInfo in await client.GetTagsAsync(1, 20, QiitaTagSortMode.Count)) { Console.Write(tagInfo.Id.PadRight(15)); Console.Write(tagInfo.Count.ToString().PadRight(10)); Console.WriteLine(tagInfo.FollowersCount); } } } // 以下、Qiita API クライアント public interface IQiitaApiClient { [RestApi(Path = /api/v2/tags, Method = RequestMethod.Get)] TaskQiitaTagInfo[] GetTagsAsync( [RestParam(page)] int page, [RestParam(per_page)] int perPage, [RestParam(sort)] QiitaTagSortMode sortMode); } [DataContract] public enum QiitaTagSortMode { [EnumMember(Value = count)] Count, [EnumMember(Value = name)] Name, } [DataContract] public sealed class QiitaTagInfo { [DataMember(Name = id)] public string Id { get; set; } = string.Empty; [DataMember(Name = items_count)] public int Count { get; set; } [DataMember(Name = followers_count)] public int FollowersCount { get; set; } } // 以下、共通部品 // DispatchProxyから派生する場合、sealedにはできない。あとpublicなデフォルトコンストラクタが必要 public class RestClientProxy : DispatchProxy { private RestClient _client = null!; public static TRestApiClient CreateTRestApiClient(string baseUrl) where TRestApiClient : class { var proxy = CreateTRestApiClient, RestClientProxy(); ((RestClientProxy)(object)proxy).Init(baseUrl); return proxy; } private void Init(string baseUrl) { _client = new RestClient(baseUrl); } protected override object Invoke(MethodInfo methodInfo, object[] args) { var apiAttr = methodInfo.GetCustomAttributeRestApiAttribute()!; var request = new RestRequest(apiAttr.Path, Enum.ParseMethod(apiAttr.Method.ToString(), true)); var serializer = new JsonSerializer(); serializer.Converters.Add(new StringEnumConverter()); var jsonArgs = JArray.FromObject(args, serializer); var paramInfos = methodInfo.GetParameters(); foreach (var item in jsonArgs.Zip(paramInfos, (arg, paramInfo) = (arg, paramInfo))) { var paramAttr = item.paramInfo.GetCustomAttributeRestParamAttribute()!; request.AddParameter(paramAttr.Name, item.arg); } var resultType = methodInfo.ReturnType.GenericTypeArguments[0]; return ResultTypedTaskFactory.Create( DeserializeResultAsync(_client.ExecuteTaskAsync(request), resultType), resultType); // 戻り値のデシリアライズ static async Taskobject? DeserializeResultAsync(TaskIRestResponse executeTask, Type resultType) { var response = await executeTask.ConfigureAwait(false); if (response.ResponseStatus != ResponseStatus.Completed) { throw new RestException(response.StatusCode, response.ErrorMessage, response.ErrorException); } return JsonConvert.DeserializeObject(response.Content, resultType); } } } public enum RequestMethod { Get, Post, } [AttributeUsage(AttributeTargets.Method)] public sealed class RestApiAttribute : Attribute { public string Path { get; set; } = string.Empty; public RequestMethod Method { get; set; } } [AttributeUsage(AttributeTargets.Parameter)] public sealed class RestParamAttribute : Attribute { public string Name { get; } public RestParamAttribute(string name) { Name = name; } } public sealed class RestException : Exception { public HttpStatusCode StatusCode { get; } public RestException(HttpStatusCode statusCode, string errorMessage, Exception errorException) : base(errorMessage, errorException) { StatusCode = statusCode; } } public static class ResultTypedTaskFactory { public static object Create(Taskobject? task, Type resultType) { var genericType = typeof(TaskInvoker).MakeGenericType(resultType); var taskGetter = (ITaskGetter)Activator.CreateInstance(genericType, task).AsNotNullable(); return taskGetter.ResultTypedTask; } private interface ITaskGetter { object ResultTypedTask { get; } } private sealed class TaskInvokerTResult : ITaskGetter { public object ResultTypedTask { get; } public TaskInvoker(Taskobject? task) { ResultTypedTask = InvokeAsync(); async TaskTResult InvokeAsync() { return (TResult)(await task.ConfigureAwait(false))!; } } } } 実行結果 Python 32273 62544 JavaScript 28966 65017 Ruby 23669 36895 Rails 19410 24176 PHP 17307 40479 AWS 14834 6928 iOS 14642 32042 Android 13140 39289 Java 13062 42886 Swift 12597 6856 Docker 11643 6509 Linux 10820 40215 Node.js 9787 29395 Git 8969 38904 Mac 8198 31382 Python3 8130 3156 Unity 8119 4759 C# 8035 25641 Go 7201 5068 MySQL 6721 32644 おわりに 以前はJavaScriptの記事が一番多かったですが、現在はPythonが多いですね。"
},{
  "url": "/articles/8f834044a63f4cef9d41bb4da9709d4d/",
  "date": "2019-10-11",
  "title": "[C#] async／awaitについてざっくりと",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "C#",
      "url": "/tags/cs/"
    }
  ],
  "content": "説明 今更ですが、async/awaitについて。 非同期処理の呼び出し側の利点 継続処理を同期的に書けるし、try-catchで例外捕捉できる 同期コンテキストにより、継続処理や例外捕捉後の処理を呼び出し側スレッド上で実行できる 非同期メソッドはasyncを指定し、メソッド名のサフィックスはAsync 戻り値はTaskかTask\u003CT\u003E、もしくは同期的な処理のみで終わる場合もあるならValueTaskかValueTask\u003CT\u003E async voidなメソッドは、GUIアプリのイベントハンドラのように、待つ必要がない場合のみ使う async voidなメソッドはawaitで待機できないので 同期コンテキストを使用する必要がない場合は、Task.ConfigureAwait(false)を呼び出しておく その方が効率がいいのと、非同期メソッドを使う側でTask.Wait()されてもデッドロックしない ライブラリ側でタスク開始する場合、リソース的に問題ないか要検討 スレッド数の調整やスケジューリングはアプリ側じゃないと正しく判断できないので ソースコード 環境は .NET Core 3.0 / C# 8.0 using System.Threading.Tasks; using System.Windows.Forms; #nullable enable namespace WindowsFormsApp1 { public partial class Form1 : Form { public Form1() { InitializeComponent(); } protected override async void OnMouseDown(MouseEventArgs e) { base.OnMouseDown(e); var result = await Sample.Test1Async(); Text = result.ToString(); } } } static class Sample { // パターン1 public static async Taskint Test1Async() { await Task.Delay(100).ConfigureAwait(false); await Task.Delay(200).ConfigureAwait(false); return await Task.Factory.StartNew(() = { // なにかの重い処理... return 0; }).ConfigureAwait(false); } // パターン2 public static async Taskint Test2Async() { await Task.Delay(100).ConfigureAwait(false); await Task.Delay(200).ConfigureAwait(false); await Task.Delay(300).ConfigureAwait(false); return 0; } // 同期的な処理だけで返す場合があるパターン public static async ValueTaskint Test3Async(int value) { if (value 0) { return -1; } await Task.Delay(100).ConfigureAwait(false); await Task.Delay(200).ConfigureAwait(false); await Task.Delay(300).ConfigureAwait(false); return 0; } }"
},{
  "url": "/articles/38a4689d90be46a18af46d9679fa01e2/",
  "date": "2019-10-10",
  "title": "[C#] Enum.HasFlagの結果を確認",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "C#",
      "url": "/tags/cs/"
    }
  ],
  "content": "はじめに Enum.HasFlagメソッドの結果を確認してみました。 ついでに数値リテラルに2進数リテラルとアンダースコア区切り文字を使用してみました。 ソースコード 環境は .NET Core 3.0 / C# 8.0 class Program { static void Main() { // 0値に対してHasFlagは使用しないけど試してみる Console.WriteLine(SampleOptions.Default.HasFlag(SampleOptions.Default)); // true Console.WriteLine(SampleOptions.Read.HasFlag(SampleOptions.Default)); // true Console.WriteLine(SampleOptions.ReadWrite.HasFlag(SampleOptions.Read)); // true Console.WriteLine(SampleOptions.ReadWrite.HasFlag(SampleOptions.Write)); // true Console.WriteLine(SampleOptions.Read.HasFlag(SampleOptions.ReadWrite)); // false } } [Flags] public enum SampleOptions { Default = 0b_0000_0000, Read = 0b_0000_0001, Write = 0b_0000_0010, ReadWrite = Read | Write, } おわりに 結果としては当然なんですが、 var hasFlag = (Enum値 確認したいEnum値) == 確認したいEnum値; と同じでした。"
}]
