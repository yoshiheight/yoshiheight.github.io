[{
  "url": "/articles/f638d5988257491e917c4ed14fbf5b38/",
  "date": "2018-11-29",
  "title": "[C#] Socketを使ってP2Pでやりとりするチャットアプリを作る",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "C#",
      "url": "/tags/cs/"
    },
    {
      "name": "Socket",
      "url": "/tags/socket/"
    },
    {
      "name": "P2P",
      "url": "/tags/p2p/"
    }
  ],
  "content": "はじめに Socketを使ってTCPで非同期P2Pでやりとりするチャットアプリサンプルを作ってみました。 GUIイメージ画像 構成 「通信ライブラリ」と「画面」に分けます。 ・通信ライブラリ側 ITcpSerializer.cs 送受信するメッセージのシリアライザ用インターフェイス TcpPeer.cs TCPで非同期P2P通信するクラス ・画面側 MainWindow.xaml 画面 StringSerializer.cs メッセージシリアライザ 通信ライブラリ側 送受信するデータのシリアライザは画面側が実装するので、通信ライブラリ側ではインターフェイスを提供します。 public interface ITcpSerializerTMessage { void Serialize(Stream stream, TMessage message); TMessage Deserialize(Stream stream); } TcpPeerは一番重要な送受信する為のクラスです。 // TCPで非同期P2P通信するクラス public sealed class TcpPeerTMessage where TMessage : class { public event ActionTMessage Sended; public event ActionTMessage Recved; private Socket _socket; private ITcpSerializerTMessage _serializer; private SynchronizationContext _sc = SynchronizationContext.Current; private ConcurrentQueueTMessage _sendQueue = new ConcurrentQueueTMessage(); // コンストラクタ（接続待機側で、相手からの接続要求Socketに対して使用） public TcpPeer(Socket socket, ITcpSerializerTMessage serializer) { _socket = socket; _serializer = serializer; } // コンストラクタ（接続する側で使用） public TcpPeer(ITcpSerializerTMessage serializer) { _socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); _serializer = serializer; } // 指定のIPアドレス・ポートに接続する public async Task ConnectAsync(string ipAddr, int port) { await Task.Factory.StartNew(() = _socket.Connect(IPAddress.Parse(ipAddr), port)); } // 非同期送受信を開始する public async Task StartMessagingAsync() { try { await Task.WhenAll( Task.Factory.StartNew(DoSendMain, TaskCreationOptions.LongRunning), Task.Factory.StartNew(DoRecvMain, TaskCreationOptions.LongRunning)); } finally { _socket.Close(); } } // メッセージ送信 public void Send(TMessage message) { _sendQueue.Enqueue(message); } // 送信キュー内の全てのメッセージが送信された後、送受信を終了させる public void Terminate() { _sendQueue.Enqueue(null); } // 送信メイン private void DoSendMain() { try { using (var stream = new NetworkStream(_socket, FileAccess.Write, false)) { while (_socket.Connected) { if (_sendQueue.TryDequeue(out var message)) { if (message == null) { break; } _serializer.Serialize(stream, message); stream.Flush(); _sc.Post(_ = Sended?.Invoke(message), null); } else { // CPU占有回避（本来はManualResetEventを使ってキューに追加された時だけ処理する方がいい） Thread.Sleep(1); } } } } finally { _socket.Shutdown(SocketShutdown.Send); } } // 受信メイン private void DoRecvMain() { try { using (var stream = new NetworkStream(_socket, FileAccess.Read, false)) { var peekBuff = new byte[1]; while (_socket.Receive(peekBuff, SocketFlags.Peek) 0) { var message = _serializer.Deserialize(stream); _sc.Post(_ = Recved?.Invoke(message), null); } } } finally { Terminate(); } } } TcpPeerは実装をシンプルにする為、以下のようにしています。 送信用と受信用にスレッドを用意 Socketクラスはスレッドセーフなので同期の必要はない Task、async/awaitを使用 送信キューを用意 画面側への通知にはSynchronizationContextを使用 通信終了時の処理フローは以下です。 自分が送信側をシャットダウン 相手の受信側が終わる 相手が送信側シャットダウン 自分の受信側が終わる 画面側 送受信に使用するメッセージクラスとシリアライザ（つまり通信プロトコルにあたる部分）は画面側で用意します。 今回はメッセージクラスは用意せずstringをそのまま使うことにして、シリアライザのみ用意します。 // メッセージシリアライザ public sealed class StringSerializer : ITcpSerializerstring { // シリアライズ public void Serialize(Stream stream, string message) { var bytes = Encoding.UTF8.GetBytes(message); // データ長の書き込み stream.WriteByte((byte)bytes.Length); // データの書き込み stream.Write(bytes, 0, bytes.Length); } // デシリアライズ public string Deserialize(Stream stream) { // データ長の読み込み var len = stream.ReadByte(); // データの読み込み return Encoding.UTF8.GetString(ReadDataFromNetwork(stream, len)); } // ネットワークストリームからバイト列を読み込む private static byte[] ReadDataFromNetwork(Stream stream, int readLength) { // ネットワークの場合、一度に読み込めるとは限らないのでループする var buffer = new byte[readLength]; var readTotal = 0; while (readTotal readLength) { readTotal \u002B= stream.Read(buffer, readTotal, readLength - readTotal); } return buffer; } } 画面レイアウトはXAMLで適当に作ってください。 Window x:Class=WpfTcpChat.MainWindow xmlns=http://schemas.microsoft.com/winfx/2006/xaml/presentation xmlns:x=http://schemas.microsoft.com/winfx/2006/xaml xmlns:d=http://schemas.microsoft.com/expression/blend/2008 xmlns:mc=http://schemas.openxmlformats.org/markup-compatibility/2006 mc:Ignorable=d Title=TCP P2P Chat Height=250 Width=300 DockPanel StackPanel DockPanel.Dock=Top Orientation=Horizontal Button Content=待機を開始 Click=WaitButton_Click Margin=4 / Button Content=接続 Click=ConnectButton_Click Margin=4 / /StackPanel DockPanel DockPanel.Dock=Bottom Button DockPanel.Dock=Right IsDefault=True Content=送信 Click=SendButton_Click / TextBox Name=textboxInput / /DockPanel TextBox Name=textboxChatContent AcceptsReturn=True IsReadOnly=True VerticalScrollBarVisibility=Visible / /DockPanel /Window 画面側の処理は通信ライブラリを使うだけで、いたってシンプルです。 private TcpPeerstring _peer; // チャットのメイン処理 private async void ChatProc() { // メッセージを送受信した際のイベント処理 _peer.Sended \u002B= message = textboxChatContent.AppendText($ 自分: {message}\\n); _peer.Recved \u002B= message = textboxChatContent.AppendText($ 相手: {message}\\n); textboxChatContent.AppendText(チャット開始\\n); await _peer.StartMessagingAsync(); textboxChatContent.AppendText(チャット終了\\n); } // 相手からの接続を待機する private async void WaitButton_Click(object sender, RoutedEventArgs e) { textboxChatContent.AppendText(待機中...\\n); var listener = new TcpListener(new IPEndPoint(IPAddress.Any, 10000)); listener.Start(); var socket = await listener.AcceptSocketAsync(); listener.Stop(); _peer = new TcpPeerstring(socket, new StringSerializer()); ChatProc(); } // 相手に接続する private async void ConnectButton_Click(object sender, RoutedEventArgs e) { textboxChatContent.AppendText(接続中...\\n); _peer = new TcpPeerstring(new StringSerializer()); await _peer.ConnectAsync(127.0.0.1, 10000); ChatProc(); } // メッセージを送信する private void SendButton_Click(object sender, RoutedEventArgs e) { if (string.IsNullOrEmpty(textboxInput.Text)) { // 終了 _peer.Terminate(); return; } // メッセージ送信 _peer.Send(textboxInput.Text); textboxInput.Clear(); } おわりに async/await（エイシンク/アウェイト）最高！！"
},{
  "url": "/articles/c963f0fbaf4e4adf9a7a391c725b6858/",
  "date": "2018-11-28",
  "title": "[C#] .NET CoreでT4Templateを使う場合の注意点",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "C#",
      "url": "/tags/cs/"
    },
    {
      "name": "T4Template",
      "url": "/tags/t4template/"
    },
    {
      "name": ".NET Core",
      "url": "/tags/netcore/"
    }
  ],
  "content": "はじめに Visual Studio で .NET Core プロジェクトに T4Template を追加すると、とある問題が発生しており（自分の環境だけかもしれませんが）、その回避方法について記載します。 環境 Visual Studio Community 2017 Version 15.9.3 .NET Core 2.1 コンソールアプリ ランタイムテキストテンプレート 現象 ランタイムテキストテンプレートを新規追加すると、以下の現象が発生する。 常に発生 砂時計アイコンのままになってしまい、動作も重く操作がままならない（Visual Studio を再起動するまで続く） たまに発生 Visual Studio でランタイムテキストテンプレートのプロパティを確認すると、カスタムツールが TextTemplatingFileGenerator になっている（正しくは TextTemplatingFilePreprocessor） 回避方法 テキストファイルを新規作成し、プロパティのカスタムツールに以下を設定する TextTemplatingFilePreprocessor 更にファイルの先頭に以下のコードを記載する #@ template language=C# # #@ assembly name=System.Core # #@ import namespace=System.Linq # #@ import namespace=System.Text # #@ import namespace=System.Collections.Generic # 任意だが、テキストファイルの拡張子を「.tt」など、分かりやすいものに変更する リビルド もう一つ注意点 .NET Core 2.1 には CodeDom が含まれていない為、T4Template でビルドエラーになります。NuGet から追加する必要があります。 CodeDom https://www.nuget.org/packages/System.CodeDom/ おわりに T4Template は外部ファイル化はできないのですが、 \u003C# #\u003E の間に C# コードをそのまま記述できるという学習コストの低さと、 構文エラーをビルド時に見つけてくれるという利点があります。 今後も使う機会はあるので、この現象が Visual Studio の不具合であれば今後改善されることを期待します。"
},{
  "url": "/articles/b771882b37214e448ddbac04f105f7e0/",
  "date": "2018-11-26",
  "title": "[C#] 透過プロキシでREST Clientを実装してQiita APIをたたいてみる",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "C#",
      "url": "/tags/cs/"
    },
    {
      "name": "REST",
      "url": "/tags/rest/"
    },
    {
      "name": "AOP",
      "url": "/tags/aop/"
    }
  ],
  "content": "はじめに RestSharpを試してみようと思い、Qiita APIでタグ一覧を取得してみました。 https://qiita.com/api/v2/docs 普通にRestSharpを使うのでは面白くないので、 以下のようにインターフェイスを用意すれば簡単にREST Clientが作れる仕組みを実装してみます。 // こんな風にRESTクライアントを定義 public interface IQiitaApi { [RestApi(Path = /api/v2/tags, Method = RequestMethod.Get)] QiitaTagInfo[] GetTags( [RestParam(page)] int page, [RestParam(per_page)] int perPage, [RestParam(sort)] QiitaTagSortMode sortMode); } [DataContract] public enum QiitaTagSortMode { [EnumMember(Value = count)] Count, [EnumMember(Value = name)] Name, } // 関係ないけど、あえて [JsonObject(MemberSerialization.OptIn)] を試す [JsonObject(MemberSerialization.OptIn)] public sealed class QiitaTagInfo { [JsonProperty(id)] public string Id { get; set; } [JsonProperty(items_count)] public int Count { get; set; } [JsonProperty(followers_count)] public int FollowersCount { get; set; } } // こんな風に使う var factory = new RestApiFactory(https://qiita.com); var api = factory.CreateIQiitaApi(); var result = api.GetTags(1, 20, QiitaTagSortMode.Count); 実装 使用ライブラリ RestSharp https://www.nuget.org/packages/RestSharp/ Json.NET https://www.nuget.org/packages/Newtonsoft.Json/ C#でAOP（アスペクト指向的）なことを実現するにはRealProxyクラスを使用します。 public sealed class RestApiFactory { private readonly string _baseUrl; public RestApiFactory(string baseUrl) { _baseUrl = baseUrl; } public TApi CreateTApi() { var proxy = new RestApiProxyTApi(_baseUrl); return (TApi)proxy.GetTransparentProxy(); } } public sealed class RestApiProxyTApi : RealProxy { private readonly RestClient _client; public RestApiProxy(string baseUrl) : base(typeof(TApi)) { _client = new RestClient(baseUrl); } public override IMessage Invoke(IMessage message) { var methodMessage = (IMethodCallMessage)message; var methodInfo = (MethodInfo)methodMessage.MethodBase; var apiAttr = methodInfo.GetCustomAttributeRestApiAttribute(); var request = new RestRequest(apiAttr.Path, (Method)Enum.Parse(typeof(Method), apiAttr.Method.ToString(), true)); var serializer = new JsonSerializer(); serializer.Converters.Add(new StringEnumConverter()); var args = JArray.FromObject(methodMessage.Args, serializer); var paramInfos = methodMessage.MethodBase.GetParameters(); foreach (var item in args.Zip(paramInfos, (arg, paramInfo) = new { arg, paramInfo })) { var paramAttr = item.paramInfo.GetCustomAttributeRestParamAttribute(); request.AddParameter(paramAttr.Name, item.arg); } var response = _client.Execute(request); if (response.ResponseStatus != ResponseStatus.Completed) { throw new RestException(response.StatusCode, response.ErrorMessage, response.ErrorException); } var result = JsonConvert.DeserializeObject(response.Content, methodInfo.ReturnType); return new ReturnMessage(result, null, 0, methodMessage.LogicalCallContext, methodMessage); } } public enum RequestMethod { Get, Post, } public sealed class RestApiAttribute : Attribute { public string Path { get; set; } public RequestMethod Method { get; set; } } public sealed class RestParamAttribute : Attribute { public string Name { get; } public RestParamAttribute(string name) { Name = name; } } public sealed class RestException : Exception { public HttpStatusCode StatusCode { get; } public RestException(HttpStatusCode statusCode, string errorMessage, Exception errorException) : base(errorMessage, errorException) { StatusCode = statusCode; } } 動かしてみる // SSL関連で必要であれば呼ぶ // ServicePointManager.ServerCertificateValidationCallback = (sender, certificate, chain, sslPolicyErrors) = true; // ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls12; var factory = new RestApiFactory(https://qiita.com); var api = factory.CreateIQiitaApi(); var result = api.GetTags(1, 20, QiitaTagSortMode.Count); foreach (var tagInfo in result) { Console.Write(tagInfo.Id.PadRight(15)); Console.Write(tagInfo.Count.ToString().PadRight(10)); Console.WriteLine(tagInfo.FollowersCount); } [実行結果] JavaScript 21990 48870 Python 21863 41067 Ruby 18711 27500 PHP 13818 30173 Rails 12594 16450 iOS 12455 23069 Android 10915 29762 AWS 10528 5003 Java 10359 31906 Swift 10273 6167 Linux 8773 28311 docker 8226 4966 Git 7125 27652 Node.js 7021 20220 Mac 6631 22047 Unity 5970 3849 C# 5970 17342 MySQL 5301 22457 C\u002B\u002B 5065 19147 Xcode 4844 16773 JavaScriptの記事が一番多いですね。"
},{
  "url": "/articles/72a14c413389404d85f946326a2b2e7e/",
  "date": "2018-11-24",
  "title": "Windows10メモ",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "Windows",
      "url": "/tags/windows/"
    },
    {
      "name": "開発全般",
      "url": "/tags/general-dev/"
    }
  ],
  "content": "Windows 10 Pro 備忘録 ショートカット 情報/ツール表示 Win \u002B Pause/Break ： システム情報の表示 Win \u002B A ： アクションセンターを開く Win \u002B I ： 設定画面を開く Win \u002B G ： GameDVR 起動/終了 Win \u002B R ： ファイル名を指定して実行を開く シャットダウン Alt \u002B F4 ： Windowsシャットダウン（タスクバーorデスクトップがアクティブ時） 仮想デスクトップ Ctrl \u002B Win \u002B D ： 新しい仮想デスクトップを作成 Ctrl \u002B Win \u002B ←/→ ： 仮想デスクトップの切り替え Ctrl \u002B Win \u002B F4 ： 仮想デスクトップを閉じる ウィンドウ操作 Alt \u002B F4 ： ウィンドウを閉じる Alt \u002B スペース ： ウィンドウのシステムメニューを表示 Alt \u002B Tab ： ウィンドウ切り替え Win \u002B Tab ： タスクビューの表示/終了 Win \u002B D ： デスクトップを表示/復帰 Win \u002B ↑/↓ ： ウィンドウの最大化/元のサイズに戻す/最小化の切り替え Win \u002B ←/→ ： ウィンドウを左右2分の1にスナップ Win \u002B ↑/↓ ： 左右にスナップした状態で、ウィンドウを上下4分の1にスナップ ゴッドモード ゴッドモードとは、Windows の各種設定にまとめてアクセスできる機能 やり方：新規フォルダを作成し、名前を以下にする 任意の名前.{ED7BA470-8E54-465E-825C-99712043E01C} Windows10 Creators Update以降ではフォルダ名が空白になる問題があるので、ショートカットの作成で以下のパスを設定する explorer.exe shell:::{ED7BA470-8E54-465E-825C-99712043E01C} Windows10のタスクバーで「最近使ったもの」を非表示にする スタートメニュー \u003E 設定 \u003E パーソナル設定 \u003E スタート スタート画面またはタスクバーのジャンプリストに最近開いた項目を表示するをオフ パフォーマンス設定 システム \u003E システムの詳細設定 \u003E 詳細設定 \u003E パフォーマンス メニューが左側に出る場合の対処 レジストリエディタで、以下の設定を行う キー: HKEY_CURRENT_USER\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\MenuDropAlignment 値: 0 タスクマネージャーでGDIオブジェクトの使用数を表示する タスクマネージャー \u003E 詳細タブ \u003E 列ヘッダーで右メニュー \u003E 列の選択 GDIオブジェクトを選択"
},{
  "url": "/articles/a136415738cd4a589fe9a7d1fc5f8687/",
  "date": "2018-11-23",
  "title": "[C#] EnumをJson変換した際のシリアライズ値",
  "category": {
    "order": 2,
    "name": "Scrap",
    "url": "/categories/scrap/"
  },
  "tags": [
    {
      "name": "C#",
      "url": "/tags/cs/"
    },
    {
      "name": "JSON",
      "url": "/tags/json/"
    }
  ],
  "content": "はじめに Json.NETでEnumをシリアライズした際、どういう値になるのか調べてみました。 Json.NET https://www.nuget.org/packages/Newtonsoft.Json/ FlagsなEnumで試します。 デフォルトの動作 class Program { static void Main(string[] args) { Console.WriteLine(JsonConvert.SerializeObject(Colors.Red)); Console.WriteLine(JsonConvert.SerializeObject(Colors.Red | Colors.Blue)); Console.WriteLine(JsonConvert.SerializeObject(Colors.Red | Colors.Blue | Colors.Yellow)); } } [Flags] public enum Colors { Red = 0x01, Blue = 0x02, Yellow = 0x04, } [実行結果] 1 3 7 デフォルトでは数値として出力されます。 この場合、Json.NETではEnumに特別な属性は指定不要ですが、以下のように書くこともできます。 [Flags] [DataContract] public enum Colors { [EnumMember] Red = 0x01, [EnumMember] Blue = 0x02, [EnumMember] Yellow = 0x04, } 文字列として出力する場合 Json.NETのStringEnumConverterを使用します。 シリアライズ時に指定する方法と、Enum自体に指定する方法と、Enumを保持する側のプロパティに指定する方法があります。 // シリアライズ時に指定する方法（ちなみにデシリアライズ時はStringEnumConverterの指定は不要） JsonConvert.SerializeObject(Colors.Red, new StringEnumConverter()); // Enum自体に指定する方法 [JsonConverter(typeof(StringEnumConverter))] public enum Colors // Enumを保持する側のプロパティに指定する方法 public class Person { [JsonConverter(typeof(StringEnumConverter))] public Colors PersonColors { get; set; } } [実行結果] Red Red, Blue Red, Blue, Yellow 文字列で別名を指定する場合 EnumMember属性でValueを指定します。 この場合も、StringEnumConverterを使用しないと文字列として出力されません。 [Flags] [DataContract] public enum Colors { [EnumMember(Value = 赤)] Red = 0x01, [EnumMember(Value = 青)] Blue = 0x02, [EnumMember(Value = 黄)] Yellow = 0x04, } [実行結果] 赤 赤, 青 赤, 青, 黄 どの方法がいいのか？ 状況に応じてだと思いますが、どの方法でもシリアライズするEnumには明示的にDataContract属性、EnumMember属性を指定した方がいいと思います。 Enumに限った話ではないですが、以下の理由でシリアライズ関連の属性はDataContract系をよく使用します。 シリアライズするモデルクラスについてはシリアライザのベンダーロックインは避けたい DataContract系のオプトイン仕様（属性を付加したものだけがシリアライズ対象になる）が明示的でいい"
}]
